/*
 * Copyright 2017-2018 Volvo Car Corporation
 * This file is covered by LICENSE file in the root of this project
 */

package com.volvocars.brightnessservice;

import android.util.Log;
import java.io.*;
import android.os.*;
import java.util.concurrent.*;

/**
 *
 * DimmingMonitor
 * Keeps track of the dimming state of the display.
 * Provides callbacks to interested parties if the display is
 * dimmed or not due to user in-activity.
 */

/**
 * This implmentation use an ugly solution similar to parsing the output
 * from the console command "dumpsys display". This shall be changed when
 * real support is available (in Q?) to read the display status (BRIGHT/DIMMED)
 */

public class DimmingMonitor {
    public static final String TAG = "BrightnessService.dimmon";

    private ScheduledExecutorService mTimer;
    private ParcelFileDescriptor mPfds[];
    private DimmingCallback mCallback;
    private State mLastState = State.UNKNOWN;

    public DimmingMonitor(DimmingCallback callback) {
        mCallback = callback;
        mTimer = Executors.newSingleThreadScheduledExecutor();;
        init();
    }

    public enum State {
        UNKNOWN,
        BRIGHT,
        DIMMED
    }

    public interface DimmingCallback {
        public void onDisplayStateChanged(State state);
    }

    private void init() {
        //  See impl of dumpsys for this hack
        IBinder displaycontrollerservice = ServiceManager.getService("display");
        if (displaycontrollerservice!=null) {
            try {
                mPfds = ParcelFileDescriptor.createPipe();
                final FileDescriptor write_fd = mPfds[1].getFileDescriptor(); // displaycontrollerservice writes to this FD
                final FileDescriptor read_fd =  mPfds[0].getFileDescriptor(); // readDump() reads from this FD
                mTimer.scheduleAtFixedRate( // Start polling timer
                    () -> pollDump(displaycontrollerservice, write_fd),
                    10, // first poll after 10 secs
                    10, // sub-sequent polls with 10secs interval
                    TimeUnit.SECONDS);

                // Start read-thread. Will continuously read the
                // output generated by "pollDump"
                new Thread(() -> readDump(read_fd)).start();
            } catch (Exception e) {
                Log.e(TAG, e.getMessage());
            }

        } else {
            Log.w(TAG, "Could not find display service");
        }
    }

    private void pollDump(IBinder displaycontroller, final FileDescriptor write_fd) {
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
        try {
            Log.v(TAG, "dumping...");
            displaycontroller.dump(write_fd, new String[0]);
        } catch (Exception e) {
            Log.e(TAG, e.getMessage());
        }
    }

    private void readDump(final FileDescriptor read_fd) {
        Log.i(TAG, "readDumpSys thread started");
        // We don't want this thread to "block" any other job going on
        // so lets set prio to lowest possible
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
        Reader r = new InputStreamReader(new FileInputStream(read_fd));
        BufferedReader br = new BufferedReader(r);
        while(true) {
            try {
                String line = br.readLine();
                // We are looking for lines with this kind of content: "mAppliedDimming=false|true"
                if (line.contains("mAppliedDimming")) {
                    // now for true & false
                    if (line.contains("true")) {
                        if (mLastState!=State.DIMMED) {
                            mLastState = State.DIMMED;
                            mCallback.onDisplayStateChanged(mLastState);
                        }
                    } else if(mLastState!=State.BRIGHT) { // We rely on that "false" is in string
                        mLastState = State.BRIGHT;
                        mCallback.onDisplayStateChanged(mLastState);
                    }
                }

            } catch(Exception e) {
                Log.e(TAG, "readDump fail, exiting read-thread: "+e.getMessage());
                return;
            }
        }
    }
}