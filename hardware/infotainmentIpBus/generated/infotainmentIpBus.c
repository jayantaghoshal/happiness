/*
 * Copyright 2017 Volvo Car Corporation
 * This file is covered by LICENSE file in the root of this project
 */

//
// infotainmentIpBus.c
//
// Code automatically generated by asnparse.$Revision: 1.56 $ $Date: 2012/04/12 09:02:11CEST $ GMT
// Generated: 11:35:14 fredag 2016 december 23
// ASN File: C:\temp\icup\ihu_infotainment-ip-service\libasn1\spec\infotainmentIpBus.asn time:12:19:18 tisdag 2016
// november 1
//

#include "infotainmentIpBus.h"

/* "Friendly" functions from pl/asn_base/asn_base.h */
ASN_Result ASN_Stream_GetResult(ASN_Stream stream);
ASN_Result ASN_Session_GetResult(ASN_Session session);

/* Defines */
#define ASN_MAX(a, b) ((a > b) ? a : b)

// Find the index for value in an array
static U32 findIndex(U32 value, const U32 *ordinalArray, U32 arraySize) {
    U32 index;
    for (index = 0; index < arraySize; index++) {
        if (value == ordinalArray[index]) {
            return index;
        }
    }
    return arraySize;  // The value was not found
}
/*
 * Start of Icb_VccPduHeader of type ASNSequence
 */

Icb_VccPduHeader Icb_VccPduHeader_Create(ASN_Session session) {
    Icb_VccPduHeader value = (Icb_VccPduHeader)ASN_Malloc(session, sizeof(struct Icb_VccPduHeader_t));
    if (value != (Icb_VccPduHeader)NULL) {
        value->serviceId = 0;
        value->operationId = 0;
        value->msgLength = 0;
        value->senderHandle = 0;
        value->protocolVersion = 0;
        value->operationType = 0;
        value->dataType = 0;
        value->reservedII = 0;
    }
    return value;
}

U32 Icb_VccPduHeader_EncodedSize(Icb_VccPduHeader ThisPtr) {
    U32 length = 0;
    length += U32_EncodedSize(ThisPtr->serviceId, 0, 65535);
    length += U32_EncodedSize(ThisPtr->operationId, 0, 65535);
    length += U32_EncodedSize(ThisPtr->msgLength, 0, 4294967295U);
    length += U32_EncodedSize(ThisPtr->senderHandle, 0, 4294967295U);
    length += U32_EncodedSize(ThisPtr->protocolVersion, 0, 255);
    length += U32_EncodedSize(ThisPtr->operationType, 0, 255);
    length += U32_EncodedSize(ThisPtr->dataType, 0, 255);
    length += U32_EncodedSize(ThisPtr->reservedII, 0, 255);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_VccPduHeader_SessionSize() {
    U32 length = sizeof(struct Icb_VccPduHeader_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_VccPduHeader_Print(Icb_VccPduHeader ThisPtr) {
    ASN_PrintIndented("serviceId" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->serviceId);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("operationId" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->operationId);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("msgLength" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->msgLength);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("senderHandle" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->senderHandle);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("protocolVersion" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->protocolVersion);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("operationType" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->operationType);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("dataType" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->dataType);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("reservedII" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->reservedII);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_VccPduHeader_Decode(Icb_VccPduHeader ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->serviceId, session, stream, 0, 65535));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->operationId, session, stream, 0, 65535));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->msgLength, session, stream, 0, 4294967295U));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->senderHandle, session, stream, 0, 4294967295U));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->protocolVersion, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->operationType, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->dataType, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->reservedII, session, stream, 0, 255));
    return ASN_RESULT_OK;
}

ASN_Result Icb_VccPduHeader_Encode(Icb_VccPduHeader ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->serviceId, stream, 0, 65535));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->operationId, stream, 0, 65535));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->msgLength, stream, 0, 4294967295U));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->senderHandle, stream, 0, 4294967295U));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->protocolVersion, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->operationType, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->dataType, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->reservedII, stream, 0, 255));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_VccPduHeader of type ASNSequence
 */

static const U32 Icb_ErrorCode_EnumMap[] = {
        e_Icb_ErrorCode_notOk,                   /* Index = 0 */
        e_Icb_ErrorCode_serviceIdNotAvailable,   /* Index = 1 */
        e_Icb_ErrorCode_operationIdNotAvailable, /* Index = 2 */
        e_Icb_ErrorCode_opTypeNotAvailable,      /* Index = 3 */
        e_Icb_ErrorCode_invalidProtocolVersion,  /* Index = 4 */
        e_Icb_ErrorCode_segmentationError,       /* Index = 5 */
        e_Icb_ErrorCode_invalidLength,           /* Index = 6 */
        e_Icb_ErrorCode_applicationError,        /* Index = 7 */
        e_Icb_ErrorCode_timeout,                 /* Index = 8 */
        e_Icb_ErrorCode_busy,                    /* Index = 9 */
        e_Icb_ErrorCode_incorrectState,          /* Index = 10 */
        e_Icb_ErrorCode_incorrectCode,           /* Index = 11 */
        e_Icb_ErrorCode_incorrectCodePuk,        /* Index = 12 */
        e_Icb_ErrorCode_asn1decodeError,         /* Index = 13 */
        e_Icb_ErrorCode_parameterInvalid         /* Index = 14 */
};

ASN_Result Icb_ErrorCode_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 14, FALSE));

    if (*val >= 15) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_ErrorCode_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_ErrorCode_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_ErrorCode_EnumMap, 15);

    if (index == 15) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 14, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_ErrorCode_Print(Icb_ErrorCode value) {
    switch (value) {
        case e_Icb_ErrorCode_notOk:
            ASN_PrintIndented("notOk" EOL);
            break;
        case e_Icb_ErrorCode_serviceIdNotAvailable:
            ASN_PrintIndented("serviceIdNotAvailable" EOL);
            break;
        case e_Icb_ErrorCode_operationIdNotAvailable:
            ASN_PrintIndented("operationIdNotAvailable" EOL);
            break;
        case e_Icb_ErrorCode_opTypeNotAvailable:
            ASN_PrintIndented("opTypeNotAvailable" EOL);
            break;
        case e_Icb_ErrorCode_invalidProtocolVersion:
            ASN_PrintIndented("invalidProtocolVersion" EOL);
            break;
        case e_Icb_ErrorCode_segmentationError:
            ASN_PrintIndented("segmentationError" EOL);
            break;
        case e_Icb_ErrorCode_invalidLength:
            ASN_PrintIndented("invalidLength" EOL);
            break;
        case e_Icb_ErrorCode_applicationError:
            ASN_PrintIndented("applicationError" EOL);
            break;
        case e_Icb_ErrorCode_timeout:
            ASN_PrintIndented("timeout" EOL);
            break;
        case e_Icb_ErrorCode_busy:
            ASN_PrintIndented("busy" EOL);
            break;
        case e_Icb_ErrorCode_incorrectState:
            ASN_PrintIndented("incorrectState" EOL);
            break;
        case e_Icb_ErrorCode_incorrectCode:
            ASN_PrintIndented("incorrectCode" EOL);
            break;
        case e_Icb_ErrorCode_incorrectCodePuk:
            ASN_PrintIndented("incorrectCodePuk" EOL);
            break;
        case e_Icb_ErrorCode_asn1decodeError:
            ASN_PrintIndented("asn1decodeError" EOL);
            break;
        case e_Icb_ErrorCode_parameterInvalid:
            ASN_PrintIndented("parameterInvalid" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_DateTime of type ASNSequence
 */

Icb_DateTime Icb_DateTime_Create(ASN_Session session) {
    Icb_DateTime value = (Icb_DateTime)ASN_Malloc(session, sizeof(struct Icb_DateTime_t));
    if (value != (Icb_DateTime)NULL) {
        value->year = 0;
        value->month = 0;
        value->day = 0;
        value->hour = 0;
        value->minute = 0;
        value->second = 0;
    }
    return value;
}

U32 Icb_DateTime_EncodedSize(Icb_DateTime ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->year, 2000, 2127);
    length += U32_EncodedSize(ThisPtr->month, 1, 12);
    length += U32_EncodedSize(ThisPtr->day, 1, 31);
    length += U32_EncodedSize(ThisPtr->hour, 0, 23);
    length += U32_EncodedSize(ThisPtr->minute, 0, 59);
    length += U32_EncodedSize(ThisPtr->second, 0, 59);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_DateTime_SessionSize() {
    U32 length = sizeof(struct Icb_DateTime_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_DateTime_Print(Icb_DateTime ThisPtr) {
    ASN_PrintIndented("year" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->year);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("month" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->month);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("day" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->day);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("hour" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->hour);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("minute" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->minute);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("second" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->second);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_DateTime_Decode(Icb_DateTime ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->year, session, stream, 2000, 2127));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->month, session, stream, 1, 12));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->day, session, stream, 1, 31));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->hour, session, stream, 0, 23));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->minute, session, stream, 0, 59));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->second, session, stream, 0, 59));
    return ASN_RESULT_OK;
}

ASN_Result Icb_DateTime_Encode(Icb_DateTime ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->year, stream, 2000, 2127));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->month, stream, 1, 12));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->day, stream, 1, 31));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->hour, stream, 0, 23));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->minute, stream, 0, 59));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->second, stream, 0, 59));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_DateTime of type ASNSequence
 */

static const U32 Icb_SourceStatus_EnumMap[] = {
        e_Icb_SourceStatus_unidentified, /* Index = 0 */
        e_Icb_SourceStatus_trusted,      /* Index = 1 */
        e_Icb_SourceStatus_callCenter,   /* Index = 2 */
        e_Icb_SourceStatus_psap,         /* Index = 3 */
        e_Icb_SourceStatus_outgoing      /* Index = 4 */
};

ASN_Result Icb_SourceStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 4, FALSE));

    if (*val >= 5) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_SourceStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_SourceStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_SourceStatus_EnumMap, 5);

    if (index == 5) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 4, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_SourceStatus_Print(Icb_SourceStatus value) {
    switch (value) {
        case e_Icb_SourceStatus_unidentified:
            ASN_PrintIndented("unidentified" EOL);
            break;
        case e_Icb_SourceStatus_trusted:
            ASN_PrintIndented("trusted" EOL);
            break;
        case e_Icb_SourceStatus_callCenter:
            ASN_PrintIndented("callCenter" EOL);
            break;
        case e_Icb_SourceStatus_psap:
            ASN_PrintIndented("psap" EOL);
            break;
        case e_Icb_SourceStatus_outgoing:
            ASN_PrintIndented("outgoing" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_OnOffStatus_EnumMap[] = {
        e_Icb_OnOffStatus_off,    /* Index = 0 */
        e_Icb_OnOffStatus_on,     /* Index = 1 */
        e_Icb_OnOffStatus_unknown /* Index = 2 */
};

ASN_Result Icb_OnOffStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_OnOffStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_OnOffStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_OnOffStatus_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_OnOffStatus_Print(Icb_OnOffStatus value) {
    switch (value) {
        case e_Icb_OnOffStatus_off:
            ASN_PrintIndented("off" EOL);
            break;
        case e_Icb_OnOffStatus_on:
            ASN_PrintIndented("on" EOL);
            break;
        case e_Icb_OnOffStatus_unknown:
            ASN_PrintIndented("unknown" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_SecurityStatus_EnumMap[] = {
        e_Icb_SecurityStatus_idle,            /* Index = 0 */
        e_Icb_SecurityStatus_standby,         /* Index = 1 */
        e_Icb_SecurityStatus_active,          /* Index = 2 */
        e_Icb_SecurityStatus_activeStandalone /* Index = 3 */
};

ASN_Result Icb_SecurityStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_SecurityStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_SecurityStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_SecurityStatus_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_SecurityStatus_Print(Icb_SecurityStatus value) {
    switch (value) {
        case e_Icb_SecurityStatus_idle:
            ASN_PrintIndented("idle" EOL);
            break;
        case e_Icb_SecurityStatus_standby:
            ASN_PrintIndented("standby" EOL);
            break;
        case e_Icb_SecurityStatus_active:
            ASN_PrintIndented("active" EOL);
            break;
        case e_Icb_SecurityStatus_activeStandalone:
            ASN_PrintIndented("activeStandalone" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_GenericOkStatus_EnumMap[] = {
        e_Icb_GenericOkStatus_unknown, /* Index = 0 */
        e_Icb_GenericOkStatus_ok,      /* Index = 1 */
        e_Icb_GenericOkStatus_notOk    /* Index = 2 */
};

ASN_Result Icb_GenericOkStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_GenericOkStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_GenericOkStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_GenericOkStatus_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_GenericOkStatus_Print(Icb_GenericOkStatus value) {
    switch (value) {
        case e_Icb_GenericOkStatus_unknown:
            ASN_PrintIndented("unknown" EOL);
            break;
        case e_Icb_GenericOkStatus_ok:
            ASN_PrintIndented("ok" EOL);
            break;
        case e_Icb_GenericOkStatus_notOk:
            ASN_PrintIndented("notOk" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_AudioStatus of type ASNSequence
 */

Icb_AudioStatus Icb_AudioStatus_Create(ASN_Session session) {
    Icb_AudioStatus value = (Icb_AudioStatus)ASN_Malloc(session, sizeof(struct Icb_AudioStatus_t));
    if (value != (Icb_AudioStatus)NULL) {
        value->micStatus = 0;
        value->speakerStatus = 0;
    }
    return value;
}

U32 Icb_AudioStatus_EncodedSize(Icb_AudioStatus ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_GenericOkStatus_EncodedSize(ThisPtr->micStatus);
    length += Icb_GenericOkStatus_EncodedSize(ThisPtr->speakerStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_AudioStatus_SessionSize() {
    U32 length = sizeof(struct Icb_AudioStatus_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_AudioStatus_Print(Icb_AudioStatus ThisPtr) {
    ASN_PrintIndented("micStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_GenericOkStatus_Print(ThisPtr->micStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("speakerStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_GenericOkStatus_Print(ThisPtr->speakerStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_AudioStatus_Decode(Icb_AudioStatus ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_GenericOkStatus_Decode(&ThisPtr->micStatus, session, stream));
    ASN_DECODE_CHECK(Icb_GenericOkStatus_Decode(&ThisPtr->speakerStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_AudioStatus_Encode(Icb_AudioStatus ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_GenericOkStatus_Encode(ThisPtr->micStatus, stream));
    ASN_ENCODE_CHECK(Icb_GenericOkStatus_Encode(ThisPtr->speakerStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_AudioStatus of type ASNSequence
 */

/*
 * Start of Icb_UUID of type ASNSequence
 */

Icb_UUID Icb_UUID_Create(ASN_Session session) {
    Icb_UUID value = (Icb_UUID)ASN_Malloc(session, sizeof(struct Icb_UUID_t));
    if (value != (Icb_UUID)NULL) {
        value->uuid = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_UUID_EncodedSize(Icb_UUID ThisPtr) {
    U32 length = 0;
    length += ASN_UTF8String_EncodedSize(ThisPtr->uuid, 1, 36);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_UUID_SessionSize() {
    U32 length = sizeof(struct Icb_UUID_t);
    length += ASN_UTF8String_SessionSize(1, 36);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_UUID_Print(Icb_UUID ThisPtr) {
    ASN_PrintIndented("uuid" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->uuid);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_UUID_Decode(Icb_UUID ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->uuid, session, stream, 1, 36));
    return ASN_RESULT_OK;
}

ASN_Result Icb_UUID_Encode(Icb_UUID ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->uuid, stream, 1, 36));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_UUID of type ASNSequence
 */

/*
 * Start of Icb_PartIdentifier of type ASNSequence
 */

Icb_PartIdentifier Icb_PartIdentifier_Create(ASN_Session session) {
    Icb_PartIdentifier value = (Icb_PartIdentifier)ASN_Malloc(session, sizeof(struct Icb_PartIdentifier_t));
    if (value != (Icb_PartIdentifier)NULL) {
        value->partID = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_PartIdentifier_EncodedSize(Icb_PartIdentifier ThisPtr) {
    U32 length = 0;
    length += ASN_UTF8String_EncodedSize(ThisPtr->partID, 1, 40);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_PartIdentifier_SessionSize() {
    U32 length = sizeof(struct Icb_PartIdentifier_t);
    length += ASN_UTF8String_SessionSize(1, 40);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_PartIdentifier_Print(Icb_PartIdentifier ThisPtr) {
    ASN_PrintIndented("partID" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->partID);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_PartIdentifier_Decode(Icb_PartIdentifier ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->partID, session, stream, 1, 40));
    return ASN_RESULT_OK;
}

ASN_Result Icb_PartIdentifier_Encode(Icb_PartIdentifier ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->partID, stream, 1, 40));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_PartIdentifier of type ASNSequence
 */

static const U32 Icb_SBTrigger_EnumMap[] = {
        e_Icb_SBTrigger_diagnostic, /* Index = 0 */
        e_Icb_SBTrigger_predicted,  /* Index = 1 */
        e_Icb_SBTrigger_warning,    /* Index = 2 */
        e_Icb_SBTrigger_manual      /* Index = 3 */
};

ASN_Result Icb_SBTrigger_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_SBTrigger_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_SBTrigger_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_SBTrigger_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_SBTrigger_Print(Icb_SBTrigger value) {
    switch (value) {
        case e_Icb_SBTrigger_diagnostic:
            ASN_PrintIndented("diagnostic" EOL);
            break;
        case e_Icb_SBTrigger_predicted:
            ASN_PrintIndented("predicted" EOL);
            break;
        case e_Icb_SBTrigger_warning:
            ASN_PrintIndented("warning" EOL);
            break;
        case e_Icb_SBTrigger_manual:
            ASN_PrintIndented("manual" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_SBWarning of type ASNSequence
 */

Icb_SBWarning Icb_SBWarning_Create(ASN_Session session) {
    Icb_SBWarning value = (Icb_SBWarning)ASN_Malloc(session, sizeof(struct Icb_SBWarning_t));
    if (value != (Icb_SBWarning)NULL) {
        value->id = 0;
        value->message = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_SBWarning_EncodedSize(Icb_SBWarning ThisPtr) {
    U32 length = 0;
    length += U32_EncodedSize(ThisPtr->id, 0, 65535);
    length += ASN_UTF8String_EncodedSize(ThisPtr->message, 0, 100);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_SBWarning_SessionSize() {
    U32 length = sizeof(struct Icb_SBWarning_t);
    length += ASN_UTF8String_SessionSize(0, 100);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_SBWarning_Print(Icb_SBWarning ThisPtr) {
    ASN_PrintIndented("id" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->id);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("message" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->message);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_SBWarning_Decode(Icb_SBWarning ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->id, session, stream, 0, 65535));
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->message, session, stream, 0, 100));
    return ASN_RESULT_OK;
}

ASN_Result Icb_SBWarning_Encode(Icb_SBWarning ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->id, stream, 0, 65535));
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->message, stream, 0, 100));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_SBWarning of type ASNSequence
 */

/*
 * Start of Icb_OpSVTStatus_Response of type ASNSequence
 */

Icb_OpSVTStatus_Response Icb_OpSVTStatus_Response_Create(ASN_Session session) {
    Icb_OpSVTStatus_Response value =
            (Icb_OpSVTStatus_Response)ASN_Malloc(session, sizeof(struct Icb_OpSVTStatus_Response_t));
    if (value != (Icb_OpSVTStatus_Response)NULL) {
        value->svtStatus = 0;
    }
    return value;
}

U32 Icb_OpSVTStatus_Response_EncodedSize(Icb_OpSVTStatus_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SecurityStatus_EncodedSize(ThisPtr->svtStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSVTStatus_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpSVTStatus_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSVTStatus_Response_Print(Icb_OpSVTStatus_Response ThisPtr) {
    ASN_PrintIndented("svtStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_SecurityStatus_Print(ThisPtr->svtStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSVTStatus_Response_Decode(Icb_OpSVTStatus_Response ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SecurityStatus_Decode(&ThisPtr->svtStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSVTStatus_Response_Encode(Icb_OpSVTStatus_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SecurityStatus_Encode(ThisPtr->svtStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSVTStatus_Response of type ASNSequence
 */

/*
 * Start of Icb_OpSVTStatus_Notification of type ASNSequence
 */

Icb_OpSVTStatus_Notification Icb_OpSVTStatus_Notification_Create(ASN_Session session) {
    Icb_OpSVTStatus_Notification value =
            (Icb_OpSVTStatus_Notification)ASN_Malloc(session, sizeof(struct Icb_OpSVTStatus_Notification_t));
    if (value != (Icb_OpSVTStatus_Notification)NULL) {
        value->svtStatus = 0;
    }
    return value;
}

U32 Icb_OpSVTStatus_Notification_EncodedSize(Icb_OpSVTStatus_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SecurityStatus_EncodedSize(ThisPtr->svtStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSVTStatus_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpSVTStatus_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSVTStatus_Notification_Print(Icb_OpSVTStatus_Notification ThisPtr) {
    ASN_PrintIndented("svtStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_SecurityStatus_Print(ThisPtr->svtStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSVTStatus_Notification_Decode(Icb_OpSVTStatus_Notification ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SecurityStatus_Decode(&ThisPtr->svtStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSVTStatus_Notification_Encode(Icb_OpSVTStatus_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SecurityStatus_Encode(ThisPtr->svtStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSVTStatus_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpTNStatus_Response of type ASNSequence
 */

Icb_OpTNStatus_Response Icb_OpTNStatus_Response_Create(ASN_Session session) {
    Icb_OpTNStatus_Response value =
            (Icb_OpTNStatus_Response)ASN_Malloc(session, sizeof(struct Icb_OpTNStatus_Response_t));
    if (value != (Icb_OpTNStatus_Response)NULL) {
        value->tnStatus = 0;
    }
    return value;
}

U32 Icb_OpTNStatus_Response_EncodedSize(Icb_OpTNStatus_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SecurityStatus_EncodedSize(ThisPtr->tnStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTNStatus_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpTNStatus_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTNStatus_Response_Print(Icb_OpTNStatus_Response ThisPtr) {
    ASN_PrintIndented("tnStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_SecurityStatus_Print(ThisPtr->tnStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTNStatus_Response_Decode(Icb_OpTNStatus_Response ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SecurityStatus_Decode(&ThisPtr->tnStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTNStatus_Response_Encode(Icb_OpTNStatus_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SecurityStatus_Encode(ThisPtr->tnStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTNStatus_Response of type ASNSequence
 */

/*
 * Start of Icb_OpTNStatus_Notification of type ASNSequence
 */

Icb_OpTNStatus_Notification Icb_OpTNStatus_Notification_Create(ASN_Session session) {
    Icb_OpTNStatus_Notification value =
            (Icb_OpTNStatus_Notification)ASN_Malloc(session, sizeof(struct Icb_OpTNStatus_Notification_t));
    if (value != (Icb_OpTNStatus_Notification)NULL) {
        value->tnStatus = 0;
    }
    return value;
}

U32 Icb_OpTNStatus_Notification_EncodedSize(Icb_OpTNStatus_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SecurityStatus_EncodedSize(ThisPtr->tnStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTNStatus_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpTNStatus_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTNStatus_Notification_Print(Icb_OpTNStatus_Notification ThisPtr) {
    ASN_PrintIndented("tnStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_SecurityStatus_Print(ThisPtr->tnStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTNStatus_Notification_Decode(Icb_OpTNStatus_Notification ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SecurityStatus_Decode(&ThisPtr->tnStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTNStatus_Notification_Encode(Icb_OpTNStatus_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SecurityStatus_Encode(ThisPtr->tnStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTNStatus_Notification of type ASNSequence
 */

/*
 * Start of Icb_TelemSettings of type ASNSequence
 */

Icb_TelemSettings Icb_TelemSettings_Create(ASN_Session session) {
    Icb_TelemSettings value = (Icb_TelemSettings)ASN_Malloc(session, sizeof(struct Icb_TelemSettings_t));
    if (value != (Icb_TelemSettings)NULL) {
        value->keylockEnabled = 0;
    }
    return value;
}

U32 Icb_TelemSettings_EncodedSize(Icb_TelemSettings ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->keylockEnabled);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_TelemSettings_SessionSize() {
    U32 length = sizeof(struct Icb_TelemSettings_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_TelemSettings_Print(Icb_TelemSettings ThisPtr) {
    ASN_PrintIndented("keylockEnabled" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->keylockEnabled);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_TelemSettings_Decode(Icb_TelemSettings ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->keylockEnabled, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_TelemSettings_Encode(Icb_TelemSettings ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->keylockEnabled, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_TelemSettings of type ASNSequence
 */

/*
 * Start of Icb_SimpleVehiclePosition of type ASNChoice
 */

Icb_SimpleVehiclePosition Icb_SimpleVehiclePosition_Create(ASN_Session session) {
    Icb_SimpleVehiclePosition value =
            (Icb_SimpleVehiclePosition)ASN_Malloc(session, sizeof(struct Icb_SimpleVehiclePosition_t));
    value->wgs84 = (Icb_WGS84SimplePositionData)NULL;
    return value;
}

U32 Icb_SimpleVehiclePosition_EncodedSize(Icb_SimpleVehiclePosition ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 1);
    switch (ThisPtr->choice) {
        case e_Icb_SimpleVehiclePosition_noValidData:
            length += ASN_Null_EncodedSize(ThisPtr->noValidData);
            break;
        case e_Icb_SimpleVehiclePosition_wgs84:
            length += Icb_WGS84SimplePositionData_EncodedSize(ThisPtr->wgs84);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_SimpleVehiclePosition_SessionSize() {
    U32 max = 0;
    U32 length;
    length = Icb_WGS84SimplePositionData_SessionSize();
    if (length > max) max = length;

    return max + sizeof(struct Icb_SimpleVehiclePosition_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_SimpleVehiclePosition_Decode(Icb_SimpleVehiclePosition ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 1));
    ASN_SETTYPE_CHECK(Icb_SimpleVehiclePosition_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_SimpleVehiclePosition_noValidData:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->noValidData, session, stream));
            break;

        case e_Icb_SimpleVehiclePosition_wgs84:
            ASN_DECODE_CHECK(Icb_WGS84SimplePositionData_Decode(ThisPtr->wgs84, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_SimpleVehiclePosition_Encode(Icb_SimpleVehiclePosition ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 1));
    switch (ThisPtr->choice) {
        case e_Icb_SimpleVehiclePosition_noValidData:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->noValidData, stream));
            break;

        case e_Icb_SimpleVehiclePosition_wgs84:
            ASN_ENCODE_CHECK(Icb_WGS84SimplePositionData_Encode(ThisPtr->wgs84, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_SimpleVehiclePosition_SetType(Icb_SimpleVehiclePosition ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_SimpleVehiclePosition_noValidData) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_SimpleVehiclePosition_wgs84) {
        ThisPtr->choice = type;
        ThisPtr->wgs84 = Icb_WGS84SimplePositionData_Create(session);
        ASN_MEM_CHECK(ThisPtr->wgs84);
    } else
        ThisPtr->wgs84 = (Icb_WGS84SimplePositionData)NULL;

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_SimpleVehiclePosition_Print(Icb_SimpleVehiclePosition ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_SimpleVehiclePosition_noValidData:
            ASN_PrintIndented("Icb_SimpleVehiclePosition is noValidData" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->noValidData);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_SimpleVehiclePosition_wgs84:
            ASN_PrintIndented("Icb_SimpleVehiclePosition is wgs84" EOL);
            ASN_PrintSetIndent(1);
            Icb_WGS84SimplePositionData_Print(ThisPtr->wgs84);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_SimpleVehiclePosition of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

static const U32 Icb_ActivationStatusChange_EnumMap[] = {
        e_Icb_ActivationStatusChange_activate,    /* Index = 0 */
        e_Icb_ActivationStatusChange_preactivate, /* Index = 1 */
        e_Icb_ActivationStatusChange_provision    /* Index = 2 */
};

ASN_Result Icb_ActivationStatusChange_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_ActivationStatusChange_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_ActivationStatusChange_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_ActivationStatusChange_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_ActivationStatusChange_Print(Icb_ActivationStatusChange value) {
    switch (value) {
        case e_Icb_ActivationStatusChange_activate:
            ASN_PrintIndented("activate" EOL);
            break;
        case e_Icb_ActivationStatusChange_preactivate:
            ASN_PrintIndented("preactivate" EOL);
            break;
        case e_Icb_ActivationStatusChange_provision:
            ASN_PrintIndented("provision" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_ActivationStatus_EnumMap[] = {
        e_Icb_ActivationStatus_deactivated,                 /* Index = 0 */
        e_Icb_ActivationStatus_activated_provisioned,       /* Index = 1 */
        e_Icb_ActivationStatus_pre_activated_unprovisioned, /* Index = 2 */
        e_Icb_ActivationStatus_activated_unprovisioned,     /* Index = 3 */
        e_Icb_ActivationStatus_remote_provisioning_ongoing, /* Index = 4 */
        e_Icb_ActivationStatus_provisioning_ongoing         /* Index = 5 */
};

ASN_Result Icb_ActivationStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 5, FALSE));

    if (*val >= 6) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_ActivationStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_ActivationStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_ActivationStatus_EnumMap, 6);

    if (index == 6) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 5, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_ActivationStatus_Print(Icb_ActivationStatus value) {
    switch (value) {
        case e_Icb_ActivationStatus_deactivated:
            ASN_PrintIndented("deactivated" EOL);
            break;
        case e_Icb_ActivationStatus_activated_provisioned:
            ASN_PrintIndented("activated_provisioned" EOL);
            break;
        case e_Icb_ActivationStatus_pre_activated_unprovisioned:
            ASN_PrintIndented("pre_activated_unprovisioned" EOL);
            break;
        case e_Icb_ActivationStatus_activated_unprovisioned:
            ASN_PrintIndented("activated_unprovisioned" EOL);
            break;
        case e_Icb_ActivationStatus_remote_provisioning_ongoing:
            ASN_PrintIndented("remote_provisioning_ongoing" EOL);
            break;
        case e_Icb_ActivationStatus_provisioning_ongoing:
            ASN_PrintIndented("provisioning_ongoing" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_OnCallService_EnumMap[] = {
        e_Icb_OnCallService_emergencyAssist, /* Index = 0 */
        e_Icb_OnCallService_roadsideAssist   /* Index = 1 */
};

ASN_Result Icb_OnCallService_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_OnCallService_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_OnCallService_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_OnCallService_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_OnCallService_Print(Icb_OnCallService value) {
    switch (value) {
        case e_Icb_OnCallService_emergencyAssist:
            ASN_PrintIndented("emergencyAssist" EOL);
            break;
        case e_Icb_OnCallService_roadsideAssist:
            ASN_PrintIndented("roadsideAssist" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_OnOffSetting_EnumMap[] = {
        e_Icb_OnOffSetting_off, /* Index = 0 */
        e_Icb_OnOffSetting_on   /* Index = 1 */
};

ASN_Result Icb_OnOffSetting_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_OnOffSetting_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_OnOffSetting_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_OnOffSetting_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_OnOffSetting_Print(Icb_OnOffSetting value) {
    switch (value) {
        case e_Icb_OnOffSetting_off:
            ASN_PrintIndented("off" EOL);
            break;
        case e_Icb_OnOffSetting_on:
            ASN_PrintIndented("on" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpServiceActivation_Response of type ASNSequence
 */

Icb_OpServiceActivation_Response Icb_OpServiceActivation_Response_Create(ASN_Session session) {
    Icb_OpServiceActivation_Response value =
            (Icb_OpServiceActivation_Response)ASN_Malloc(session, sizeof(struct Icb_OpServiceActivation_Response_t));
    if (value != (Icb_OpServiceActivation_Response)NULL) {
        value->responseOk = 0;
    }
    return value;
}

U32 Icb_OpServiceActivation_Response_EncodedSize(Icb_OpServiceActivation_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_Null_EncodedSize(ThisPtr->responseOk);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpServiceActivation_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpServiceActivation_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpServiceActivation_Response_Print(Icb_OpServiceActivation_Response ThisPtr) {
    ASN_PrintIndented("responseOk" EOL);
    ASN_PrintSetIndent(1);
    ASN_Null_Print(ThisPtr->responseOk);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpServiceActivation_Response_Decode(Icb_OpServiceActivation_Response ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->responseOk, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpServiceActivation_Response_Encode(Icb_OpServiceActivation_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->responseOk, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpServiceActivation_Response of type ASNSequence
 */

static const U32 Icb_RescueStatus_EnumMap[] = {
        e_Icb_RescueStatus_disabled,            /* Index = 0 */
        e_Icb_RescueStatus_notActive,           /* Index = 1 */
        e_Icb_RescueStatus_serviceNotAvailable, /* Index = 2 */
        e_Icb_RescueStatus_active,              /* Index = 3 */
        e_Icb_RescueStatus_terminated           /* Index = 4 */
};

ASN_Result Icb_RescueStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 4, FALSE));

    if (*val >= 5) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_RescueStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_RescueStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_RescueStatus_EnumMap, 5);

    if (index == 5) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 4, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_RescueStatus_Print(Icb_RescueStatus value) {
    switch (value) {
        case e_Icb_RescueStatus_disabled:
            ASN_PrintIndented("disabled" EOL);
            break;
        case e_Icb_RescueStatus_notActive:
            ASN_PrintIndented("notActive" EOL);
            break;
        case e_Icb_RescueStatus_serviceNotAvailable:
            ASN_PrintIndented("serviceNotAvailable" EOL);
            break;
        case e_Icb_RescueStatus_active:
            ASN_PrintIndented("active" EOL);
            break;
        case e_Icb_RescueStatus_terminated:
            ASN_PrintIndented("terminated" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_ButtonStatus_EnumMap[] = {
        e_Icb_ButtonStatus_disabled,       /* Index = 0 */
        e_Icb_ButtonStatus_onCallPressed,  /* Index = 1 */
        e_Icb_ButtonStatus_onCallReleased, /* Index = 2 */
        e_Icb_ButtonStatus_sosPressed,     /* Index = 3 */
        e_Icb_ButtonStatus_sosReleased,    /* Index = 4 */
        e_Icb_ButtonStatus_allReleased     /* Index = 5 */
};

ASN_Result Icb_ButtonStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 5, FALSE));

    if (*val >= 6) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_ButtonStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_ButtonStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_ButtonStatus_EnumMap, 6);

    if (index == 6) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 5, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_ButtonStatus_Print(Icb_ButtonStatus value) {
    switch (value) {
        case e_Icb_ButtonStatus_disabled:
            ASN_PrintIndented("disabled" EOL);
            break;
        case e_Icb_ButtonStatus_onCallPressed:
            ASN_PrintIndented("onCallPressed" EOL);
            break;
        case e_Icb_ButtonStatus_onCallReleased:
            ASN_PrintIndented("onCallReleased" EOL);
            break;
        case e_Icb_ButtonStatus_sosPressed:
            ASN_PrintIndented("sosPressed" EOL);
            break;
        case e_Icb_ButtonStatus_sosReleased:
            ASN_PrintIndented("sosReleased" EOL);
            break;
        case e_Icb_ButtonStatus_allReleased:
            ASN_PrintIndented("allReleased" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_VoiceStatus_EnumMap[] = {
        e_Icb_VoiceStatus_noConnection,     /* Index = 0 */
        e_Icb_VoiceStatus_connectingCSC,    /* Index = 1 */
        e_Icb_VoiceStatus_connectingPSAP,   /* Index = 2 */
        e_Icb_VoiceStatus_connectedCSC,     /* Index = 3 */
        e_Icb_VoiceStatus_connectedPSAP,    /* Index = 4 */
        e_Icb_VoiceStatus_incomingCall,     /* Index = 5 */
        e_Icb_VoiceStatus_connectedCall,    /* Index = 6 */
        e_Icb_VoiceStatus_connectedIncoming /* Index = 7 */
};

ASN_Result Icb_VoiceStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 7, FALSE));

    if (*val >= 8) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_VoiceStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_VoiceStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_VoiceStatus_EnumMap, 8);

    if (index == 8) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 7, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_VoiceStatus_Print(Icb_VoiceStatus value) {
    switch (value) {
        case e_Icb_VoiceStatus_noConnection:
            ASN_PrintIndented("noConnection" EOL);
            break;
        case e_Icb_VoiceStatus_connectingCSC:
            ASN_PrintIndented("connectingCSC" EOL);
            break;
        case e_Icb_VoiceStatus_connectingPSAP:
            ASN_PrintIndented("connectingPSAP" EOL);
            break;
        case e_Icb_VoiceStatus_connectedCSC:
            ASN_PrintIndented("connectedCSC" EOL);
            break;
        case e_Icb_VoiceStatus_connectedPSAP:
            ASN_PrintIndented("connectedPSAP" EOL);
            break;
        case e_Icb_VoiceStatus_incomingCall:
            ASN_PrintIndented("incomingCall" EOL);
            break;
        case e_Icb_VoiceStatus_connectedCall:
            ASN_PrintIndented("connectedCall" EOL);
            break;
        case e_Icb_VoiceStatus_connectedIncoming:
            ASN_PrintIndented("connectedIncoming" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_MessageStatus_EnumMap[] = {
        e_Icb_MessageStatus_notSent,      /* Index = 0 */
        e_Icb_MessageStatus_sending,      /* Index = 1 */
        e_Icb_MessageStatus_sent,         /* Index = 2 */
        e_Icb_MessageStatus_ackUndefined, /* Index = 3 */
        e_Icb_MessageStatus_ackDefined    /* Index = 4 */
};

ASN_Result Icb_MessageStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 4, FALSE));

    if (*val >= 5) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_MessageStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_MessageStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_MessageStatus_EnumMap, 5);

    if (index == 5) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 4, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_MessageStatus_Print(Icb_MessageStatus value) {
    switch (value) {
        case e_Icb_MessageStatus_notSent:
            ASN_PrintIndented("notSent" EOL);
            break;
        case e_Icb_MessageStatus_sending:
            ASN_PrintIndented("sending" EOL);
            break;
        case e_Icb_MessageStatus_sent:
            ASN_PrintIndented("sent" EOL);
            break;
        case e_Icb_MessageStatus_ackUndefined:
            ASN_PrintIndented("ackUndefined" EOL);
            break;
        case e_Icb_MessageStatus_ackDefined:
            ASN_PrintIndented("ackDefined" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_PSAPStatus_EnumMap[] = {
        e_Icb_PSAPStatus_confirmRequired,   /* Index = 0 */
        e_Icb_PSAPStatus_confirmNotRequired /* Index = 1 */
};

ASN_Result Icb_PSAPStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_PSAPStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_PSAPStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_PSAPStatus_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_PSAPStatus_Print(Icb_PSAPStatus value) {
    switch (value) {
        case e_Icb_PSAPStatus_confirmRequired:
            ASN_PrintIndented("confirmRequired" EOL);
            break;
        case e_Icb_PSAPStatus_confirmNotRequired:
            ASN_PrintIndented("confirmNotRequired" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_SendToCarConfirmation_EnumMap[] = {
        e_Icb_SendToCarConfirmation_addedAsDestination,         /* Index = 0 */
        e_Icb_SendToCarConfirmation_addedAsWaypoint,            /* Index = 1 */
        e_Icb_SendToCarConfirmation_rejected,                   /* Index = 2 */
        e_Icb_SendToCarConfirmation_desinationOutsideOfMapData, /* Index = 3 */
        e_Icb_SendToCarConfirmation_errorWhenAdding             /* Index = 4 */
};

ASN_Result Icb_SendToCarConfirmation_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 4, FALSE));

    if (*val >= 5) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_SendToCarConfirmation_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_SendToCarConfirmation_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_SendToCarConfirmation_EnumMap, 5);

    if (index == 5) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 4, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_SendToCarConfirmation_Print(Icb_SendToCarConfirmation value) {
    switch (value) {
        case e_Icb_SendToCarConfirmation_addedAsDestination:
            ASN_PrintIndented("addedAsDestination" EOL);
            break;
        case e_Icb_SendToCarConfirmation_addedAsWaypoint:
            ASN_PrintIndented("addedAsWaypoint" EOL);
            break;
        case e_Icb_SendToCarConfirmation_rejected:
            ASN_PrintIndented("rejected" EOL);
            break;
        case e_Icb_SendToCarConfirmation_desinationOutsideOfMapData:
            ASN_PrintIndented("desinationOutsideOfMapData" EOL);
            break;
        case e_Icb_SendToCarConfirmation_errorWhenAdding:
            ASN_PrintIndented("errorWhenAdding" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_PreferredEcalls_EnumMap[] = {
        e_Icb_PreferredEcalls_publicSOS,  /* Index = 0 */
        e_Icb_PreferredEcalls_volvoOnCall /* Index = 1 */
};

ASN_Result Icb_PreferredEcalls_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_PreferredEcalls_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_PreferredEcalls_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_PreferredEcalls_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_PreferredEcalls_Print(Icb_PreferredEcalls value) {
    switch (value) {
        case e_Icb_PreferredEcalls_publicSOS:
            ASN_PrintIndented("publicSOS" EOL);
            break;
        case e_Icb_PreferredEcalls_volvoOnCall:
            ASN_PrintIndented("volvoOnCall" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpTextMessage_SetRequest of type ASNSequence
 */

Icb_OpTextMessage_SetRequest Icb_OpTextMessage_SetRequest_Create(ASN_Session session) {
    Icb_OpTextMessage_SetRequest value =
            (Icb_OpTextMessage_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpTextMessage_SetRequest_t));
    if (value != (Icb_OpTextMessage_SetRequest)NULL) {
        value->exists__optional__source = 0;
        value->sourceStatus = 0;
        value->source = ASN_UTF8String_Create(session);
        value->text = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_OpTextMessage_SetRequest_EncodedSize(Icb_OpTextMessage_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__source);
    length += Icb_SourceStatus_EncodedSize(ThisPtr->sourceStatus);
    if (ThisPtr->exists__optional__source == TRUE) {
        length += ASN_UTF8String_EncodedSize(ThisPtr->source, 1, 30);
    }
    length += ASN_UTF8String_EncodedSize(ThisPtr->text, 1, 140);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTextMessage_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpTextMessage_SetRequest_t);
    length += ASN_UTF8String_SessionSize(1, 30);
    length += ASN_UTF8String_SessionSize(1, 140);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTextMessage_SetRequest_Print(Icb_OpTextMessage_SetRequest ThisPtr) {
    ASN_PrintIndented("exists__optional__source" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__source);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sourceStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_SourceStatus_Print(ThisPtr->sourceStatus);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__source == TRUE) {
        ASN_PrintIndented("source" EOL);
        ASN_PrintSetIndent(1);
        ASN_UTF8String_Print(ThisPtr->source);
        ASN_PrintSetIndent(-1);
    }
    ASN_PrintIndented("text" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->text);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTextMessage_SetRequest_Decode(Icb_OpTextMessage_SetRequest ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__source, session, stream));
    ASN_DECODE_CHECK(Icb_SourceStatus_Decode(&ThisPtr->sourceStatus, session, stream));
    if (ThisPtr->exists__optional__source == TRUE) {
        ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->source, session, stream, 1, 30));
    }
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->text, session, stream, 1, 140));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTextMessage_SetRequest_Encode(Icb_OpTextMessage_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__source, stream));
    ASN_ENCODE_CHECK(Icb_SourceStatus_Encode(ThisPtr->sourceStatus, stream));
    if (ThisPtr->exists__optional__source == TRUE) {
        ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->source, stream, 1, 30));
    }
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->text, stream, 1, 140));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTextMessage_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpIHUSystemInfo_Response of type ASNSequence
 */

Icb_OpIHUSystemInfo_Response Icb_OpIHUSystemInfo_Response_Create(ASN_Session session) {
    Icb_OpIHUSystemInfo_Response value =
            (Icb_OpIHUSystemInfo_Response)ASN_Malloc(session, sizeof(struct Icb_OpIHUSystemInfo_Response_t));
    if (value != (Icb_OpIHUSystemInfo_Response)NULL) {
        value->softwareVersion = ASN_OctetString_Create(session);
        value->mapBaseVersion = ASN_OctetString_Create(session);
        value->mapIncrement = 0;
        value->typeOfPackage = 0;
        value->failedFetchBooking = 0;
        value->failedServiceIP = 0;
    }
    return value;
}

U32 Icb_OpIHUSystemInfo_Response_EncodedSize(Icb_OpIHUSystemInfo_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_OctetString_EncodedSize(ThisPtr->softwareVersion, 0, 20);
    length += ASN_OctetString_EncodedSize(ThisPtr->mapBaseVersion, 0, 20);
    length += U32_EncodedSize(ThisPtr->mapIncrement, 0, 255);
    length += U32_EncodedSize(ThisPtr->typeOfPackage, 0, 255);
    length += U32_EncodedSize(ThisPtr->failedFetchBooking, 0, 65535);
    length += U32_EncodedSize(ThisPtr->failedServiceIP, 0, 65535);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpIHUSystemInfo_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpIHUSystemInfo_Response_t);
    length += ASN_OctetString_SessionSize(0, 20);
    length += ASN_OctetString_SessionSize(0, 20);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpIHUSystemInfo_Response_Print(Icb_OpIHUSystemInfo_Response ThisPtr) {
    ASN_PrintIndented("softwareVersion" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->softwareVersion);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("mapBaseVersion" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->mapBaseVersion);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("mapIncrement" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->mapIncrement);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("typeOfPackage" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->typeOfPackage);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("failedFetchBooking" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->failedFetchBooking);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("failedServiceIP" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->failedServiceIP);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpIHUSystemInfo_Response_Decode(Icb_OpIHUSystemInfo_Response ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->softwareVersion, session, stream, 0, 20));
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->mapBaseVersion, session, stream, 0, 20));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->mapIncrement, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->typeOfPackage, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->failedFetchBooking, session, stream, 0, 65535));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->failedServiceIP, session, stream, 0, 65535));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpIHUSystemInfo_Response_Encode(Icb_OpIHUSystemInfo_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->softwareVersion, stream, 0, 20));
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->mapBaseVersion, stream, 0, 20));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->mapIncrement, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->typeOfPackage, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->failedFetchBooking, stream, 0, 65535));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->failedServiceIP, stream, 0, 65535));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpIHUSystemInfo_Response of type ASNSequence
 */

/*
 * Start of Icb_UserPrivacySettings of type ASNSequence
 */

Icb_UserPrivacySettings Icb_UserPrivacySettings_Create(ASN_Session session) {
    Icb_UserPrivacySettings value =
            (Icb_UserPrivacySettings)ASN_Malloc(session, sizeof(struct Icb_UserPrivacySettings_t));
    if (value != (Icb_UserPrivacySettings)NULL) {
        value->carStatUploadEn = 0;
        value->locationServicesEn = 0;
    }
    return value;
}

U32 Icb_UserPrivacySettings_EncodedSize(Icb_UserPrivacySettings ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->carStatUploadEn);
    length += BOOL_EncodedSize(ThisPtr->locationServicesEn);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_UserPrivacySettings_SessionSize() {
    U32 length = sizeof(struct Icb_UserPrivacySettings_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_UserPrivacySettings_Print(Icb_UserPrivacySettings ThisPtr) {
    ASN_PrintIndented("carStatUploadEn" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->carStatUploadEn);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("locationServicesEn" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->locationServicesEn);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_UserPrivacySettings_Decode(Icb_UserPrivacySettings ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->carStatUploadEn, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->locationServicesEn, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_UserPrivacySettings_Encode(Icb_UserPrivacySettings ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->carStatUploadEn, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->locationServicesEn, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_UserPrivacySettings of type ASNSequence
 */

/*
 * Start of Icb_ClimateTimerError of type ASNChoice
 */

Icb_ClimateTimerError Icb_ClimateTimerError_Create(ASN_Session session) {
    Icb_ClimateTimerError value = (Icb_ClimateTimerError)ASN_Malloc(session, sizeof(struct Icb_ClimateTimerError_t));
    return value;
}

U32 Icb_ClimateTimerError_EncodedSize(Icb_ClimateTimerError ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 2);
    switch (ThisPtr->choice) {
        case e_Icb_ClimateTimerError_noError:
            length += ASN_Null_EncodedSize(ThisPtr->noError);
            break;
        case e_Icb_ClimateTimerError_setTimersError:
            length += Icb_TimerError_EncodedSize(ThisPtr->setTimersError);
            break;
        case e_Icb_ClimateTimerError_getTimerError:
            length += Icb_TimerError_EncodedSize(ThisPtr->getTimerError);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ClimateTimerError_SessionSize() {
    U32 max = 0;
    return max + sizeof(struct Icb_ClimateTimerError_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ClimateTimerError_Decode(Icb_ClimateTimerError ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 2));
    ASN_SETTYPE_CHECK(Icb_ClimateTimerError_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_ClimateTimerError_noError:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->noError, session, stream));
            break;

        case e_Icb_ClimateTimerError_setTimersError:
            ASN_DECODE_CHECK(Icb_TimerError_Decode(&ThisPtr->setTimersError, session, stream));
            break;

        case e_Icb_ClimateTimerError_getTimerError:
            ASN_DECODE_CHECK(Icb_TimerError_Decode(&ThisPtr->getTimerError, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ClimateTimerError_Encode(Icb_ClimateTimerError ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 2));
    switch (ThisPtr->choice) {
        case e_Icb_ClimateTimerError_noError:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->noError, stream));
            break;

        case e_Icb_ClimateTimerError_setTimersError:
            ASN_ENCODE_CHECK(Icb_TimerError_Encode(ThisPtr->setTimersError, stream));
            break;

        case e_Icb_ClimateTimerError_getTimerError:
            ASN_ENCODE_CHECK(Icb_TimerError_Encode(ThisPtr->getTimerError, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ClimateTimerError_SetType(Icb_ClimateTimerError ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_ClimateTimerError_noError) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_ClimateTimerError_setTimersError) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_ClimateTimerError_getTimerError) {
        ThisPtr->choice = type;
    }

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_ClimateTimerError_Print(Icb_ClimateTimerError ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_ClimateTimerError_noError:
            ASN_PrintIndented("Icb_ClimateTimerError is noError" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->noError);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_ClimateTimerError_setTimersError:
            ASN_PrintIndented("Icb_ClimateTimerError is setTimersError" EOL);
            ASN_PrintSetIndent(1);
            Icb_TimerError_Print(ThisPtr->setTimersError);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_ClimateTimerError_getTimerError:
            ASN_PrintIndented("Icb_ClimateTimerError is getTimerError" EOL);
            ASN_PrintSetIndent(1);
            Icb_TimerError_Print(ThisPtr->getTimerError);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_ClimateTimerError of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

static const U32 Icb_TimerError_EnumMap[] = {
        e_Icb_TimerError_newerTimers,    /* Index = 0 */
        e_Icb_TimerError_carInUseHMI,    /* Index = 1 */
        e_Icb_TimerError_generalErrorHMI /* Index = 2 */
};

ASN_Result Icb_TimerError_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_TimerError_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_TimerError_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_TimerError_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_TimerError_Print(Icb_TimerError value) {
    switch (value) {
        case e_Icb_TimerError_newerTimers:
            ASN_PrintIndented("newerTimers" EOL);
            break;
        case e_Icb_TimerError_carInUseHMI:
            ASN_PrintIndented("carInUseHMI" EOL);
            break;
        case e_Icb_TimerError_generalErrorHMI:
            ASN_PrintIndented("generalErrorHMI" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_TimerStatus_EnumMap[] = {
        e_Icb_TimerStatus_notUsed, /* Index = 0 */
        e_Icb_TimerStatus_off,     /* Index = 1 */
        e_Icb_TimerStatus_on,      /* Index = 2 */
        e_Icb_TimerStatus_reserved /* Index = 3 */
};

ASN_Result Icb_TimerStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_TimerStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_TimerStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_TimerStatus_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_TimerStatus_Print(Icb_TimerStatus value) {
    switch (value) {
        case e_Icb_TimerStatus_notUsed:
            ASN_PrintIndented("notUsed" EOL);
            break;
        case e_Icb_TimerStatus_off:
            ASN_PrintIndented("off" EOL);
            break;
        case e_Icb_TimerStatus_on:
            ASN_PrintIndented("on" EOL);
            break;
        case e_Icb_TimerStatus_reserved:
            ASN_PrintIndented("reserved" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_TimerType_EnumMap[] = {
        e_Icb_TimerType_reserved, /* Index = 0 */
        e_Icb_TimerType_single,   /* Index = 1 */
        e_Icb_TimerType_day,      /* Index = 2 */
        e_Icb_TimerType_repeated  /* Index = 3 */
};

ASN_Result Icb_TimerType_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_TimerType_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_TimerType_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_TimerType_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_TimerType_Print(Icb_TimerType value) {
    switch (value) {
        case e_Icb_TimerType_reserved:
            ASN_PrintIndented("reserved" EOL);
            break;
        case e_Icb_TimerType_single:
            ASN_PrintIndented("single" EOL);
            break;
        case e_Icb_TimerType_day:
            ASN_PrintIndented("day" EOL);
            break;
        case e_Icb_TimerType_repeated:
            ASN_PrintIndented("repeated" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_OnOff_EnumMap[] = {
        e_Icb_OnOff_off, /* Index = 0 */
        e_Icb_OnOff_on   /* Index = 1 */
};

ASN_Result Icb_OnOff_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_OnOff_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_OnOff_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_OnOff_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_OnOff_Print(Icb_OnOff value) {
    switch (value) {
        case e_Icb_OnOff_off:
            ASN_PrintIndented("off" EOL);
            break;
        case e_Icb_OnOff_on:
            ASN_PrintIndented("on" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpSoHWarning_Notification of type ASNSequence
 */

Icb_OpSoHWarning_Notification Icb_OpSoHWarning_Notification_Create(ASN_Session session) {
    Icb_OpSoHWarning_Notification value =
            (Icb_OpSoHWarning_Notification)ASN_Malloc(session, sizeof(struct Icb_OpSoHWarning_Notification_t));
    if (value != (Icb_OpSoHWarning_Notification)NULL) {
        value->sbWarning = Icb_SBWarning_Create(session);
    }
    return value;
}

U32 Icb_OpSoHWarning_Notification_EncodedSize(Icb_OpSoHWarning_Notification ThisPtr) {
    U32 length = 0;
    length += Icb_SBWarning_EncodedSize(ThisPtr->sbWarning);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSoHWarning_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpSoHWarning_Notification_t);
    length += Icb_SBWarning_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSoHWarning_Notification_Print(Icb_OpSoHWarning_Notification ThisPtr) {
    ASN_PrintIndented("sbWarning" EOL);
    ASN_PrintSetIndent(1);
    Icb_SBWarning_Print(ThisPtr->sbWarning);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSoHWarning_Notification_Decode(Icb_OpSoHWarning_Notification ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_SBWarning_Decode(ThisPtr->sbWarning, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSoHWarning_Notification_Encode(Icb_OpSoHWarning_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_SBWarning_Encode(ThisPtr->sbWarning, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSoHWarning_Notification of type ASNSequence
 */

static const U32 Icb_SettingType_EnumMap[] = {
        e_Icb_SettingType_setting, /* Index = 0 */
        e_Icb_SettingType_error    /* Index = 1 */
};

ASN_Result Icb_SettingType_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_SettingType_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_SettingType_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_SettingType_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_SettingType_Print(Icb_SettingType value) {
    switch (value) {
        case e_Icb_SettingType_setting:
            ASN_PrintIndented("setting" EOL);
            break;
        case e_Icb_SettingType_error:
            ASN_PrintIndented("error" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpServiceBooking_Notification of type ASNSequence
 */

Icb_OpServiceBooking_Notification Icb_OpServiceBooking_Notification_Create(ASN_Session session) {
    Icb_OpServiceBooking_Notification value =
            (Icb_OpServiceBooking_Notification)ASN_Malloc(session, sizeof(struct Icb_OpServiceBooking_Notification_t));
    if (value != (Icb_OpServiceBooking_Notification)NULL) {
        value->exists__optional__sbText = 0;
        value->exists__optional__sbWarning = 0;
        value->exists__optional__dtcWarning = 0;
        value->sbTrigger = 0;
        value->sbText = ASN_UTF8String_Create(session);
        value->sbWarning = Icb_SBWarning_Create(session);
        value->dtcWarning = Icb_SBWarning_Create(session);
    }
    return value;
}

U32 Icb_OpServiceBooking_Notification_EncodedSize(Icb_OpServiceBooking_Notification ThisPtr) {
    U32 length = 0;
    length += BOOL_EncodedSize(ThisPtr->exists__optional__sbText);
    length += BOOL_EncodedSize(ThisPtr->exists__optional__sbWarning);
    length += BOOL_EncodedSize(ThisPtr->exists__optional__dtcWarning);
    length += Icb_SBTrigger_EncodedSize(ThisPtr->sbTrigger);
    if (ThisPtr->exists__optional__sbText == TRUE) {
        length += ASN_UTF8String_EncodedSize(ThisPtr->sbText, 0, 5);
    }
    if (ThisPtr->exists__optional__sbWarning == TRUE) {
        length += Icb_SBWarning_EncodedSize(ThisPtr->sbWarning);
    }
    if (ThisPtr->exists__optional__dtcWarning == TRUE) {
        length += Icb_SBWarning_EncodedSize(ThisPtr->dtcWarning);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpServiceBooking_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpServiceBooking_Notification_t);
    length += ASN_UTF8String_SessionSize(0, 5);
    length += Icb_SBWarning_SessionSize();
    length += Icb_SBWarning_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpServiceBooking_Notification_Print(Icb_OpServiceBooking_Notification ThisPtr) {
    ASN_PrintIndented("exists__optional__sbText" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__sbText);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("exists__optional__sbWarning" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__sbWarning);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("exists__optional__dtcWarning" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__dtcWarning);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sbTrigger" EOL);
    ASN_PrintSetIndent(1);
    Icb_SBTrigger_Print(ThisPtr->sbTrigger);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__sbText == TRUE) {
        ASN_PrintIndented("sbText" EOL);
        ASN_PrintSetIndent(1);
        ASN_UTF8String_Print(ThisPtr->sbText);
        ASN_PrintSetIndent(-1);
    }
    if (ThisPtr->exists__optional__sbWarning == TRUE) {
        ASN_PrintIndented("sbWarning" EOL);
        ASN_PrintSetIndent(1);
        Icb_SBWarning_Print(ThisPtr->sbWarning);
        ASN_PrintSetIndent(-1);
    }
    if (ThisPtr->exists__optional__dtcWarning == TRUE) {
        ASN_PrintIndented("dtcWarning" EOL);
        ASN_PrintSetIndent(1);
        Icb_SBWarning_Print(ThisPtr->dtcWarning);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpServiceBooking_Notification_Decode(Icb_OpServiceBooking_Notification ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__sbText, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__sbWarning, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__dtcWarning, session, stream));
    ASN_DECODE_CHECK(Icb_SBTrigger_Decode(&ThisPtr->sbTrigger, session, stream));
    if (ThisPtr->exists__optional__sbText == TRUE) {
        ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->sbText, session, stream, 0, 5));
    }
    if (ThisPtr->exists__optional__sbWarning == TRUE) {
        ASN_DECODE_CHECK(Icb_SBWarning_Decode(ThisPtr->sbWarning, session, stream));
    }
    if (ThisPtr->exists__optional__dtcWarning == TRUE) {
        ASN_DECODE_CHECK(Icb_SBWarning_Decode(ThisPtr->dtcWarning, session, stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpServiceBooking_Notification_Encode(Icb_OpServiceBooking_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__sbText, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__sbWarning, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__dtcWarning, stream));
    ASN_ENCODE_CHECK(Icb_SBTrigger_Encode(ThisPtr->sbTrigger, stream));
    if (ThisPtr->exists__optional__sbText == TRUE) {
        ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->sbText, stream, 0, 5));
    }
    if (ThisPtr->exists__optional__sbWarning == TRUE) {
        ASN_ENCODE_CHECK(Icb_SBWarning_Encode(ThisPtr->sbWarning, stream));
    }
    if (ThisPtr->exists__optional__dtcWarning == TRUE) {
        ASN_ENCODE_CHECK(Icb_SBWarning_Encode(ThisPtr->dtcWarning, stream));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpServiceBooking_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpSoHPackageUploaded_Notification of type ASNSequence
 */

Icb_OpSoHPackageUploaded_Notification Icb_OpSoHPackageUploaded_Notification_Create(ASN_Session session) {
    Icb_OpSoHPackageUploaded_Notification value = (Icb_OpSoHPackageUploaded_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpSoHPackageUploaded_Notification_t));
    if (value != (Icb_OpSoHPackageUploaded_Notification)NULL) {
        value->packetID = ASN_UTF8String_Create(session);
        value->result = 0;
    }
    return value;
}

U32 Icb_OpSoHPackageUploaded_Notification_EncodedSize(Icb_OpSoHPackageUploaded_Notification ThisPtr) {
    U32 length = 0;
    length += ASN_UTF8String_EncodedSize(ThisPtr->packetID, 0, 40);
    length += Icb_GenericOkStatus_EncodedSize(ThisPtr->result);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSoHPackageUploaded_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpSoHPackageUploaded_Notification_t);
    length += ASN_UTF8String_SessionSize(0, 40);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSoHPackageUploaded_Notification_Print(Icb_OpSoHPackageUploaded_Notification ThisPtr) {
    ASN_PrintIndented("packetID" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->packetID);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("result" EOL);
    ASN_PrintSetIndent(1);
    Icb_GenericOkStatus_Print(ThisPtr->result);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSoHPackageUploaded_Notification_Decode(Icb_OpSoHPackageUploaded_Notification ThisPtr,
                                                        ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->packetID, session, stream, 0, 40));
    ASN_DECODE_CHECK(Icb_GenericOkStatus_Decode(&ThisPtr->result, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSoHPackageUploaded_Notification_Encode(Icb_OpSoHPackageUploaded_Notification ThisPtr,
                                                        ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->packetID, stream, 0, 40));
    ASN_ENCODE_CHECK(Icb_GenericOkStatus_Encode(ThisPtr->result, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSoHPackageUploaded_Notification of type ASNSequence
 */

static const U32 Icb_DataCounter_EnumMap[] = {
        e_Icb_DataCounter_psimSentReceived /* Index = 0 */
};

ASN_Result Icb_DataCounter_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 0, FALSE));

    if (*val >= 1) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_DataCounter_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_DataCounter_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_DataCounter_EnumMap, 1);

    if (index == 1) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 0, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_DataCounter_Print(Icb_DataCounter value) {
    switch (value) {
        case e_Icb_DataCounter_psimSentReceived:
            ASN_PrintIndented("psimSentReceived" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpPSIMResetDataCounter_SetRequest of type ASNSequence
 */

Icb_OpPSIMResetDataCounter_SetRequest Icb_OpPSIMResetDataCounter_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMResetDataCounter_SetRequest value = (Icb_OpPSIMResetDataCounter_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMResetDataCounter_SetRequest_t));
    if (value != (Icb_OpPSIMResetDataCounter_SetRequest)NULL) {
        value->counter = 0;
    }
    return value;
}

U32 Icb_OpPSIMResetDataCounter_SetRequest_EncodedSize(Icb_OpPSIMResetDataCounter_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_DataCounter_EncodedSize(ThisPtr->counter);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMResetDataCounter_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMResetDataCounter_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMResetDataCounter_SetRequest_Print(Icb_OpPSIMResetDataCounter_SetRequest ThisPtr) {
    ASN_PrintIndented("counter" EOL);
    ASN_PrintSetIndent(1);
    Icb_DataCounter_Print(ThisPtr->counter);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMResetDataCounter_SetRequest_Decode(Icb_OpPSIMResetDataCounter_SetRequest ThisPtr,
                                                        ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_DataCounter_Decode(&ThisPtr->counter, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMResetDataCounter_SetRequest_Encode(Icb_OpPSIMResetDataCounter_SetRequest ThisPtr,
                                                        ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_DataCounter_Encode(ThisPtr->counter, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMResetDataCounter_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMResetDataCounter_Response of type ASNSequence
 */

Icb_OpPSIMResetDataCounter_Response Icb_OpPSIMResetDataCounter_Response_Create(ASN_Session session) {
    Icb_OpPSIMResetDataCounter_Response value = (Icb_OpPSIMResetDataCounter_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMResetDataCounter_Response_t));
    if (value != (Icb_OpPSIMResetDataCounter_Response)NULL) {
        value->byteCount = 0;
        value->counter = 0;
    }
    return value;
}

U32 Icb_OpPSIMResetDataCounter_Response_EncodedSize(Icb_OpPSIMResetDataCounter_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_DataCounterValue_EncodedSize(ThisPtr->byteCount);
    length += Icb_DataCounter_EncodedSize(ThisPtr->counter);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMResetDataCounter_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMResetDataCounter_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMResetDataCounter_Response_Print(Icb_OpPSIMResetDataCounter_Response ThisPtr) {
    ASN_PrintIndented("byteCount" EOL);
    ASN_PrintSetIndent(1);
    Icb_DataCounterValue_Print(ThisPtr->byteCount);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("counter" EOL);
    ASN_PrintSetIndent(1);
    Icb_DataCounter_Print(ThisPtr->counter);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMResetDataCounter_Response_Decode(Icb_OpPSIMResetDataCounter_Response ThisPtr, ASN_Session session,
                                                      ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_DataCounterValue_Decode(&ThisPtr->byteCount, session, stream));
    ASN_DECODE_CHECK(Icb_DataCounter_Decode(&ThisPtr->counter, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMResetDataCounter_Response_Encode(Icb_OpPSIMResetDataCounter_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_DataCounterValue_Encode(ThisPtr->byteCount, stream));
    ASN_ENCODE_CHECK(Icb_DataCounter_Encode(ThisPtr->counter, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMResetDataCounter_Response of type ASNSequence
 */

/*
 * Start of Icb_APNConfiguration of type ASNSequence
 */

Icb_APNConfiguration Icb_APNConfiguration_Create(ASN_Session session) {
    Icb_APNConfiguration value = (Icb_APNConfiguration)ASN_Malloc(session, sizeof(struct Icb_APNConfiguration_t));
    if (value != (Icb_APNConfiguration)NULL) {
        value->apnName = ASN_OctetString_Create(session);
        value->username = ASN_OctetString_Create(session);
        value->password = ASN_OctetString_Create(session);
    }
    return value;
}

U32 Icb_APNConfiguration_EncodedSize(Icb_APNConfiguration ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_OctetString_EncodedSize(ThisPtr->apnName, 0, 63);
    length += ASN_OctetString_EncodedSize(ThisPtr->username, 0, 30);
    length += ASN_OctetString_EncodedSize(ThisPtr->password, 0, 30);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_APNConfiguration_SessionSize() {
    U32 length = sizeof(struct Icb_APNConfiguration_t);
    length += ASN_OctetString_SessionSize(0, 63);
    length += ASN_OctetString_SessionSize(0, 30);
    length += ASN_OctetString_SessionSize(0, 30);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_APNConfiguration_Print(Icb_APNConfiguration ThisPtr) {
    ASN_PrintIndented("apnName" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->apnName);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("username" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->username);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("password" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->password);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_APNConfiguration_Decode(Icb_APNConfiguration ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->apnName, session, stream, 0, 63));
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->username, session, stream, 0, 30));
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->password, session, stream, 0, 30));
    return ASN_RESULT_OK;
}

ASN_Result Icb_APNConfiguration_Encode(Icb_APNConfiguration ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->apnName, stream, 0, 63));
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->username, stream, 0, 30));
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->password, stream, 0, 30));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_APNConfiguration of type ASNSequence
 */

/*
 * Start of Icb_AutomaticAPNConfiguration of type ASNSequence
 */

Icb_AutomaticAPNConfiguration Icb_AutomaticAPNConfiguration_Create(ASN_Session session) {
    Icb_AutomaticAPNConfiguration value =
            (Icb_AutomaticAPNConfiguration)ASN_Malloc(session, sizeof(struct Icb_AutomaticAPNConfiguration_t));
    if (value != (Icb_AutomaticAPNConfiguration)NULL) {
        value->exists__optional__configuration = 0;
        value->configuration = Icb_APNConfiguration_Create(session);
    }
    return value;
}

U32 Icb_AutomaticAPNConfiguration_EncodedSize(Icb_AutomaticAPNConfiguration ThisPtr) {
    U32 length = 0;
    length += BOOL_EncodedSize(ThisPtr->exists__optional__configuration);
    if (ThisPtr->exists__optional__configuration == TRUE) {
        length += Icb_APNConfiguration_EncodedSize(ThisPtr->configuration);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_AutomaticAPNConfiguration_SessionSize() {
    U32 length = sizeof(struct Icb_AutomaticAPNConfiguration_t);
    length += Icb_APNConfiguration_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_AutomaticAPNConfiguration_Print(Icb_AutomaticAPNConfiguration ThisPtr) {
    ASN_PrintIndented("exists__optional__configuration" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__configuration);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__configuration == TRUE) {
        ASN_PrintIndented("configuration" EOL);
        ASN_PrintSetIndent(1);
        Icb_APNConfiguration_Print(ThisPtr->configuration);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_AutomaticAPNConfiguration_Decode(Icb_AutomaticAPNConfiguration ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__configuration, session, stream));
    if (ThisPtr->exists__optional__configuration == TRUE) {
        ASN_DECODE_CHECK(Icb_APNConfiguration_Decode(ThisPtr->configuration, session, stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_AutomaticAPNConfiguration_Encode(Icb_AutomaticAPNConfiguration ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__configuration, stream));
    if (ThisPtr->exists__optional__configuration == TRUE) {
        ASN_ENCODE_CHECK(Icb_APNConfiguration_Encode(ThisPtr->configuration, stream));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_AutomaticAPNConfiguration of type ASNSequence
 */

/*
 * Start of Icb_APNSelection of type ASNChoice
 */

Icb_APNSelection Icb_APNSelection_Create(ASN_Session session) {
    Icb_APNSelection value = (Icb_APNSelection)ASN_Malloc(session, sizeof(struct Icb_APNSelection_t));
    value->automatic = (Icb_AutomaticAPNConfiguration)NULL;
    value->manual = (Icb_APNConfiguration)NULL;
    value->autoFailed = (Icb_AutomaticAPNConfiguration)NULL;
    return value;
}

U32 Icb_APNSelection_EncodedSize(Icb_APNSelection ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 2);
    switch (ThisPtr->choice) {
        case e_Icb_APNSelection_automatic:
            length += Icb_AutomaticAPNConfiguration_EncodedSize(ThisPtr->automatic);
            break;
        case e_Icb_APNSelection_manual:
            length += Icb_APNConfiguration_EncodedSize(ThisPtr->manual);
            break;
        case e_Icb_APNSelection_autoFailed:
            length += Icb_AutomaticAPNConfiguration_EncodedSize(ThisPtr->autoFailed);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_APNSelection_SessionSize() {
    U32 max = 0;
    U32 length;
    length = Icb_AutomaticAPNConfiguration_SessionSize();
    if (length > max) max = length;

    length = Icb_APNConfiguration_SessionSize();
    if (length > max) max = length;

    length = Icb_AutomaticAPNConfiguration_SessionSize();
    if (length > max) max = length;

    return max + sizeof(struct Icb_APNSelection_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_APNSelection_Decode(Icb_APNSelection ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 2));
    ASN_SETTYPE_CHECK(Icb_APNSelection_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_APNSelection_automatic:
            ASN_DECODE_CHECK(Icb_AutomaticAPNConfiguration_Decode(ThisPtr->automatic, session, stream));
            break;

        case e_Icb_APNSelection_manual:
            ASN_DECODE_CHECK(Icb_APNConfiguration_Decode(ThisPtr->manual, session, stream));
            break;

        case e_Icb_APNSelection_autoFailed:
            ASN_DECODE_CHECK(Icb_AutomaticAPNConfiguration_Decode(ThisPtr->autoFailed, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_APNSelection_Encode(Icb_APNSelection ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 2));
    switch (ThisPtr->choice) {
        case e_Icb_APNSelection_automatic:
            ASN_ENCODE_CHECK(Icb_AutomaticAPNConfiguration_Encode(ThisPtr->automatic, stream));
            break;

        case e_Icb_APNSelection_manual:
            ASN_ENCODE_CHECK(Icb_APNConfiguration_Encode(ThisPtr->manual, stream));
            break;

        case e_Icb_APNSelection_autoFailed:
            ASN_ENCODE_CHECK(Icb_AutomaticAPNConfiguration_Encode(ThisPtr->autoFailed, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_APNSelection_SetType(Icb_APNSelection ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_APNSelection_automatic) {
        ThisPtr->choice = type;
        ThisPtr->automatic = Icb_AutomaticAPNConfiguration_Create(session);
        ASN_MEM_CHECK(ThisPtr->automatic);
    } else
        ThisPtr->automatic = (Icb_AutomaticAPNConfiguration)NULL;

    if (type == e_Icb_APNSelection_manual) {
        ThisPtr->choice = type;
        ThisPtr->manual = Icb_APNConfiguration_Create(session);
        ASN_MEM_CHECK(ThisPtr->manual);
    } else
        ThisPtr->manual = (Icb_APNConfiguration)NULL;

    if (type == e_Icb_APNSelection_autoFailed) {
        ThisPtr->choice = type;
        ThisPtr->autoFailed = Icb_AutomaticAPNConfiguration_Create(session);
        ASN_MEM_CHECK(ThisPtr->autoFailed);
    } else
        ThisPtr->autoFailed = (Icb_AutomaticAPNConfiguration)NULL;

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_APNSelection_Print(Icb_APNSelection ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_APNSelection_automatic:
            ASN_PrintIndented("Icb_APNSelection is automatic" EOL);
            ASN_PrintSetIndent(1);
            Icb_AutomaticAPNConfiguration_Print(ThisPtr->automatic);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_APNSelection_manual:
            ASN_PrintIndented("Icb_APNSelection is manual" EOL);
            ASN_PrintSetIndent(1);
            Icb_APNConfiguration_Print(ThisPtr->manual);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_APNSelection_autoFailed:
            ASN_PrintIndented("Icb_APNSelection is autoFailed" EOL);
            ASN_PrintSetIndent(1);
            Icb_AutomaticAPNConfiguration_Print(ThisPtr->autoFailed);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_APNSelection of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_OpPSIMConnect_SetRequest of type ASNSequence
 */

Icb_OpPSIMConnect_SetRequest Icb_OpPSIMConnect_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMConnect_SetRequest value =
            (Icb_OpPSIMConnect_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpPSIMConnect_SetRequest_t));
    if (value != (Icb_OpPSIMConnect_SetRequest)NULL) {
        value->onOff = 0;
    }
    return value;
}

U32 Icb_OpPSIMConnect_SetRequest_EncodedSize(Icb_OpPSIMConnect_SetRequest ThisPtr) {
    U32 length = 0;
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->onOff);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMConnect_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMConnect_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMConnect_SetRequest_Print(Icb_OpPSIMConnect_SetRequest ThisPtr) {
    ASN_PrintIndented("onOff" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->onOff);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMConnect_SetRequest_Decode(Icb_OpPSIMConnect_SetRequest ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->onOff, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMConnect_SetRequest_Encode(Icb_OpPSIMConnect_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->onOff, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMConnect_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMConnect_Response of type ASNSequence
 */

Icb_OpPSIMConnect_Response Icb_OpPSIMConnect_Response_Create(ASN_Session session) {
    Icb_OpPSIMConnect_Response value =
            (Icb_OpPSIMConnect_Response)ASN_Malloc(session, sizeof(struct Icb_OpPSIMConnect_Response_t));
    if (value != (Icb_OpPSIMConnect_Response)NULL) {
        value->onOff = 0;
    }
    return value;
}

U32 Icb_OpPSIMConnect_Response_EncodedSize(Icb_OpPSIMConnect_Response ThisPtr) {
    U32 length = 0;
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->onOff);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMConnect_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMConnect_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMConnect_Response_Print(Icb_OpPSIMConnect_Response ThisPtr) {
    ASN_PrintIndented("onOff" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->onOff);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMConnect_Response_Decode(Icb_OpPSIMConnect_Response ThisPtr, ASN_Session session,
                                             ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->onOff, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMConnect_Response_Encode(Icb_OpPSIMConnect_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->onOff, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMConnect_Response of type ASNSequence
 */

static const U32 Icb_PSIMConnectionStatus_EnumMap[] = {
        e_Icb_PSIMConnectionStatus_connectedHome,    /* Index = 0 */
        e_Icb_PSIMConnectionStatus_connectedRoaming, /* Index = 1 */
        e_Icb_PSIMConnectionStatus_connecting,       /* Index = 2 */
        e_Icb_PSIMConnectionStatus_disconnected,     /* Index = 3 */
        e_Icb_PSIMConnectionStatus_prohibited        /* Index = 4 */
};

ASN_Result Icb_PSIMConnectionStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 4, FALSE));

    if (*val >= 5) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_PSIMConnectionStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_PSIMConnectionStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_PSIMConnectionStatus_EnumMap, 5);

    if (index == 5) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 4, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_PSIMConnectionStatus_Print(Icb_PSIMConnectionStatus value) {
    switch (value) {
        case e_Icb_PSIMConnectionStatus_connectedHome:
            ASN_PrintIndented("connectedHome" EOL);
            break;
        case e_Icb_PSIMConnectionStatus_connectedRoaming:
            ASN_PrintIndented("connectedRoaming" EOL);
            break;
        case e_Icb_PSIMConnectionStatus_connecting:
            ASN_PrintIndented("connecting" EOL);
            break;
        case e_Icb_PSIMConnectionStatus_disconnected:
            ASN_PrintIndented("disconnected" EOL);
            break;
        case e_Icb_PSIMConnectionStatus_prohibited:
            ASN_PrintIndented("prohibited" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_WirelessTechnology_EnumMap[] = {
        e_Icb_WirelessTechnology_unknown, /* Index = 0 */
        e_Icb_WirelessTechnology_gprs,    /* Index = 1 */
        e_Icb_WirelessTechnology_edge,    /* Index = 2 */
        e_Icb_WirelessTechnology_umts,    /* Index = 3 */
        e_Icb_WirelessTechnology_hsdpa,   /* Index = 4 */
        e_Icb_WirelessTechnology_hsupa,   /* Index = 5 */
        e_Icb_WirelessTechnology_lte      /* Index = 6 */
};

ASN_Result Icb_WirelessTechnology_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 6, FALSE));

    if (*val >= 7) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WirelessTechnology_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WirelessTechnology_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WirelessTechnology_EnumMap, 7);

    if (index == 7) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 6, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WirelessTechnology_Print(Icb_WirelessTechnology value) {
    switch (value) {
        case e_Icb_WirelessTechnology_unknown:
            ASN_PrintIndented("unknown" EOL);
            break;
        case e_Icb_WirelessTechnology_gprs:
            ASN_PrintIndented("gprs" EOL);
            break;
        case e_Icb_WirelessTechnology_edge:
            ASN_PrintIndented("edge" EOL);
            break;
        case e_Icb_WirelessTechnology_umts:
            ASN_PrintIndented("umts" EOL);
            break;
        case e_Icb_WirelessTechnology_hsdpa:
            ASN_PrintIndented("hsdpa" EOL);
            break;
        case e_Icb_WirelessTechnology_hsupa:
            ASN_PrintIndented("hsupa" EOL);
            break;
        case e_Icb_WirelessTechnology_lte:
            ASN_PrintIndented("lte" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpPSIMRoamingConfiguration_SetRequest of type ASNSequence
 */

Icb_OpPSIMRoamingConfiguration_SetRequest Icb_OpPSIMRoamingConfiguration_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMRoamingConfiguration_SetRequest value = (Icb_OpPSIMRoamingConfiguration_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMRoamingConfiguration_SetRequest_t));
    if (value != (Icb_OpPSIMRoamingConfiguration_SetRequest)NULL) {
        value->roamingAllowed = 0;
    }
    return value;
}

U32 Icb_OpPSIMRoamingConfiguration_SetRequest_EncodedSize(Icb_OpPSIMRoamingConfiguration_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->roamingAllowed);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMRoamingConfiguration_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMRoamingConfiguration_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMRoamingConfiguration_SetRequest_Print(Icb_OpPSIMRoamingConfiguration_SetRequest ThisPtr) {
    ASN_PrintIndented("roamingAllowed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->roamingAllowed);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMRoamingConfiguration_SetRequest_Decode(Icb_OpPSIMRoamingConfiguration_SetRequest ThisPtr,
                                                            ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->roamingAllowed, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMRoamingConfiguration_SetRequest_Encode(Icb_OpPSIMRoamingConfiguration_SetRequest ThisPtr,
                                                            ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->roamingAllowed, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMRoamingConfiguration_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMRoamingConfiguration_Response of type ASNSequence
 */

Icb_OpPSIMRoamingConfiguration_Response Icb_OpPSIMRoamingConfiguration_Response_Create(ASN_Session session) {
    Icb_OpPSIMRoamingConfiguration_Response value = (Icb_OpPSIMRoamingConfiguration_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMRoamingConfiguration_Response_t));
    if (value != (Icb_OpPSIMRoamingConfiguration_Response)NULL) {
        value->roamingAllowed = 0;
    }
    return value;
}

U32 Icb_OpPSIMRoamingConfiguration_Response_EncodedSize(Icb_OpPSIMRoamingConfiguration_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->roamingAllowed);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMRoamingConfiguration_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMRoamingConfiguration_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMRoamingConfiguration_Response_Print(Icb_OpPSIMRoamingConfiguration_Response ThisPtr) {
    ASN_PrintIndented("roamingAllowed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->roamingAllowed);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMRoamingConfiguration_Response_Decode(Icb_OpPSIMRoamingConfiguration_Response ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->roamingAllowed, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMRoamingConfiguration_Response_Encode(Icb_OpPSIMRoamingConfiguration_Response ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->roamingAllowed, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMRoamingConfiguration_Response of type ASNSequence
 */

/*
 * Start of Icb_OpAccessRightPinCode_Response of type ASNSequence
 */

Icb_OpAccessRightPinCode_Response Icb_OpAccessRightPinCode_Response_Create(ASN_Session session) {
    Icb_OpAccessRightPinCode_Response value =
            (Icb_OpAccessRightPinCode_Response)ASN_Malloc(session, sizeof(struct Icb_OpAccessRightPinCode_Response_t));
    if (value != (Icb_OpAccessRightPinCode_Response)NULL) {
        value->pinCodeChangeAllowed = 0;
    }
    return value;
}

U32 Icb_OpAccessRightPinCode_Response_EncodedSize(Icb_OpAccessRightPinCode_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->pinCodeChangeAllowed);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpAccessRightPinCode_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpAccessRightPinCode_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpAccessRightPinCode_Response_Print(Icb_OpAccessRightPinCode_Response ThisPtr) {
    ASN_PrintIndented("pinCodeChangeAllowed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->pinCodeChangeAllowed);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpAccessRightPinCode_Response_Decode(Icb_OpAccessRightPinCode_Response ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->pinCodeChangeAllowed, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpAccessRightPinCode_Response_Encode(Icb_OpAccessRightPinCode_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->pinCodeChangeAllowed, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpAccessRightPinCode_Response of type ASNSequence
 */

static const U32 Icb_Ecu_EnumMap[] = {
        e_Icb_Ecu_none, /* Index = 0 */
        e_Icb_Ecu_ihu,  /* Index = 1 */
        e_Icb_Ecu_vcm,  /* Index = 2 */
        e_Icb_Ecu_tem   /* Index = 3 */
};

ASN_Result Icb_Ecu_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_Ecu_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_Ecu_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_Ecu_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_Ecu_Print(Icb_Ecu value) {
    switch (value) {
        case e_Icb_Ecu_none:
            ASN_PrintIndented("none" EOL);
            break;
        case e_Icb_Ecu_ihu:
            ASN_PrintIndented("ihu" EOL);
            break;
        case e_Icb_Ecu_vcm:
            ASN_PrintIndented("vcm" EOL);
            break;
        case e_Icb_Ecu_tem:
            ASN_PrintIndented("tem" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpFactoryDefaultRestore_Response of type ASNSequence
 */

Icb_OpFactoryDefaultRestore_Response Icb_OpFactoryDefaultRestore_Response_Create(ASN_Session session) {
    Icb_OpFactoryDefaultRestore_Response value = (Icb_OpFactoryDefaultRestore_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpFactoryDefaultRestore_Response_t));
    if (value != (Icb_OpFactoryDefaultRestore_Response)NULL) {
        value->restorationResult = 0;
    }
    return value;
}

U32 Icb_OpFactoryDefaultRestore_Response_EncodedSize(Icb_OpFactoryDefaultRestore_Response ThisPtr) {
    U32 length = 0;
    length += BOOL_EncodedSize(ThisPtr->restorationResult);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpFactoryDefaultRestore_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpFactoryDefaultRestore_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpFactoryDefaultRestore_Response_Print(Icb_OpFactoryDefaultRestore_Response ThisPtr) {
    ASN_PrintIndented("restorationResult" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->restorationResult);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpFactoryDefaultRestore_Response_Decode(Icb_OpFactoryDefaultRestore_Response ThisPtr,
                                                       ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->restorationResult, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpFactoryDefaultRestore_Response_Encode(Icb_OpFactoryDefaultRestore_Response ThisPtr,
                                                       ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->restorationResult, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpFactoryDefaultRestore_Response of type ASNSequence
 */

/*
 * Start of Icb_OpConnectivityStatus_Response of type ASNSequence
 */

Icb_OpConnectivityStatus_Response Icb_OpConnectivityStatus_Response_Create(ASN_Session session) {
    Icb_OpConnectivityStatus_Response value =
            (Icb_OpConnectivityStatus_Response)ASN_Malloc(session, sizeof(struct Icb_OpConnectivityStatus_Response_t));
    if (value != (Icb_OpConnectivityStatus_Response)NULL) {
        value->generalConnectivityAvailable = 0;
    }
    return value;
}

U32 Icb_OpConnectivityStatus_Response_EncodedSize(Icb_OpConnectivityStatus_Response ThisPtr) {
    U32 length = 0;
    length += BOOL_EncodedSize(ThisPtr->generalConnectivityAvailable);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpConnectivityStatus_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpConnectivityStatus_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpConnectivityStatus_Response_Print(Icb_OpConnectivityStatus_Response ThisPtr) {
    ASN_PrintIndented("generalConnectivityAvailable" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->generalConnectivityAvailable);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpConnectivityStatus_Response_Decode(Icb_OpConnectivityStatus_Response ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->generalConnectivityAvailable, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpConnectivityStatus_Response_Encode(Icb_OpConnectivityStatus_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->generalConnectivityAvailable, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpConnectivityStatus_Response of type ASNSequence
 */

/*
 * Start of Icb_OpConnectivityStatus_Notification of type ASNSequence
 */

Icb_OpConnectivityStatus_Notification Icb_OpConnectivityStatus_Notification_Create(ASN_Session session) {
    Icb_OpConnectivityStatus_Notification value = (Icb_OpConnectivityStatus_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpConnectivityStatus_Notification_t));
    if (value != (Icb_OpConnectivityStatus_Notification)NULL) {
        value->generalConnectivityAvailable = 0;
    }
    return value;
}

U32 Icb_OpConnectivityStatus_Notification_EncodedSize(Icb_OpConnectivityStatus_Notification ThisPtr) {
    U32 length = 0;
    length += BOOL_EncodedSize(ThisPtr->generalConnectivityAvailable);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpConnectivityStatus_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpConnectivityStatus_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpConnectivityStatus_Notification_Print(Icb_OpConnectivityStatus_Notification ThisPtr) {
    ASN_PrintIndented("generalConnectivityAvailable" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->generalConnectivityAvailable);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpConnectivityStatus_Notification_Decode(Icb_OpConnectivityStatus_Notification ThisPtr,
                                                        ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->generalConnectivityAvailable, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpConnectivityStatus_Notification_Encode(Icb_OpConnectivityStatus_Notification ThisPtr,
                                                        ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->generalConnectivityAvailable, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpConnectivityStatus_Notification of type ASNSequence
 */

static const U32 Icb_WorkshopWlanConnectionResult_EnumMap[] = {
        e_Icb_WorkshopWlanConnectionResult_connected,             /* Index = 0 */
        e_Icb_WorkshopWlanConnectionResult_failed_no_aps,         /* Index = 1 */
        e_Icb_WorkshopWlanConnectionResult_failed_authentication, /* Index = 2 */
        e_Icb_WorkshopWlanConnectionResult_failed_timeout,        /* Index = 3 */
        e_Icb_WorkshopWlanConnectionResult_failed_general         /* Index = 4 */
};

ASN_Result Icb_WorkshopWlanConnectionResult_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 4, FALSE));

    if (*val >= 5) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WorkshopWlanConnectionResult_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WorkshopWlanConnectionResult_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WorkshopWlanConnectionResult_EnumMap, 5);

    if (index == 5) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 4, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WorkshopWlanConnectionResult_Print(Icb_WorkshopWlanConnectionResult value) {
    switch (value) {
        case e_Icb_WorkshopWlanConnectionResult_connected:
            ASN_PrintIndented("connected" EOL);
            break;
        case e_Icb_WorkshopWlanConnectionResult_failed_no_aps:
            ASN_PrintIndented("failed_no_aps" EOL);
            break;
        case e_Icb_WorkshopWlanConnectionResult_failed_authentication:
            ASN_PrintIndented("failed_authentication" EOL);
            break;
        case e_Icb_WorkshopWlanConnectionResult_failed_timeout:
            ASN_PrintIndented("failed_timeout" EOL);
            break;
        case e_Icb_WorkshopWlanConnectionResult_failed_general:
            ASN_PrintIndented("failed_general" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpWorkshopWlanDetected_Notification of type ASNSequence
 */

Icb_OpWorkshopWlanDetected_Notification Icb_OpWorkshopWlanDetected_Notification_Create(ASN_Session session) {
    Icb_OpWorkshopWlanDetected_Notification value = (Icb_OpWorkshopWlanDetected_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpWorkshopWlanDetected_Notification_t));
    if (value != (Icb_OpWorkshopWlanDetected_Notification)NULL) {
        value->mode = 0;
        value->nomadicDevicePresent = 0;
    }
    return value;
}

U32 Icb_OpWorkshopWlanDetected_Notification_EncodedSize(Icb_OpWorkshopWlanDetected_Notification ThisPtr) {
    U32 length = 0;
    length += U32_EncodedSize(ThisPtr->mode, 0, 2);
    length += BOOL_EncodedSize(ThisPtr->nomadicDevicePresent);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWorkshopWlanDetected_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpWorkshopWlanDetected_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWorkshopWlanDetected_Notification_Print(Icb_OpWorkshopWlanDetected_Notification ThisPtr) {
    ASN_PrintIndented("mode" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->mode);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("nomadicDevicePresent" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->nomadicDevicePresent);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWorkshopWlanDetected_Notification_Decode(Icb_OpWorkshopWlanDetected_Notification ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->mode, session, stream, 0, 2));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->nomadicDevicePresent, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWorkshopWlanDetected_Notification_Encode(Icb_OpWorkshopWlanDetected_Notification ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->mode, stream, 0, 2));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->nomadicDevicePresent, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWorkshopWlanDetected_Notification of type ASNSequence
 */

static const U32 Icb_InternetSource_EnumMap[] = {
        e_Icb_InternetSource_none,      /* Index = 0 */
        e_Icb_InternetSource_psim,      /* Index = 1 */
        e_Icb_InternetSource_bluetooth, /* Index = 2 */
        e_Icb_InternetSource_usb        /* Index = 3 */
};

ASN_Result Icb_InternetSource_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 255, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_InternetSource_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_InternetSource_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_InternetSource_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 255, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_InternetSource_Print(Icb_InternetSource value) {
    switch (value) {
        case e_Icb_InternetSource_none:
            ASN_PrintIndented("none" EOL);
            break;
        case e_Icb_InternetSource_psim:
            ASN_PrintIndented("psim" EOL);
            break;
        case e_Icb_InternetSource_bluetooth:
            ASN_PrintIndented("bluetooth" EOL);
            break;
        case e_Icb_InternetSource_usb:
            ASN_PrintIndented("usb" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpInternetSourceCtrlBT_SetRequest of type ASNSequence
 */

Icb_OpInternetSourceCtrlBT_SetRequest Icb_OpInternetSourceCtrlBT_SetRequest_Create(ASN_Session session) {
    Icb_OpInternetSourceCtrlBT_SetRequest value = (Icb_OpInternetSourceCtrlBT_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpInternetSourceCtrlBT_SetRequest_t));
    if (value != (Icb_OpInternetSourceCtrlBT_SetRequest)NULL) {
        value->onOff = 0;
    }
    return value;
}

U32 Icb_OpInternetSourceCtrlBT_SetRequest_EncodedSize(Icb_OpInternetSourceCtrlBT_SetRequest ThisPtr) {
    U32 length = 0;
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->onOff);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpInternetSourceCtrlBT_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpInternetSourceCtrlBT_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpInternetSourceCtrlBT_SetRequest_Print(Icb_OpInternetSourceCtrlBT_SetRequest ThisPtr) {
    ASN_PrintIndented("onOff" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->onOff);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpInternetSourceCtrlBT_SetRequest_Decode(Icb_OpInternetSourceCtrlBT_SetRequest ThisPtr,
                                                        ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->onOff, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpInternetSourceCtrlBT_SetRequest_Encode(Icb_OpInternetSourceCtrlBT_SetRequest ThisPtr,
                                                        ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->onOff, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpInternetSourceCtrlBT_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpInternetSourceCtrlBT_Response of type ASNSequence
 */

Icb_OpInternetSourceCtrlBT_Response Icb_OpInternetSourceCtrlBT_Response_Create(ASN_Session session) {
    Icb_OpInternetSourceCtrlBT_Response value = (Icb_OpInternetSourceCtrlBT_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpInternetSourceCtrlBT_Response_t));
    if (value != (Icb_OpInternetSourceCtrlBT_Response)NULL) {
        value->onOff = 0;
    }
    return value;
}

U32 Icb_OpInternetSourceCtrlBT_Response_EncodedSize(Icb_OpInternetSourceCtrlBT_Response ThisPtr) {
    U32 length = 0;
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->onOff);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpInternetSourceCtrlBT_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpInternetSourceCtrlBT_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpInternetSourceCtrlBT_Response_Print(Icb_OpInternetSourceCtrlBT_Response ThisPtr) {
    ASN_PrintIndented("onOff" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->onOff);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpInternetSourceCtrlBT_Response_Decode(Icb_OpInternetSourceCtrlBT_Response ThisPtr, ASN_Session session,
                                                      ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->onOff, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpInternetSourceCtrlBT_Response_Encode(Icb_OpInternetSourceCtrlBT_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->onOff, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpInternetSourceCtrlBT_Response of type ASNSequence
 */

/*
 * Start of Icb_OpInternetSourceCtrlBT_Notification of type ASNSequence
 */

Icb_OpInternetSourceCtrlBT_Notification Icb_OpInternetSourceCtrlBT_Notification_Create(ASN_Session session) {
    Icb_OpInternetSourceCtrlBT_Notification value = (Icb_OpInternetSourceCtrlBT_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpInternetSourceCtrlBT_Notification_t));
    if (value != (Icb_OpInternetSourceCtrlBT_Notification)NULL) {
        value->onOff = 0;
    }
    return value;
}

U32 Icb_OpInternetSourceCtrlBT_Notification_EncodedSize(Icb_OpInternetSourceCtrlBT_Notification ThisPtr) {
    U32 length = 0;
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->onOff);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpInternetSourceCtrlBT_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpInternetSourceCtrlBT_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpInternetSourceCtrlBT_Notification_Print(Icb_OpInternetSourceCtrlBT_Notification ThisPtr) {
    ASN_PrintIndented("onOff" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->onOff);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpInternetSourceCtrlBT_Notification_Decode(Icb_OpInternetSourceCtrlBT_Notification ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->onOff, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpInternetSourceCtrlBT_Notification_Encode(Icb_OpInternetSourceCtrlBT_Notification ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->onOff, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpInternetSourceCtrlBT_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpInternetSourceCtrlUSB_SetRequest of type ASNSequence
 */

Icb_OpInternetSourceCtrlUSB_SetRequest Icb_OpInternetSourceCtrlUSB_SetRequest_Create(ASN_Session session) {
    Icb_OpInternetSourceCtrlUSB_SetRequest value = (Icb_OpInternetSourceCtrlUSB_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpInternetSourceCtrlUSB_SetRequest_t));
    if (value != (Icb_OpInternetSourceCtrlUSB_SetRequest)NULL) {
        value->onOff = 0;
    }
    return value;
}

U32 Icb_OpInternetSourceCtrlUSB_SetRequest_EncodedSize(Icb_OpInternetSourceCtrlUSB_SetRequest ThisPtr) {
    U32 length = 0;
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->onOff);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpInternetSourceCtrlUSB_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpInternetSourceCtrlUSB_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpInternetSourceCtrlUSB_SetRequest_Print(Icb_OpInternetSourceCtrlUSB_SetRequest ThisPtr) {
    ASN_PrintIndented("onOff" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->onOff);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpInternetSourceCtrlUSB_SetRequest_Decode(Icb_OpInternetSourceCtrlUSB_SetRequest ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->onOff, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpInternetSourceCtrlUSB_SetRequest_Encode(Icb_OpInternetSourceCtrlUSB_SetRequest ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->onOff, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpInternetSourceCtrlUSB_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpInternetSourceCtrlUSB_Response of type ASNSequence
 */

Icb_OpInternetSourceCtrlUSB_Response Icb_OpInternetSourceCtrlUSB_Response_Create(ASN_Session session) {
    Icb_OpInternetSourceCtrlUSB_Response value = (Icb_OpInternetSourceCtrlUSB_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpInternetSourceCtrlUSB_Response_t));
    if (value != (Icb_OpInternetSourceCtrlUSB_Response)NULL) {
        value->onOff = 0;
    }
    return value;
}

U32 Icb_OpInternetSourceCtrlUSB_Response_EncodedSize(Icb_OpInternetSourceCtrlUSB_Response ThisPtr) {
    U32 length = 0;
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->onOff);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpInternetSourceCtrlUSB_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpInternetSourceCtrlUSB_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpInternetSourceCtrlUSB_Response_Print(Icb_OpInternetSourceCtrlUSB_Response ThisPtr) {
    ASN_PrintIndented("onOff" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->onOff);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpInternetSourceCtrlUSB_Response_Decode(Icb_OpInternetSourceCtrlUSB_Response ThisPtr,
                                                       ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->onOff, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpInternetSourceCtrlUSB_Response_Encode(Icb_OpInternetSourceCtrlUSB_Response ThisPtr,
                                                       ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->onOff, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpInternetSourceCtrlUSB_Response of type ASNSequence
 */

/*
 * Start of Icb_OpInternetSourceCtrlUSB_Notification of type ASNSequence
 */

Icb_OpInternetSourceCtrlUSB_Notification Icb_OpInternetSourceCtrlUSB_Notification_Create(ASN_Session session) {
    Icb_OpInternetSourceCtrlUSB_Notification value = (Icb_OpInternetSourceCtrlUSB_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpInternetSourceCtrlUSB_Notification_t));
    if (value != (Icb_OpInternetSourceCtrlUSB_Notification)NULL) {
        value->onOff = 0;
    }
    return value;
}

U32 Icb_OpInternetSourceCtrlUSB_Notification_EncodedSize(Icb_OpInternetSourceCtrlUSB_Notification ThisPtr) {
    U32 length = 0;
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->onOff);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpInternetSourceCtrlUSB_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpInternetSourceCtrlUSB_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpInternetSourceCtrlUSB_Notification_Print(Icb_OpInternetSourceCtrlUSB_Notification ThisPtr) {
    ASN_PrintIndented("onOff" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->onOff);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpInternetSourceCtrlUSB_Notification_Decode(Icb_OpInternetSourceCtrlUSB_Notification ThisPtr,
                                                           ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->onOff, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpInternetSourceCtrlUSB_Notification_Encode(Icb_OpInternetSourceCtrlUSB_Notification ThisPtr,
                                                           ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->onOff, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpInternetSourceCtrlUSB_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMMessage_SetRequest of type ASNSequence
 */

Icb_OpPSIMMessage_SetRequest Icb_OpPSIMMessage_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMMessage_SetRequest value =
            (Icb_OpPSIMMessage_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpPSIMMessage_SetRequest_t));
    if (value != (Icb_OpPSIMMessage_SetRequest)NULL) {
        value->exists__optional__sender = 0;
        value->sender = ASN_UTF8String_Create(session);
        value->number = ASN_UTF8String_Create(session);
        value->body = ASN_UTF8String_Create(session);
        value->date = ASN_UTF8String_Create(session);
        value->time = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMMessage_SetRequest_EncodedSize(Icb_OpPSIMMessage_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__sender);
    if (ThisPtr->exists__optional__sender == TRUE) {
        length += ASN_UTF8String_EncodedSize(ThisPtr->sender, 1, 50);
    }
    length += ASN_UTF8String_EncodedSize(ThisPtr->number, 1, 40);
    length += ASN_UTF8String_EncodedSize(ThisPtr->body, 1, 500);
    length += ASN_UTF8String_EncodedSize(ThisPtr->date, 1, 40);
    length += ASN_UTF8String_EncodedSize(ThisPtr->time, 1, 40);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMMessage_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMMessage_SetRequest_t);
    length += ASN_UTF8String_SessionSize(1, 50);
    length += ASN_UTF8String_SessionSize(1, 40);
    length += ASN_UTF8String_SessionSize(1, 500);
    length += ASN_UTF8String_SessionSize(1, 40);
    length += ASN_UTF8String_SessionSize(1, 40);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMMessage_SetRequest_Print(Icb_OpPSIMMessage_SetRequest ThisPtr) {
    ASN_PrintIndented("exists__optional__sender" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__sender);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__sender == TRUE) {
        ASN_PrintIndented("sender" EOL);
        ASN_PrintSetIndent(1);
        ASN_UTF8String_Print(ThisPtr->sender);
        ASN_PrintSetIndent(-1);
    }
    ASN_PrintIndented("number" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->number);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("body" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->body);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("date" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->date);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("time" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->time);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMMessage_SetRequest_Decode(Icb_OpPSIMMessage_SetRequest ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__sender, session, stream));
    if (ThisPtr->exists__optional__sender == TRUE) {
        ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->sender, session, stream, 1, 50));
    }
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->number, session, stream, 1, 40));
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->body, session, stream, 1, 500));
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->date, session, stream, 1, 40));
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->time, session, stream, 1, 40));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMMessage_SetRequest_Encode(Icb_OpPSIMMessage_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__sender, stream));
    if (ThisPtr->exists__optional__sender == TRUE) {
        ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->sender, stream, 1, 50));
    }
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->number, stream, 1, 40));
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->body, stream, 1, 500));
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->date, stream, 1, 40));
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->time, stream, 1, 40));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMMessage_SetRequest of type ASNSequence
 */

static const U32 Icb_WLANMode_EnumMap[] = {
        e_Icb_WLANMode_off,  /* Index = 0 */
        e_Icb_WLANMode_sta,  /* Index = 1 */
        e_Icb_WLANMode_ap,   /* Index = 2 */
        e_Icb_WLANMode_staWS /* Index = 3 */
};

ASN_Result Icb_WLANMode_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WLANMode_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANMode_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WLANMode_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WLANMode_Print(Icb_WLANMode value) {
    switch (value) {
        case e_Icb_WLANMode_off:
            ASN_PrintIndented("off" EOL);
            break;
        case e_Icb_WLANMode_sta:
            ASN_PrintIndented("sta" EOL);
            break;
        case e_Icb_WLANMode_ap:
            ASN_PrintIndented("ap" EOL);
            break;
        case e_Icb_WLANMode_staWS:
            ASN_PrintIndented("staWS" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_WLANFrequencyBand_EnumMap[] = {
        e_Icb_WLANFrequencyBand_lowFrequencyBand, /* Index = 0 */
        e_Icb_WLANFrequencyBand_highFrequencyBand /* Index = 1 */
};

ASN_Result Icb_WLANFrequencyBand_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WLANFrequencyBand_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANFrequencyBand_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WLANFrequencyBand_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WLANFrequencyBand_Print(Icb_WLANFrequencyBand value) {
    switch (value) {
        case e_Icb_WLANFrequencyBand_lowFrequencyBand:
            ASN_PrintIndented("lowFrequencyBand" EOL);
            break;
        case e_Icb_WLANFrequencyBand_highFrequencyBand:
            ASN_PrintIndented("highFrequencyBand" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_WLANChannelWidthData_EnumMap[] = {
        e_Icb_WLANChannelWidthData_width_5MHz,  /* Index = 0 */
        e_Icb_WLANChannelWidthData_width_10MHz, /* Index = 1 */
        e_Icb_WLANChannelWidthData_width_20MHz  /* Index = 2 */
};

ASN_Result Icb_WLANChannelWidthData_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WLANChannelWidthData_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANChannelWidthData_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WLANChannelWidthData_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WLANChannelWidthData_Print(Icb_WLANChannelWidthData value) {
    switch (value) {
        case e_Icb_WLANChannelWidthData_width_5MHz:
            ASN_PrintIndented("width_5MHz" EOL);
            break;
        case e_Icb_WLANChannelWidthData_width_10MHz:
            ASN_PrintIndented("width_10MHz" EOL);
            break;
        case e_Icb_WLANChannelWidthData_width_20MHz:
            ASN_PrintIndented("width_20MHz" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_WLANConnDevice of type ASNSequence
 */

Icb_WLANConnDevice Icb_WLANConnDevice_Create(ASN_Session session) {
    Icb_WLANConnDevice value = (Icb_WLANConnDevice)ASN_Malloc(session, sizeof(struct Icb_WLANConnDevice_t));
    if (value != (Icb_WLANConnDevice)NULL) {
        value->deviceName = ASN_OctetString_Create(session);
    }
    return value;
}

U32 Icb_WLANConnDevice_EncodedSize(Icb_WLANConnDevice ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_OctetString_EncodedSize(ThisPtr->deviceName, 0, 32);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_WLANConnDevice_SessionSize() {
    U32 length = sizeof(struct Icb_WLANConnDevice_t);
    length += ASN_OctetString_SessionSize(0, 32);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_WLANConnDevice_Print(Icb_WLANConnDevice ThisPtr) {
    ASN_PrintIndented("deviceName" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->deviceName);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_WLANConnDevice_Decode(Icb_WLANConnDevice ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->deviceName, session, stream, 0, 32));
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANConnDevice_Encode(Icb_WLANConnDevice ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->deviceName, stream, 0, 32));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_WLANConnDevice of type ASNSequence
 */

static const U32 Icb_WLANConnectStatus_EnumMap[] = {
        e_Icb_WLANConnectStatus_disconnected, /* Index = 0 */
        e_Icb_WLANConnectStatus_connected,    /* Index = 1 */
        e_Icb_WLANConnectStatus_wrongPassword /* Index = 2 */
};

ASN_Result Icb_WLANConnectStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WLANConnectStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANConnectStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WLANConnectStatus_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WLANConnectStatus_Print(Icb_WLANConnectStatus value) {
    switch (value) {
        case e_Icb_WLANConnectStatus_disconnected:
            ASN_PrintIndented("disconnected" EOL);
            break;
        case e_Icb_WLANConnectStatus_connected:
            ASN_PrintIndented("connected" EOL);
            break;
        case e_Icb_WLANConnectStatus_wrongPassword:
            ASN_PrintIndented("wrongPassword" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpWLANSTADisconnect_Response of type ASNSequence
 */

Icb_OpWLANSTADisconnect_Response Icb_OpWLANSTADisconnect_Response_Create(ASN_Session session) {
    Icb_OpWLANSTADisconnect_Response value =
            (Icb_OpWLANSTADisconnect_Response)ASN_Malloc(session, sizeof(struct Icb_OpWLANSTADisconnect_Response_t));
    if (value != (Icb_OpWLANSTADisconnect_Response)NULL) {
        value->wLANConnectStatus = 0;
    }
    return value;
}

U32 Icb_OpWLANSTADisconnect_Response_EncodedSize(Icb_OpWLANSTADisconnect_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANConnectStatus_EncodedSize(ThisPtr->wLANConnectStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANSTADisconnect_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANSTADisconnect_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANSTADisconnect_Response_Print(Icb_OpWLANSTADisconnect_Response ThisPtr) {
    ASN_PrintIndented("wLANConnectStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANConnectStatus_Print(ThisPtr->wLANConnectStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANSTADisconnect_Response_Decode(Icb_OpWLANSTADisconnect_Response ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANConnectStatus_Decode(&ThisPtr->wLANConnectStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANSTADisconnect_Response_Encode(Icb_OpWLANSTADisconnect_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANConnectStatus_Encode(ThisPtr->wLANConnectStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANSTADisconnect_Response of type ASNSequence
 */

static const U32 Icb_WLANAPCurrentStatus_EnumMap[] = {
        e_Icb_WLANAPCurrentStatus_disabled, /* Index = 0 */
        e_Icb_WLANAPCurrentStatus_enabled   /* Index = 1 */
};

ASN_Result Icb_WLANAPCurrentStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WLANAPCurrentStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANAPCurrentStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WLANAPCurrentStatus_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WLANAPCurrentStatus_Print(Icb_WLANAPCurrentStatus value) {
    switch (value) {
        case e_Icb_WLANAPCurrentStatus_disabled:
            ASN_PrintIndented("disabled" EOL);
            break;
        case e_Icb_WLANAPCurrentStatus_enabled:
            ASN_PrintIndented("enabled" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_WLANConnectionStatus_EnumMap[] = {
        e_Icb_WLANConnectionStatus_disconnected, /* Index = 0 */
        e_Icb_WLANConnectionStatus_connected     /* Index = 1 */
};

ASN_Result Icb_WLANConnectionStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WLANConnectionStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANConnectionStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WLANConnectionStatus_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WLANConnectionStatus_Print(Icb_WLANConnectionStatus value) {
    switch (value) {
        case e_Icb_WLANConnectionStatus_disconnected:
            ASN_PrintIndented("disconnected" EOL);
            break;
        case e_Icb_WLANConnectionStatus_connected:
            ASN_PrintIndented("connected" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_WLANSecurityType_EnumMap[] = {
        e_Icb_WLANSecurityType_open,          /* Index = 0 */
        e_Icb_WLANSecurityType_wEP_open,      /* Index = 1 */
        e_Icb_WLANSecurityType_wEP_SharedKey, /* Index = 2 */
        e_Icb_WLANSecurityType_wPA_EAP_TLS,   /* Index = 3 */
        e_Icb_WLANSecurityType_wPA_PSK,       /* Index = 4 */
        e_Icb_WLANSecurityType_wPA2_PSK,      /* Index = 5 */
        e_Icb_WLANSecurityType_wPA2_EAP_TLS   /* Index = 6 */
};

ASN_Result Icb_WLANSecurityType_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 6, FALSE));

    if (*val >= 7) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_WLANSecurityType_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANSecurityType_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_WLANSecurityType_EnumMap, 7);

    if (index == 7) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 6, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_WLANSecurityType_Print(Icb_WLANSecurityType value) {
    switch (value) {
        case e_Icb_WLANSecurityType_open:
            ASN_PrintIndented("open" EOL);
            break;
        case e_Icb_WLANSecurityType_wEP_open:
            ASN_PrintIndented("wEP_open" EOL);
            break;
        case e_Icb_WLANSecurityType_wEP_SharedKey:
            ASN_PrintIndented("wEP_SharedKey" EOL);
            break;
        case e_Icb_WLANSecurityType_wPA_EAP_TLS:
            ASN_PrintIndented("wPA_EAP_TLS" EOL);
            break;
        case e_Icb_WLANSecurityType_wPA_PSK:
            ASN_PrintIndented("wPA_PSK" EOL);
            break;
        case e_Icb_WLANSecurityType_wPA2_PSK:
            ASN_PrintIndented("wPA2_PSK" EOL);
            break;
        case e_Icb_WLANSecurityType_wPA2_EAP_TLS:
            ASN_PrintIndented("wPA2_EAP_TLS" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpWLANSTAForgetRememberedNetwk_SetRequest of type ASNSequence
 */

Icb_OpWLANSTAForgetRememberedNetwk_SetRequest Icb_OpWLANSTAForgetRememberedNetwk_SetRequest_Create(
        ASN_Session session) {
    Icb_OpWLANSTAForgetRememberedNetwk_SetRequest value = (Icb_OpWLANSTAForgetRememberedNetwk_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpWLANSTAForgetRememberedNetwk_SetRequest_t));
    if (value != (Icb_OpWLANSTAForgetRememberedNetwk_SetRequest)NULL) {
        value->wLANSSIDToForget = Icb_SSID_Create(session);
    }
    return value;
}

U32 Icb_OpWLANSTAForgetRememberedNetwk_SetRequest_EncodedSize(Icb_OpWLANSTAForgetRememberedNetwk_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SSID_EncodedSize(ThisPtr->wLANSSIDToForget);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANSTAForgetRememberedNetwk_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANSTAForgetRememberedNetwk_SetRequest_t);
    length += Icb_SSID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANSTAForgetRememberedNetwk_SetRequest_Print(Icb_OpWLANSTAForgetRememberedNetwk_SetRequest ThisPtr) {
    ASN_PrintIndented("wLANSSIDToForget" EOL);
    ASN_PrintSetIndent(1);
    Icb_SSID_Print(ThisPtr->wLANSSIDToForget);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANSTAForgetRememberedNetwk_SetRequest_Decode(Icb_OpWLANSTAForgetRememberedNetwk_SetRequest ThisPtr,
                                                                ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->wLANSSIDToForget, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANSTAForgetRememberedNetwk_SetRequest_Encode(Icb_OpWLANSTAForgetRememberedNetwk_SetRequest ThisPtr,
                                                                ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->wLANSSIDToForget, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANSTAForgetRememberedNetwk_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpWLANSTAForgetRememberedNetwk_Response of type ASNSequence
 */

Icb_OpWLANSTAForgetRememberedNetwk_Response Icb_OpWLANSTAForgetRememberedNetwk_Response_Create(ASN_Session session) {
    Icb_OpWLANSTAForgetRememberedNetwk_Response value = (Icb_OpWLANSTAForgetRememberedNetwk_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpWLANSTAForgetRememberedNetwk_Response_t));
    if (value != (Icb_OpWLANSTAForgetRememberedNetwk_Response)NULL) {
        value->wLANSSIDToForgetStatus = Icb_SSID_Create(session);
    }
    return value;
}

U32 Icb_OpWLANSTAForgetRememberedNetwk_Response_EncodedSize(Icb_OpWLANSTAForgetRememberedNetwk_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SSID_EncodedSize(ThisPtr->wLANSSIDToForgetStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANSTAForgetRememberedNetwk_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANSTAForgetRememberedNetwk_Response_t);
    length += Icb_SSID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANSTAForgetRememberedNetwk_Response_Print(Icb_OpWLANSTAForgetRememberedNetwk_Response ThisPtr) {
    ASN_PrintIndented("wLANSSIDToForgetStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_SSID_Print(ThisPtr->wLANSSIDToForgetStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANSTAForgetRememberedNetwk_Response_Decode(Icb_OpWLANSTAForgetRememberedNetwk_Response ThisPtr,
                                                              ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->wLANSSIDToForgetStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANSTAForgetRememberedNetwk_Response_Encode(Icb_OpWLANSTAForgetRememberedNetwk_Response ThisPtr,
                                                              ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->wLANSSIDToForgetStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANSTAForgetRememberedNetwk_Response of type ASNSequence
 */

static const U32 Icb_SimSecuritySetting_EnumMap[] = {
        e_Icb_SimSecuritySetting_on,  /* Index = 0 */
        e_Icb_SimSecuritySetting_off, /* Index = 1 */
        e_Icb_SimSecuritySetting_auto /* Index = 2 */
};

ASN_Result Icb_SimSecuritySetting_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_SimSecuritySetting_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_SimSecuritySetting_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_SimSecuritySetting_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_SimSecuritySetting_Print(Icb_SimSecuritySetting value) {
    switch (value) {
        case e_Icb_SimSecuritySetting_on:
            ASN_PrintIndented("on" EOL);
            break;
        case e_Icb_SimSecuritySetting_off:
            ASN_PrintIndented("off" EOL);
            break;
        case e_Icb_SimSecuritySetting_auto:
            ASN_PrintIndented("auto" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpPSIMSecurity_Response of type ASNSequence
 */

Icb_OpPSIMSecurity_Response Icb_OpPSIMSecurity_Response_Create(ASN_Session session) {
    Icb_OpPSIMSecurity_Response value =
            (Icb_OpPSIMSecurity_Response)ASN_Malloc(session, sizeof(struct Icb_OpPSIMSecurity_Response_t));
    if (value != (Icb_OpPSIMSecurity_Response)NULL) {
        value->setting = 0;
    }
    return value;
}

U32 Icb_OpPSIMSecurity_Response_EncodedSize(Icb_OpPSIMSecurity_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SimSecuritySetting_EncodedSize(ThisPtr->setting);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMSecurity_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMSecurity_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMSecurity_Response_Print(Icb_OpPSIMSecurity_Response ThisPtr) {
    ASN_PrintIndented("setting" EOL);
    ASN_PrintSetIndent(1);
    Icb_SimSecuritySetting_Print(ThisPtr->setting);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMSecurity_Response_Decode(Icb_OpPSIMSecurity_Response ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SimSecuritySetting_Decode(&ThisPtr->setting, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMSecurity_Response_Encode(Icb_OpPSIMSecurity_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SimSecuritySetting_Encode(ThisPtr->setting, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMSecurity_Response of type ASNSequence
 */

/*
 * Start of Icb_PinPukCommand of type ASNChoice
 */

Icb_PinPukCommand Icb_PinPukCommand_Create(ASN_Session session) {
    Icb_PinPukCommand value = (Icb_PinPukCommand)ASN_Malloc(session, sizeof(struct Icb_PinPukCommand_t));
    value->enterPin = (Icb_PinCode)NULL;
    value->enterPuk = (Icb_PinPukCodes)NULL;
    value->changePin = (Icb_PinPinCodes)NULL;
    return value;
}

U32 Icb_PinPukCommand_EncodedSize(Icb_PinPukCommand ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 2);
    switch (ThisPtr->choice) {
        case e_Icb_PinPukCommand_enterPin:
            length += Icb_PinCode_EncodedSize(ThisPtr->enterPin);
            break;
        case e_Icb_PinPukCommand_enterPuk:
            length += Icb_PinPukCodes_EncodedSize(ThisPtr->enterPuk);
            break;
        case e_Icb_PinPukCommand_changePin:
            length += Icb_PinPinCodes_EncodedSize(ThisPtr->changePin);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_PinPukCommand_SessionSize() {
    U32 max = 0;
    U32 length;
    length = Icb_PinCode_SessionSize();
    if (length > max) max = length;

    length = Icb_PinPukCodes_SessionSize();
    if (length > max) max = length;

    length = Icb_PinPinCodes_SessionSize();
    if (length > max) max = length;

    return max + sizeof(struct Icb_PinPukCommand_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_PinPukCommand_Decode(Icb_PinPukCommand ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 2));
    ASN_SETTYPE_CHECK(Icb_PinPukCommand_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_PinPukCommand_enterPin:
            ASN_DECODE_CHECK(Icb_PinCode_Decode(ThisPtr->enterPin, session, stream));
            break;

        case e_Icb_PinPukCommand_enterPuk:
            ASN_DECODE_CHECK(Icb_PinPukCodes_Decode(ThisPtr->enterPuk, session, stream));
            break;

        case e_Icb_PinPukCommand_changePin:
            ASN_DECODE_CHECK(Icb_PinPinCodes_Decode(ThisPtr->changePin, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_PinPukCommand_Encode(Icb_PinPukCommand ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 2));
    switch (ThisPtr->choice) {
        case e_Icb_PinPukCommand_enterPin:
            ASN_ENCODE_CHECK(Icb_PinCode_Encode(ThisPtr->enterPin, stream));
            break;

        case e_Icb_PinPukCommand_enterPuk:
            ASN_ENCODE_CHECK(Icb_PinPukCodes_Encode(ThisPtr->enterPuk, stream));
            break;

        case e_Icb_PinPukCommand_changePin:
            ASN_ENCODE_CHECK(Icb_PinPinCodes_Encode(ThisPtr->changePin, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_PinPukCommand_SetType(Icb_PinPukCommand ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_PinPukCommand_enterPin) {
        ThisPtr->choice = type;
        ThisPtr->enterPin = Icb_PinCode_Create(session);
        ASN_MEM_CHECK(ThisPtr->enterPin);
    } else
        ThisPtr->enterPin = (Icb_PinCode)NULL;

    if (type == e_Icb_PinPukCommand_enterPuk) {
        ThisPtr->choice = type;
        ThisPtr->enterPuk = Icb_PinPukCodes_Create(session);
        ASN_MEM_CHECK(ThisPtr->enterPuk);
    } else
        ThisPtr->enterPuk = (Icb_PinPukCodes)NULL;

    if (type == e_Icb_PinPukCommand_changePin) {
        ThisPtr->choice = type;
        ThisPtr->changePin = Icb_PinPinCodes_Create(session);
        ASN_MEM_CHECK(ThisPtr->changePin);
    } else
        ThisPtr->changePin = (Icb_PinPinCodes)NULL;

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_PinPukCommand_Print(Icb_PinPukCommand ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_PinPukCommand_enterPin:
            ASN_PrintIndented("Icb_PinPukCommand is enterPin" EOL);
            ASN_PrintSetIndent(1);
            Icb_PinCode_Print(ThisPtr->enterPin);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_PinPukCommand_enterPuk:
            ASN_PrintIndented("Icb_PinPukCommand is enterPuk" EOL);
            ASN_PrintSetIndent(1);
            Icb_PinPukCodes_Print(ThisPtr->enterPuk);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_PinPukCommand_changePin:
            ASN_PrintIndented("Icb_PinPukCommand is changePin" EOL);
            ASN_PrintSetIndent(1);
            Icb_PinPinCodes_Print(ThisPtr->changePin);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_PinPukCommand of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_PinPukCodes of type ASNSequence
 */

Icb_PinPukCodes Icb_PinPukCodes_Create(ASN_Session session) {
    Icb_PinPukCodes value = (Icb_PinPukCodes)ASN_Malloc(session, sizeof(struct Icb_PinPukCodes_t));
    if (value != (Icb_PinPukCodes)NULL) {
        value->puk = ASN_OctetString_Create(session);
        value->newpin = Icb_PinCode_Create(session);
    }
    return value;
}

U32 Icb_PinPukCodes_EncodedSize(Icb_PinPukCodes ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_OctetString_EncodedSize(ThisPtr->puk, 8, 8);
    length += Icb_PinCode_EncodedSize(ThisPtr->newpin);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_PinPukCodes_SessionSize() {
    U32 length = sizeof(struct Icb_PinPukCodes_t);
    length += ASN_OctetString_SessionSize(8, 8);
    length += Icb_PinCode_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_PinPukCodes_Print(Icb_PinPukCodes ThisPtr) {
    ASN_PrintIndented("puk" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->puk);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("newpin" EOL);
    ASN_PrintSetIndent(1);
    Icb_PinCode_Print(ThisPtr->newpin);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_PinPukCodes_Decode(Icb_PinPukCodes ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->puk, session, stream, 8, 8));
    ASN_DECODE_CHECK(Icb_PinCode_Decode(ThisPtr->newpin, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_PinPukCodes_Encode(Icb_PinPukCodes ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->puk, stream, 8, 8));
    ASN_ENCODE_CHECK(Icb_PinCode_Encode(ThisPtr->newpin, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_PinPukCodes of type ASNSequence
 */

/*
 * Start of Icb_PinPinCodes of type ASNSequence
 */

Icb_PinPinCodes Icb_PinPinCodes_Create(ASN_Session session) {
    Icb_PinPinCodes value = (Icb_PinPinCodes)ASN_Malloc(session, sizeof(struct Icb_PinPinCodes_t));
    if (value != (Icb_PinPinCodes)NULL) {
        value->oldpin = Icb_PinCode_Create(session);
        value->newpin = Icb_PinCode_Create(session);
    }
    return value;
}

U32 Icb_PinPinCodes_EncodedSize(Icb_PinPinCodes ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_PinCode_EncodedSize(ThisPtr->oldpin);
    length += Icb_PinCode_EncodedSize(ThisPtr->newpin);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_PinPinCodes_SessionSize() {
    U32 length = sizeof(struct Icb_PinPinCodes_t);
    length += Icb_PinCode_SessionSize();
    length += Icb_PinCode_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_PinPinCodes_Print(Icb_PinPinCodes ThisPtr) {
    ASN_PrintIndented("oldpin" EOL);
    ASN_PrintSetIndent(1);
    Icb_PinCode_Print(ThisPtr->oldpin);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("newpin" EOL);
    ASN_PrintSetIndent(1);
    Icb_PinCode_Print(ThisPtr->newpin);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_PinPinCodes_Decode(Icb_PinPinCodes ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_PinCode_Decode(ThisPtr->oldpin, session, stream));
    ASN_DECODE_CHECK(Icb_PinCode_Decode(ThisPtr->newpin, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_PinPinCodes_Encode(Icb_PinPinCodes ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_PinCode_Encode(ThisPtr->oldpin, stream));
    ASN_ENCODE_CHECK(Icb_PinCode_Encode(ThisPtr->newpin, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_PinPinCodes of type ASNSequence
 */

/*
 * Start of Icb_RegisterState of type ASNChoice
 */

Icb_RegisterState Icb_RegisterState_Create(ASN_Session session) {
    Icb_RegisterState value = (Icb_RegisterState)ASN_Malloc(session, sizeof(struct Icb_RegisterState_t));
    value->registered = (Icb_NetworkOperator)NULL;
    value->regRoaming = (Icb_NetworkOperator)NULL;
    return value;
}

U32 Icb_RegisterState_EncodedSize(Icb_RegisterState ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 4);
    switch (ThisPtr->choice) {
        case e_Icb_RegisterState_registered:
            length += Icb_NetworkOperator_EncodedSize(ThisPtr->registered);
            break;
        case e_Icb_RegisterState_regRoaming:
            length += Icb_NetworkOperator_EncodedSize(ThisPtr->regRoaming);
            break;
        case e_Icb_RegisterState_notRegSearching:
            length += ASN_Null_EncodedSize(ThisPtr->notRegSearching);
            break;
        case e_Icb_RegisterState_notRegNotSearching:
            length += ASN_Null_EncodedSize(ThisPtr->notRegNotSearching);
            break;
        case e_Icb_RegisterState_regDenied:
            length += ASN_Null_EncodedSize(ThisPtr->regDenied);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_RegisterState_SessionSize() {
    U32 max = 0;
    U32 length;
    length = Icb_NetworkOperator_SessionSize();
    if (length > max) max = length;

    length = Icb_NetworkOperator_SessionSize();
    if (length > max) max = length;

    return max + sizeof(struct Icb_RegisterState_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_RegisterState_Decode(Icb_RegisterState ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 4));
    ASN_SETTYPE_CHECK(Icb_RegisterState_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_RegisterState_registered:
            ASN_DECODE_CHECK(Icb_NetworkOperator_Decode(ThisPtr->registered, session, stream));
            break;

        case e_Icb_RegisterState_regRoaming:
            ASN_DECODE_CHECK(Icb_NetworkOperator_Decode(ThisPtr->regRoaming, session, stream));
            break;

        case e_Icb_RegisterState_notRegSearching:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->notRegSearching, session, stream));
            break;

        case e_Icb_RegisterState_notRegNotSearching:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->notRegNotSearching, session, stream));
            break;

        case e_Icb_RegisterState_regDenied:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->regDenied, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_RegisterState_Encode(Icb_RegisterState ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 4));
    switch (ThisPtr->choice) {
        case e_Icb_RegisterState_registered:
            ASN_ENCODE_CHECK(Icb_NetworkOperator_Encode(ThisPtr->registered, stream));
            break;

        case e_Icb_RegisterState_regRoaming:
            ASN_ENCODE_CHECK(Icb_NetworkOperator_Encode(ThisPtr->regRoaming, stream));
            break;

        case e_Icb_RegisterState_notRegSearching:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->notRegSearching, stream));
            break;

        case e_Icb_RegisterState_notRegNotSearching:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->notRegNotSearching, stream));
            break;

        case e_Icb_RegisterState_regDenied:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->regDenied, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_RegisterState_SetType(Icb_RegisterState ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_RegisterState_registered) {
        ThisPtr->choice = type;
        ThisPtr->registered = Icb_NetworkOperator_Create(session);
        ASN_MEM_CHECK(ThisPtr->registered);
    } else
        ThisPtr->registered = (Icb_NetworkOperator)NULL;

    if (type == e_Icb_RegisterState_regRoaming) {
        ThisPtr->choice = type;
        ThisPtr->regRoaming = Icb_NetworkOperator_Create(session);
        ASN_MEM_CHECK(ThisPtr->regRoaming);
    } else
        ThisPtr->regRoaming = (Icb_NetworkOperator)NULL;

    if (type == e_Icb_RegisterState_notRegSearching) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_RegisterState_notRegNotSearching) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_RegisterState_regDenied) {
        ThisPtr->choice = type;
    }

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_RegisterState_Print(Icb_RegisterState ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_RegisterState_registered:
            ASN_PrintIndented("Icb_RegisterState is registered" EOL);
            ASN_PrintSetIndent(1);
            Icb_NetworkOperator_Print(ThisPtr->registered);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_RegisterState_regRoaming:
            ASN_PrintIndented("Icb_RegisterState is regRoaming" EOL);
            ASN_PrintSetIndent(1);
            Icb_NetworkOperator_Print(ThisPtr->regRoaming);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_RegisterState_notRegSearching:
            ASN_PrintIndented("Icb_RegisterState is notRegSearching" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->notRegSearching);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_RegisterState_notRegNotSearching:
            ASN_PrintIndented("Icb_RegisterState is notRegNotSearching" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->notRegNotSearching);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_RegisterState_regDenied:
            ASN_PrintIndented("Icb_RegisterState is regDenied" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->regDenied);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_RegisterState of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_NwOperatorId of type ASNSequence
 */

Icb_NwOperatorId Icb_NwOperatorId_Create(ASN_Session session) {
    Icb_NwOperatorId value = (Icb_NwOperatorId)ASN_Malloc(session, sizeof(struct Icb_NwOperatorId_t));
    if (value != (Icb_NwOperatorId)NULL) {
        value->mcc = 0;
        value->mnc = 0;
    }
    return value;
}

U32 Icb_NwOperatorId_EncodedSize(Icb_NwOperatorId ThisPtr) {
    U32 length = 0;
    length += U32_EncodedSize(ThisPtr->mcc, 0, 999);
    length += U32_EncodedSize(ThisPtr->mnc, 0, 999);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_NwOperatorId_SessionSize() {
    U32 length = sizeof(struct Icb_NwOperatorId_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_NwOperatorId_Print(Icb_NwOperatorId ThisPtr) {
    ASN_PrintIndented("mcc" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->mcc);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("mnc" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->mnc);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_NwOperatorId_Decode(Icb_NwOperatorId ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->mcc, session, stream, 0, 999));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->mnc, session, stream, 0, 999));
    return ASN_RESULT_OK;
}

ASN_Result Icb_NwOperatorId_Encode(Icb_NwOperatorId ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->mcc, stream, 0, 999));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->mnc, stream, 0, 999));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_NwOperatorId of type ASNSequence
 */

static const U32 Icb_NetworkType_EnumMap[] = {
        e_Icb_NetworkType_gsm,  /* Index = 0 */
        e_Icb_NetworkType_umts, /* Index = 1 */
        e_Icb_NetworkType_lte   /* Index = 2 */
};

ASN_Result Icb_NetworkType_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_NetworkType_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_NetworkType_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_NetworkType_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_NetworkType_Print(Icb_NetworkType value) {
    switch (value) {
        case e_Icb_NetworkType_gsm:
            ASN_PrintIndented("gsm" EOL);
            break;
        case e_Icb_NetworkType_umts:
            ASN_PrintIndented("umts" EOL);
            break;
        case e_Icb_NetworkType_lte:
            ASN_PrintIndented("lte" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OperatorSelection of type ASNChoice
 */

Icb_OperatorSelection Icb_OperatorSelection_Create(ASN_Session session) {
    Icb_OperatorSelection value = (Icb_OperatorSelection)ASN_Malloc(session, sizeof(struct Icb_OperatorSelection_t));
    value->setOperator = (Icb_NwOperatorId)NULL;
    return value;
}

U32 Icb_OperatorSelection_EncodedSize(Icb_OperatorSelection ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 1);
    switch (ThisPtr->choice) {
        case e_Icb_OperatorSelection_automatic:
            length += ASN_Null_EncodedSize(ThisPtr->automatic);
            break;
        case e_Icb_OperatorSelection_setOperator:
            length += Icb_NwOperatorId_EncodedSize(ThisPtr->setOperator);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OperatorSelection_SessionSize() {
    U32 max = 0;
    U32 length;
    length = Icb_NwOperatorId_SessionSize();
    if (length > max) max = length;

    return max + sizeof(struct Icb_OperatorSelection_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_OperatorSelection_Decode(Icb_OperatorSelection ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 1));
    ASN_SETTYPE_CHECK(Icb_OperatorSelection_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_OperatorSelection_automatic:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->automatic, session, stream));
            break;

        case e_Icb_OperatorSelection_setOperator:
            ASN_DECODE_CHECK(Icb_NwOperatorId_Decode(ThisPtr->setOperator, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OperatorSelection_Encode(Icb_OperatorSelection ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 1));
    switch (ThisPtr->choice) {
        case e_Icb_OperatorSelection_automatic:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->automatic, stream));
            break;

        case e_Icb_OperatorSelection_setOperator:
            ASN_ENCODE_CHECK(Icb_NwOperatorId_Encode(ThisPtr->setOperator, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OperatorSelection_SetType(Icb_OperatorSelection ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_OperatorSelection_automatic) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_OperatorSelection_setOperator) {
        ThisPtr->choice = type;
        ThisPtr->setOperator = Icb_NwOperatorId_Create(session);
        ASN_MEM_CHECK(ThisPtr->setOperator);
    } else
        ThisPtr->setOperator = (Icb_NwOperatorId)NULL;

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_OperatorSelection_Print(Icb_OperatorSelection ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_OperatorSelection_automatic:
            ASN_PrintIndented("Icb_OperatorSelection is automatic" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->automatic);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_OperatorSelection_setOperator:
            ASN_PrintIndented("Icb_OperatorSelection is setOperator" EOL);
            ASN_PrintSetIndent(1);
            Icb_NwOperatorId_Print(ThisPtr->setOperator);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_OperatorSelection of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_SimStatus of type ASNChoice
 */

Icb_SimStatus Icb_SimStatus_Create(ASN_Session session) {
    Icb_SimStatus value = (Icb_SimStatus)ASN_Malloc(session, sizeof(struct Icb_SimStatus_t));
    return value;
}

U32 Icb_SimStatus_EncodedSize(Icb_SimStatus ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 6);
    switch (ThisPtr->choice) {
        case e_Icb_SimStatus_notInUse:
            length += ASN_Null_EncodedSize(ThisPtr->notInUse);
            break;
        case e_Icb_SimStatus_notAvailable:
            length += ASN_Null_EncodedSize(ThisPtr->notAvailable);
            break;
        case e_Icb_SimStatus_pukBlocked:
            length += ASN_Null_EncodedSize(ThisPtr->pukBlocked);
            break;
        case e_Icb_SimStatus_pinBlocked:
            length += Icb_PukTrials_EncodedSize(ThisPtr->pinBlocked);
            break;
        case e_Icb_SimStatus_pinRequired:
            length += Icb_PinTrials_EncodedSize(ThisPtr->pinRequired);
            break;
        case e_Icb_SimStatus_initializing:
            length += ASN_Null_EncodedSize(ThisPtr->initializing);
            break;
        case e_Icb_SimStatus_readyForSettings:
            length += ASN_Null_EncodedSize(ThisPtr->readyForSettings);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_SimStatus_SessionSize() {
    U32 max = 0;
    return max + sizeof(struct Icb_SimStatus_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_SimStatus_Decode(Icb_SimStatus ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 6));
    ASN_SETTYPE_CHECK(Icb_SimStatus_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_SimStatus_notInUse:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->notInUse, session, stream));
            break;

        case e_Icb_SimStatus_notAvailable:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->notAvailable, session, stream));
            break;

        case e_Icb_SimStatus_pukBlocked:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->pukBlocked, session, stream));
            break;

        case e_Icb_SimStatus_pinBlocked:
            ASN_DECODE_CHECK(Icb_PukTrials_Decode(&ThisPtr->pinBlocked, session, stream));
            break;

        case e_Icb_SimStatus_pinRequired:
            ASN_DECODE_CHECK(Icb_PinTrials_Decode(&ThisPtr->pinRequired, session, stream));
            break;

        case e_Icb_SimStatus_initializing:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->initializing, session, stream));
            break;

        case e_Icb_SimStatus_readyForSettings:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->readyForSettings, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_SimStatus_Encode(Icb_SimStatus ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 6));
    switch (ThisPtr->choice) {
        case e_Icb_SimStatus_notInUse:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->notInUse, stream));
            break;

        case e_Icb_SimStatus_notAvailable:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->notAvailable, stream));
            break;

        case e_Icb_SimStatus_pukBlocked:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->pukBlocked, stream));
            break;

        case e_Icb_SimStatus_pinBlocked:
            ASN_ENCODE_CHECK(Icb_PukTrials_Encode(ThisPtr->pinBlocked, stream));
            break;

        case e_Icb_SimStatus_pinRequired:
            ASN_ENCODE_CHECK(Icb_PinTrials_Encode(ThisPtr->pinRequired, stream));
            break;

        case e_Icb_SimStatus_initializing:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->initializing, stream));
            break;

        case e_Icb_SimStatus_readyForSettings:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->readyForSettings, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_SimStatus_SetType(Icb_SimStatus ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_SimStatus_notInUse) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_SimStatus_notAvailable) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_SimStatus_pukBlocked) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_SimStatus_pinBlocked) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_SimStatus_pinRequired) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_SimStatus_initializing) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_SimStatus_readyForSettings) {
        ThisPtr->choice = type;
    }

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_SimStatus_Print(Icb_SimStatus ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_SimStatus_notInUse:
            ASN_PrintIndented("Icb_SimStatus is notInUse" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->notInUse);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_SimStatus_notAvailable:
            ASN_PrintIndented("Icb_SimStatus is notAvailable" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->notAvailable);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_SimStatus_pukBlocked:
            ASN_PrintIndented("Icb_SimStatus is pukBlocked" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->pukBlocked);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_SimStatus_pinBlocked:
            ASN_PrintIndented("Icb_SimStatus is pinBlocked" EOL);
            ASN_PrintSetIndent(1);
            Icb_PukTrials_Print(ThisPtr->pinBlocked);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_SimStatus_pinRequired:
            ASN_PrintIndented("Icb_SimStatus is pinRequired" EOL);
            ASN_PrintSetIndent(1);
            Icb_PinTrials_Print(ThisPtr->pinRequired);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_SimStatus_initializing:
            ASN_PrintIndented("Icb_SimStatus is initializing" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->initializing);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_SimStatus_readyForSettings:
            ASN_PrintIndented("Icb_SimStatus is readyForSettings" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->readyForSettings);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_SimStatus of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

static const U32 Icb_PinTrials_EnumMap[] = {
        e_Icb_PinTrials_unknown,       /* Index = 0 */
        e_Icb_PinTrials_oneRemaining,  /* Index = 1 */
        e_Icb_PinTrials_twoRemaining,  /* Index = 2 */
        e_Icb_PinTrials_threeRemaining /* Index = 3 */
};

ASN_Result Icb_PinTrials_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_PinTrials_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_PinTrials_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_PinTrials_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_PinTrials_Print(Icb_PinTrials value) {
    switch (value) {
        case e_Icb_PinTrials_unknown:
            ASN_PrintIndented("unknown" EOL);
            break;
        case e_Icb_PinTrials_oneRemaining:
            ASN_PrintIndented("oneRemaining" EOL);
            break;
        case e_Icb_PinTrials_twoRemaining:
            ASN_PrintIndented("twoRemaining" EOL);
            break;
        case e_Icb_PinTrials_threeRemaining:
            ASN_PrintIndented("threeRemaining" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_PukTrials_EnumMap[] = {
        e_Icb_PukTrials_unknown,        /* Index = 0 */
        e_Icb_PukTrials_oneRemaining,   /* Index = 1 */
        e_Icb_PukTrials_twoRemaining,   /* Index = 2 */
        e_Icb_PukTrials_threeRemaining, /* Index = 3 */
        e_Icb_PukTrials_fourRemaining,  /* Index = 4 */
        e_Icb_PukTrials_fiveRemaining,  /* Index = 5 */
        e_Icb_PukTrials_sixRemaining,   /* Index = 6 */
        e_Icb_PukTrials_sevenRemaining, /* Index = 7 */
        e_Icb_PukTrials_eightRemaining, /* Index = 8 */
        e_Icb_PukTrials_nineRemaining,  /* Index = 9 */
        e_Icb_PukTrials_tenRemaining    /* Index = 10 */
};

ASN_Result Icb_PukTrials_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 10, FALSE));

    if (*val >= 11) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_PukTrials_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_PukTrials_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_PukTrials_EnumMap, 11);

    if (index == 11) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 10, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_PukTrials_Print(Icb_PukTrials value) {
    switch (value) {
        case e_Icb_PukTrials_unknown:
            ASN_PrintIndented("unknown" EOL);
            break;
        case e_Icb_PukTrials_oneRemaining:
            ASN_PrintIndented("oneRemaining" EOL);
            break;
        case e_Icb_PukTrials_twoRemaining:
            ASN_PrintIndented("twoRemaining" EOL);
            break;
        case e_Icb_PukTrials_threeRemaining:
            ASN_PrintIndented("threeRemaining" EOL);
            break;
        case e_Icb_PukTrials_fourRemaining:
            ASN_PrintIndented("fourRemaining" EOL);
            break;
        case e_Icb_PukTrials_fiveRemaining:
            ASN_PrintIndented("fiveRemaining" EOL);
            break;
        case e_Icb_PukTrials_sixRemaining:
            ASN_PrintIndented("sixRemaining" EOL);
            break;
        case e_Icb_PukTrials_sevenRemaining:
            ASN_PrintIndented("sevenRemaining" EOL);
            break;
        case e_Icb_PukTrials_eightRemaining:
            ASN_PrintIndented("eightRemaining" EOL);
            break;
        case e_Icb_PukTrials_nineRemaining:
            ASN_PrintIndented("nineRemaining" EOL);
            break;
        case e_Icb_PukTrials_tenRemaining:
            ASN_PrintIndented("tenRemaining" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_PhoneOperationMode_EnumMap[] = {
        e_Icb_PhoneOperationMode_phoneOff,           /* Index = 0 */
        e_Icb_PhoneOperationMode_phoneStartup,       /* Index = 1 */
        e_Icb_PhoneOperationMode_phoneEnabled,       /* Index = 2 */
        e_Icb_PhoneOperationMode_temStandby,         /* Index = 3 */
        e_Icb_PhoneOperationMode_temClosed,          /* Index = 4 */
        e_Icb_PhoneOperationMode_temOpen,            /* Index = 5 */
        e_Icb_PhoneOperationMode_probation,          /* Index = 6 */
        e_Icb_PhoneOperationMode_probationRestricted /* Index = 7 */
};

ASN_Result Icb_PhoneOperationMode_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 7, FALSE));

    if (*val >= 8) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_PhoneOperationMode_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_PhoneOperationMode_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_PhoneOperationMode_EnumMap, 8);

    if (index == 8) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 7, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_PhoneOperationMode_Print(Icb_PhoneOperationMode value) {
    switch (value) {
        case e_Icb_PhoneOperationMode_phoneOff:
            ASN_PrintIndented("phoneOff" EOL);
            break;
        case e_Icb_PhoneOperationMode_phoneStartup:
            ASN_PrintIndented("phoneStartup" EOL);
            break;
        case e_Icb_PhoneOperationMode_phoneEnabled:
            ASN_PrintIndented("phoneEnabled" EOL);
            break;
        case e_Icb_PhoneOperationMode_temStandby:
            ASN_PrintIndented("temStandby" EOL);
            break;
        case e_Icb_PhoneOperationMode_temClosed:
            ASN_PrintIndented("temClosed" EOL);
            break;
        case e_Icb_PhoneOperationMode_temOpen:
            ASN_PrintIndented("temOpen" EOL);
            break;
        case e_Icb_PhoneOperationMode_probation:
            ASN_PrintIndented("probation" EOL);
            break;
        case e_Icb_PhoneOperationMode_probationRestricted:
            ASN_PrintIndented("probationRestricted" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpPSIMSignalStrength_Notification of type ASNSequence
 */

Icb_OpPSIMSignalStrength_Notification Icb_OpPSIMSignalStrength_Notification_Create(ASN_Session session) {
    Icb_OpPSIMSignalStrength_Notification value = (Icb_OpPSIMSignalStrength_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMSignalStrength_Notification_t));
    if (value != (Icb_OpPSIMSignalStrength_Notification)NULL) {
        value->rssi = 0;
    }
    return value;
}

U32 Icb_OpPSIMSignalStrength_Notification_EncodedSize(Icb_OpPSIMSignalStrength_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->rssi, 0, 31);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMSignalStrength_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMSignalStrength_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMSignalStrength_Notification_Print(Icb_OpPSIMSignalStrength_Notification ThisPtr) {
    ASN_PrintIndented("rssi" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->rssi);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMSignalStrength_Notification_Decode(Icb_OpPSIMSignalStrength_Notification ThisPtr,
                                                        ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->rssi, session, stream, 0, 31));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMSignalStrength_Notification_Encode(Icb_OpPSIMSignalStrength_Notification ThisPtr,
                                                        ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->rssi, stream, 0, 31));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMSignalStrength_Notification of type ASNSequence
 */

/*
 * Start of Icb_UssdReturnCode of type ASNSequence
 */

Icb_UssdReturnCode Icb_UssdReturnCode_Create(ASN_Session session) {
    Icb_UssdReturnCode value = (Icb_UssdReturnCode)ASN_Malloc(session, sizeof(struct Icb_UssdReturnCode_t));
    if (value != (Icb_UssdReturnCode)NULL) {
        value->ussdReturnCode = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_UssdReturnCode_EncodedSize(Icb_UssdReturnCode ThisPtr) {
    U32 length = 0;
    length += ASN_UTF8String_EncodedSize(ThisPtr->ussdReturnCode, 0, 300);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_UssdReturnCode_SessionSize() {
    U32 length = sizeof(struct Icb_UssdReturnCode_t);
    length += ASN_UTF8String_SessionSize(0, 300);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_UssdReturnCode_Print(Icb_UssdReturnCode ThisPtr) {
    ASN_PrintIndented("ussdReturnCode" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->ussdReturnCode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_UssdReturnCode_Decode(Icb_UssdReturnCode ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->ussdReturnCode, session, stream, 0, 300));
    return ASN_RESULT_OK;
}

ASN_Result Icb_UssdReturnCode_Encode(Icb_UssdReturnCode ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->ussdReturnCode, stream, 0, 300));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_UssdReturnCode of type ASNSequence
 */

static const U32 Icb_UssdStatus_EnumMap[] = {
        e_Icb_UssdStatus_successful, /* Index = 0 */
        e_Icb_UssdStatus_rejected,   /* Index = 1 */
        e_Icb_UssdStatus_timeout,    /* Index = 2 */
        e_Icb_UssdStatus_netInit     /* Index = 3 */
};

ASN_Result Icb_UssdStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_UssdStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_UssdStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_UssdStatus_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_UssdStatus_Print(Icb_UssdStatus value) {
    switch (value) {
        case e_Icb_UssdStatus_successful:
            ASN_PrintIndented("successful" EOL);
            break;
        case e_Icb_UssdStatus_rejected:
            ASN_PrintIndented("rejected" EOL);
            break;
        case e_Icb_UssdStatus_timeout:
            ASN_PrintIndented("timeout" EOL);
            break;
        case e_Icb_UssdStatus_netInit:
            ASN_PrintIndented("netInit" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpPremiumAudio_SetRequest of type ASNSequence
 */

Icb_OpPremiumAudio_SetRequest Icb_OpPremiumAudio_SetRequest_Create(ASN_Session session) {
    Icb_OpPremiumAudio_SetRequest value =
            (Icb_OpPremiumAudio_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpPremiumAudio_SetRequest_t));
    if (value != (Icb_OpPremiumAudio_SetRequest)NULL) {
        value->isRequested = 0;
    }
    return value;
}

U32 Icb_OpPremiumAudio_SetRequest_EncodedSize(Icb_OpPremiumAudio_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->isRequested);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPremiumAudio_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPremiumAudio_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPremiumAudio_SetRequest_Print(Icb_OpPremiumAudio_SetRequest ThisPtr) {
    ASN_PrintIndented("isRequested" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->isRequested);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPremiumAudio_SetRequest_Decode(Icb_OpPremiumAudio_SetRequest ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->isRequested, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPremiumAudio_SetRequest_Encode(Icb_OpPremiumAudio_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->isRequested, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPremiumAudio_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPremiumAudio_Response of type ASNSequence
 */

Icb_OpPremiumAudio_Response Icb_OpPremiumAudio_Response_Create(ASN_Session session) {
    Icb_OpPremiumAudio_Response value =
            (Icb_OpPremiumAudio_Response)ASN_Malloc(session, sizeof(struct Icb_OpPremiumAudio_Response_t));
    if (value != (Icb_OpPremiumAudio_Response)NULL) {
        value->premiumAudioStatus = Icb_AudioStatus_Create(session);
    }
    return value;
}

U32 Icb_OpPremiumAudio_Response_EncodedSize(Icb_OpPremiumAudio_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_AudioStatus_EncodedSize(ThisPtr->premiumAudioStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPremiumAudio_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPremiumAudio_Response_t);
    length += Icb_AudioStatus_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPremiumAudio_Response_Print(Icb_OpPremiumAudio_Response ThisPtr) {
    ASN_PrintIndented("premiumAudioStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_AudioStatus_Print(ThisPtr->premiumAudioStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPremiumAudio_Response_Decode(Icb_OpPremiumAudio_Response ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_AudioStatus_Decode(ThisPtr->premiumAudioStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPremiumAudio_Response_Encode(Icb_OpPremiumAudio_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_AudioStatus_Encode(ThisPtr->premiumAudioStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPremiumAudio_Response of type ASNSequence
 */

static const U32 Icb_AssistCallAction_EnumMap[] = {
        e_Icb_AssistCallAction_acceptCall, /* Index = 0 */
        e_Icb_AssistCallAction_hangupCall  /* Index = 1 */
};

ASN_Result Icb_AssistCallAction_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_AssistCallAction_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_AssistCallAction_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_AssistCallAction_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_AssistCallAction_Print(Icb_AssistCallAction value) {
    switch (value) {
        case e_Icb_AssistCallAction_acceptCall:
            ASN_PrintIndented("acceptCall" EOL);
            break;
        case e_Icb_AssistCallAction_hangupCall:
            ASN_PrintIndented("hangupCall" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_RadioMode_EnumMap[] = {
        e_Icb_RadioMode_telematic, /* Index = 0 */
        e_Icb_RadioMode_personal,  /* Index = 1 */
        e_Icb_RadioMode_silentTSIM /* Index = 2 */
};

ASN_Result Icb_RadioMode_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_RadioMode_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_RadioMode_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_RadioMode_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_RadioMode_Print(Icb_RadioMode value) {
    switch (value) {
        case e_Icb_RadioMode_telematic:
            ASN_PrintIndented("telematic" EOL);
            break;
        case e_Icb_RadioMode_personal:
            ASN_PrintIndented("personal" EOL);
            break;
        case e_Icb_RadioMode_silentTSIM:
            ASN_PrintIndented("silentTSIM" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpDLCConnectedSignal_Response of type ASNSequence
 */

Icb_OpDLCConnectedSignal_Response Icb_OpDLCConnectedSignal_Response_Create(ASN_Session session) {
    Icb_OpDLCConnectedSignal_Response value =
            (Icb_OpDLCConnectedSignal_Response)ASN_Malloc(session, sizeof(struct Icb_OpDLCConnectedSignal_Response_t));
    if (value != (Icb_OpDLCConnectedSignal_Response)NULL) {
        value->dlcConnected = 0;
    }
    return value;
}

U32 Icb_OpDLCConnectedSignal_Response_EncodedSize(Icb_OpDLCConnectedSignal_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->dlcConnected);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpDLCConnectedSignal_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpDLCConnectedSignal_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpDLCConnectedSignal_Response_Print(Icb_OpDLCConnectedSignal_Response ThisPtr) {
    ASN_PrintIndented("dlcConnected" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->dlcConnected);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpDLCConnectedSignal_Response_Decode(Icb_OpDLCConnectedSignal_Response ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->dlcConnected, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpDLCConnectedSignal_Response_Encode(Icb_OpDLCConnectedSignal_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->dlcConnected, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpDLCConnectedSignal_Response of type ASNSequence
 */

/*
 * Start of Icb_DRVehiclePosition of type ASNChoice
 */

Icb_DRVehiclePosition Icb_DRVehiclePosition_Create(ASN_Session session) {
    Icb_DRVehiclePosition value = (Icb_DRVehiclePosition)ASN_Malloc(session, sizeof(struct Icb_DRVehiclePosition_t));
    value->drPosition = (Icb_DRPositionData)NULL;
    return value;
}

U32 Icb_DRVehiclePosition_EncodedSize(Icb_DRVehiclePosition ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 1);
    switch (ThisPtr->choice) {
        case e_Icb_DRVehiclePosition_noValidData:
            length += ASN_Null_EncodedSize(ThisPtr->noValidData);
            break;
        case e_Icb_DRVehiclePosition_drPosition:
            length += Icb_DRPositionData_EncodedSize(ThisPtr->drPosition);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_DRVehiclePosition_SessionSize() {
    U32 max = 0;
    U32 length;
    length = Icb_DRPositionData_SessionSize();
    if (length > max) max = length;

    return max + sizeof(struct Icb_DRVehiclePosition_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_DRVehiclePosition_Decode(Icb_DRVehiclePosition ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 1));
    ASN_SETTYPE_CHECK(Icb_DRVehiclePosition_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_DRVehiclePosition_noValidData:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->noValidData, session, stream));
            break;

        case e_Icb_DRVehiclePosition_drPosition:
            ASN_DECODE_CHECK(Icb_DRPositionData_Decode(ThisPtr->drPosition, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_DRVehiclePosition_Encode(Icb_DRVehiclePosition ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 1));
    switch (ThisPtr->choice) {
        case e_Icb_DRVehiclePosition_noValidData:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->noValidData, stream));
            break;

        case e_Icb_DRVehiclePosition_drPosition:
            ASN_ENCODE_CHECK(Icb_DRPositionData_Encode(ThisPtr->drPosition, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_DRVehiclePosition_SetType(Icb_DRVehiclePosition ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_DRVehiclePosition_noValidData) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_DRVehiclePosition_drPosition) {
        ThisPtr->choice = type;
        ThisPtr->drPosition = Icb_DRPositionData_Create(session);
        ASN_MEM_CHECK(ThisPtr->drPosition);
    } else
        ThisPtr->drPosition = (Icb_DRPositionData)NULL;

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_DRVehiclePosition_Print(Icb_DRVehiclePosition ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_DRVehiclePosition_noValidData:
            ASN_PrintIndented("Icb_DRVehiclePosition is noValidData" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->noValidData);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_DRVehiclePosition_drPosition:
            ASN_PrintIndented("Icb_DRVehiclePosition is drPosition" EOL);
            ASN_PrintSetIndent(1);
            Icb_DRPositionData_Print(ThisPtr->drPosition);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_DRVehiclePosition of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

static const U32 Icb_GnssFixType_EnumMap[] = {
        e_Icb_GnssFixType_notAvailable, /* Index = 0 */
        e_Icb_GnssFixType_noFix,        /* Index = 1 */
        e_Icb_GnssFixType_fix2D,        /* Index = 2 */
        e_Icb_GnssFixType_fix3D,        /* Index = 3 */
        e_Icb_GnssFixType_startupMode   /* Index = 4 */
};

ASN_Result Icb_GnssFixType_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 4, FALSE));

    if (*val >= 5) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_GnssFixType_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_GnssFixType_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_GnssFixType_EnumMap, 5);

    if (index == 5) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 4, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_GnssFixType_Print(Icb_GnssFixType value) {
    switch (value) {
        case e_Icb_GnssFixType_notAvailable:
            ASN_PrintIndented("notAvailable" EOL);
            break;
        case e_Icb_GnssFixType_noFix:
            ASN_PrintIndented("noFix" EOL);
            break;
        case e_Icb_GnssFixType_fix2D:
            ASN_PrintIndented("fix2D" EOL);
            break;
        case e_Icb_GnssFixType_fix3D:
            ASN_PrintIndented("fix3D" EOL);
            break;
        case e_Icb_GnssFixType_startupMode:
            ASN_PrintIndented("startupMode" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_DeadReckoningType_EnumMap[] = {
        e_Icb_DeadReckoningType_noDr,         /* Index = 0 */
        e_Icb_DeadReckoningType_drNoMapMatch, /* Index = 1 */
        e_Icb_DeadReckoningType_drMapMatched  /* Index = 2 */
};

ASN_Result Icb_DeadReckoningType_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_DeadReckoningType_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_DeadReckoningType_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_DeadReckoningType_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_DeadReckoningType_Print(Icb_DeadReckoningType value) {
    switch (value) {
        case e_Icb_DeadReckoningType_noDr:
            ASN_PrintIndented("noDr" EOL);
            break;
        case e_Icb_DeadReckoningType_drNoMapMatch:
            ASN_PrintIndented("drNoMapMatch" EOL);
            break;
        case e_Icb_DeadReckoningType_drMapMatched:
            ASN_PrintIndented("drMapMatched" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_GPSSystemTime of type ASNSequence
 */

Icb_GPSSystemTime Icb_GPSSystemTime_Create(ASN_Session session) {
    Icb_GPSSystemTime value = (Icb_GPSSystemTime)ASN_Malloc(session, sizeof(struct Icb_GPSSystemTime_t));
    if (value != (Icb_GPSSystemTime)NULL) {
        value->weekNumber = 0;
        value->timeOfWeek = 0;
    }
    return value;
}

U32 Icb_GPSSystemTime_EncodedSize(Icb_GPSSystemTime ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->weekNumber, 0, 1023);
    length += U32_EncodedSize(ThisPtr->timeOfWeek, 0, 604799999);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_GPSSystemTime_SessionSize() {
    U32 length = sizeof(struct Icb_GPSSystemTime_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_GPSSystemTime_Print(Icb_GPSSystemTime ThisPtr) {
    ASN_PrintIndented("weekNumber" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->weekNumber);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("timeOfWeek" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->timeOfWeek);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_GPSSystemTime_Decode(Icb_GPSSystemTime ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->weekNumber, session, stream, 0, 1023));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->timeOfWeek, session, stream, 0, 604799999));
    return ASN_RESULT_OK;
}

ASN_Result Icb_GPSSystemTime_Encode(Icb_GPSSystemTime ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->weekNumber, stream, 0, 1023));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->timeOfWeek, stream, 0, 604799999));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_GPSSystemTime of type ASNSequence
 */

/*
 * Start of Icb_CoordinatesLongLat of type ASNSequence
 */

Icb_CoordinatesLongLat Icb_CoordinatesLongLat_Create(ASN_Session session) {
    Icb_CoordinatesLongLat value = (Icb_CoordinatesLongLat)ASN_Malloc(session, sizeof(struct Icb_CoordinatesLongLat_t));
    if (value != (Icb_CoordinatesLongLat)NULL) {
        value->longitude = 0;
        value->latitude = 0;
    }
    return value;
}

U32 Icb_CoordinatesLongLat_EncodedSize(Icb_CoordinatesLongLat ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += S32_EncodedSize(ThisPtr->longitude, INT32_MIN, INT32_MAX);
    length += S32_EncodedSize(ThisPtr->latitude, -1073741824, 1073741824);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_CoordinatesLongLat_SessionSize() {
    U32 length = sizeof(struct Icb_CoordinatesLongLat_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_CoordinatesLongLat_Print(Icb_CoordinatesLongLat ThisPtr) {
    ASN_PrintIndented("longitude" EOL);
    ASN_PrintSetIndent(1);
    S32_Print(ThisPtr->longitude);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("latitude" EOL);
    ASN_PrintSetIndent(1);
    S32_Print(ThisPtr->latitude);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_CoordinatesLongLat_Decode(Icb_CoordinatesLongLat ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(S32_Decode(&ThisPtr->longitude, session, stream, INT32_MIN, INT32_MAX));
    ASN_DECODE_CHECK(S32_Decode(&ThisPtr->latitude, session, stream, -1073741824, 1073741824));
    return ASN_RESULT_OK;
}

ASN_Result Icb_CoordinatesLongLat_Encode(Icb_CoordinatesLongLat ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(S32_Encode(ThisPtr->longitude, stream, INT32_MIN, INT32_MAX));
    ASN_ENCODE_CHECK(S32_Encode(ThisPtr->latitude, stream, -1073741824, 1073741824));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_CoordinatesLongLat of type ASNSequence
 */

/*
 * Start of Icb_Velocity of type ASNSequence
 */

Icb_Velocity Icb_Velocity_Create(ASN_Session session) {
    Icb_Velocity value = (Icb_Velocity)ASN_Malloc(session, sizeof(struct Icb_Velocity_t));
    if (value != (Icb_Velocity)NULL) {
        value->speed = 0;
        value->horizontalVelocity = 0;
        value->verticalVelocity = 0;
    }
    return value;
}

U32 Icb_Velocity_EncodedSize(Icb_Velocity ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->speed, 0, 100000);
    length += U32_EncodedSize(ThisPtr->horizontalVelocity, 0, 100000);
    length += S32_EncodedSize(ThisPtr->verticalVelocity, -100000, 100000);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_Velocity_SessionSize() {
    U32 length = sizeof(struct Icb_Velocity_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_Velocity_Print(Icb_Velocity ThisPtr) {
    ASN_PrintIndented("speed" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->speed);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("horizontalVelocity" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->horizontalVelocity);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("verticalVelocity" EOL);
    ASN_PrintSetIndent(1);
    S32_Print(ThisPtr->verticalVelocity);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_Velocity_Decode(Icb_Velocity ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->speed, session, stream, 0, 100000));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->horizontalVelocity, session, stream, 0, 100000));
    ASN_DECODE_CHECK(S32_Decode(&ThisPtr->verticalVelocity, session, stream, -100000, 100000));
    return ASN_RESULT_OK;
}

ASN_Result Icb_Velocity_Encode(Icb_Velocity ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->speed, stream, 0, 100000));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->horizontalVelocity, stream, 0, 100000));
    ASN_ENCODE_CHECK(S32_Encode(ThisPtr->verticalVelocity, stream, -100000, 100000));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_Velocity of type ASNSequence
 */

/*
 * Start of Icb_GNSSUsage of type ASNSequence
 */

Icb_GNSSUsage Icb_GNSSUsage_Create(ASN_Session session) {
    Icb_GNSSUsage value = (Icb_GNSSUsage)ASN_Malloc(session, sizeof(struct Icb_GNSSUsage_t));
    if (value != (Icb_GNSSUsage)NULL) {
        value->gpsIsUsed = 0;
        value->glonassIsUsed = 0;
        value->galileoIsUsed = 0;
        value->sbasIsUsed = 0;
        value->qzssL1IsUsed = 0;
        value->qzssL1SAIFIsUsed = 0;
    }
    return value;
}

U32 Icb_GNSSUsage_EncodedSize(Icb_GNSSUsage ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->gpsIsUsed);
    length += BOOL_EncodedSize(ThisPtr->glonassIsUsed);
    length += BOOL_EncodedSize(ThisPtr->galileoIsUsed);
    length += BOOL_EncodedSize(ThisPtr->sbasIsUsed);
    length += BOOL_EncodedSize(ThisPtr->qzssL1IsUsed);
    length += BOOL_EncodedSize(ThisPtr->qzssL1SAIFIsUsed);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_GNSSUsage_SessionSize() {
    U32 length = sizeof(struct Icb_GNSSUsage_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_GNSSUsage_Print(Icb_GNSSUsage ThisPtr) {
    ASN_PrintIndented("gpsIsUsed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->gpsIsUsed);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("glonassIsUsed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->glonassIsUsed);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("galileoIsUsed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->galileoIsUsed);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sbasIsUsed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->sbasIsUsed);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("qzssL1IsUsed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->qzssL1IsUsed);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("qzssL1SAIFIsUsed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->qzssL1SAIFIsUsed);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_GNSSUsage_Decode(Icb_GNSSUsage ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->gpsIsUsed, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->glonassIsUsed, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->galileoIsUsed, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->sbasIsUsed, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->qzssL1IsUsed, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->qzssL1SAIFIsUsed, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_GNSSUsage_Encode(Icb_GNSSUsage ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->gpsIsUsed, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->glonassIsUsed, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->galileoIsUsed, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->sbasIsUsed, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->qzssL1IsUsed, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->qzssL1SAIFIsUsed, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_GNSSUsage of type ASNSequence
 */

/*
 * Start of Icb_GNSSStatus of type ASNSequence
 */

Icb_GNSSStatus Icb_GNSSStatus_Create(ASN_Session session) {
    Icb_GNSSStatus value = (Icb_GNSSStatus)ASN_Malloc(session, sizeof(struct Icb_GNSSStatus_t));
    if (value != (Icb_GNSSStatus)NULL) {
        value->fixType = 0;
        value->dgpsIsUsed = 0;
        value->selfEphemerisDataUsage = 0;
    }
    return value;
}

U32 Icb_GNSSStatus_EncodedSize(Icb_GNSSStatus ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_GnssFixType_EncodedSize(ThisPtr->fixType);
    length += BOOL_EncodedSize(ThisPtr->dgpsIsUsed);
    length += BOOL_EncodedSize(ThisPtr->selfEphemerisDataUsage);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_GNSSStatus_SessionSize() {
    U32 length = sizeof(struct Icb_GNSSStatus_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_GNSSStatus_Print(Icb_GNSSStatus ThisPtr) {
    ASN_PrintIndented("fixType" EOL);
    ASN_PrintSetIndent(1);
    Icb_GnssFixType_Print(ThisPtr->fixType);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("dgpsIsUsed" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->dgpsIsUsed);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("selfEphemerisDataUsage" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->selfEphemerisDataUsage);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_GNSSStatus_Decode(Icb_GNSSStatus ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_GnssFixType_Decode(&ThisPtr->fixType, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->dgpsIsUsed, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->selfEphemerisDataUsage, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_GNSSStatus_Encode(Icb_GNSSStatus ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_GnssFixType_Encode(ThisPtr->fixType, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->dgpsIsUsed, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->selfEphemerisDataUsage, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_GNSSStatus of type ASNSequence
 */

/*
 * Start of Icb_NrOfSatellitesPerSystem of type ASNSequence
 */

Icb_NrOfSatellitesPerSystem Icb_NrOfSatellitesPerSystem_Create(ASN_Session session) {
    Icb_NrOfSatellitesPerSystem value =
            (Icb_NrOfSatellitesPerSystem)ASN_Malloc(session, sizeof(struct Icb_NrOfSatellitesPerSystem_t));
    if (value != (Icb_NrOfSatellitesPerSystem)NULL) {
        value->gps = 0;
        value->glonass = 0;
        value->galileo = 0;
        value->sbas = 0;
        value->qzssL1 = 0;
        value->qzssL1SAIF = 0;
    }
    return value;
}

U32 Icb_NrOfSatellitesPerSystem_EncodedSize(Icb_NrOfSatellitesPerSystem ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->gps, 0, 31);
    length += U32_EncodedSize(ThisPtr->glonass, 0, 31);
    length += U32_EncodedSize(ThisPtr->galileo, 0, 31);
    length += U32_EncodedSize(ThisPtr->sbas, 0, 31);
    length += U32_EncodedSize(ThisPtr->qzssL1, 0, 31);
    length += U32_EncodedSize(ThisPtr->qzssL1SAIF, 0, 31);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_NrOfSatellitesPerSystem_SessionSize() {
    U32 length = sizeof(struct Icb_NrOfSatellitesPerSystem_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_NrOfSatellitesPerSystem_Print(Icb_NrOfSatellitesPerSystem ThisPtr) {
    ASN_PrintIndented("gps" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->gps);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("glonass" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->glonass);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("galileo" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->galileo);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sbas" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->sbas);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("qzssL1" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->qzssL1);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("qzssL1SAIF" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->qzssL1SAIF);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_NrOfSatellitesPerSystem_Decode(Icb_NrOfSatellitesPerSystem ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->gps, session, stream, 0, 31));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->glonass, session, stream, 0, 31));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->galileo, session, stream, 0, 31));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->sbas, session, stream, 0, 31));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->qzssL1, session, stream, 0, 31));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->qzssL1SAIF, session, stream, 0, 31));
    return ASN_RESULT_OK;
}

ASN_Result Icb_NrOfSatellitesPerSystem_Encode(Icb_NrOfSatellitesPerSystem ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->gps, stream, 0, 31));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->glonass, stream, 0, 31));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->galileo, stream, 0, 31));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->sbas, stream, 0, 31));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->qzssL1, stream, 0, 31));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->qzssL1SAIF, stream, 0, 31));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_NrOfSatellitesPerSystem of type ASNSequence
 */

/*
 * Start of Icb_DOPValues of type ASNSequence
 */

Icb_DOPValues Icb_DOPValues_Create(ASN_Session session) {
    Icb_DOPValues value = (Icb_DOPValues)ASN_Malloc(session, sizeof(struct Icb_DOPValues_t));
    if (value != (Icb_DOPValues)NULL) {
        value->hdop = 0;
        value->vdop = 0;
        value->pdop = 0;
        value->tdop = 0;
    }
    return value;
}

U32 Icb_DOPValues_EncodedSize(Icb_DOPValues ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->hdop, 0, 255);
    length += U32_EncodedSize(ThisPtr->vdop, 0, 255);
    length += U32_EncodedSize(ThisPtr->pdop, 0, 255);
    length += U32_EncodedSize(ThisPtr->tdop, 0, 255);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_DOPValues_SessionSize() {
    U32 length = sizeof(struct Icb_DOPValues_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_DOPValues_Print(Icb_DOPValues ThisPtr) {
    ASN_PrintIndented("hdop" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->hdop);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("vdop" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->vdop);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("pdop" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->pdop);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("tdop" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->tdop);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_DOPValues_Decode(Icb_DOPValues ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->hdop, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->vdop, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->pdop, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->tdop, session, stream, 0, 255));
    return ASN_RESULT_OK;
}

ASN_Result Icb_DOPValues_Encode(Icb_DOPValues ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->hdop, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->vdop, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->pdop, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->tdop, stream, 0, 255));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_DOPValues of type ASNSequence
 */

#define ASN_INTERNAL_SIZE_Icb_ReceiverChannelData(max, min) \
    {                                                       \
        value->min_size = min;                              \
        value->max_size = max;                              \
    }
/*
 * Start of Icb_ReceiverChannelData of type ASNArray
 */

Icb_ReceiverChannelData Icb_ReceiverChannelData_Create(ASN_Session session) {
    Icb_ReceiverChannelData value =
            (Icb_ReceiverChannelData)ASN_Malloc(session, sizeof(struct Icb_ReceiverChannelData_t));

    if (value != (Icb_ReceiverChannelData)NULL) {
        ASN_INTERNAL_SIZE_Icb_ReceiverChannelData(0, 127);
        value->actual_size = 0;
        value->data_array = (Icb_ChannelData *)NULL;
    }
    return value;
}

U32 Icb_ReceiverChannelData_EncodedSize(Icb_ReceiverChannelData ThisPtr) {
    U32 i;
    U32 length = ASN_U32CountBits(0, 127);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_ChannelData_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ReceiverChannelData_SessionSize() {
    return sizeof(struct Icb_ReceiverChannelData_t) +
           ASN_MAX(0, 127) * (sizeof(Icb_ChannelData) + Icb_ChannelData_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ReceiverChannelData_Encode(Icb_ReceiverChannelData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, 0, 127));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_ChannelData_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ReceiverChannelData_SetSize(Icb_ReceiverChannelData ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_ChannelData *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_ChannelData *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_ChannelData_Create(session);
        if (ThisPtr->data_array[i] == (Icb_ChannelData)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ReceiverChannelData_Decode(Icb_ReceiverChannelData ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, 0, 127));
    ASN_SETSIZE_CHECK(Icb_ReceiverChannelData_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_ChannelData_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_ChannelData Icb_ReceiverChannelData_GetIndex(Icb_ReceiverChannelData ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_ChannelData)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ReceiverChannelData_Print(Icb_ReceiverChannelData ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ReceiverChannelData,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_ChannelData_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_SatelliteTrackingStatusType_EnumMap[] = {
        e_Icb_SatelliteTrackingStatusType_searching,           /* Index = 0 */
        e_Icb_SatelliteTrackingStatusType_tracking,            /* Index = 1 */
        e_Icb_SatelliteTrackingStatusType_collectedAndNotUsed, /* Index = 2 */
        e_Icb_SatelliteTrackingStatusType_collectedAndUsed     /* Index = 3 */
};

ASN_Result Icb_SatelliteTrackingStatusType_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_SatelliteTrackingStatusType_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_SatelliteTrackingStatusType_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_SatelliteTrackingStatusType_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_SatelliteTrackingStatusType_Print(Icb_SatelliteTrackingStatusType value) {
    switch (value) {
        case e_Icb_SatelliteTrackingStatusType_searching:
            ASN_PrintIndented("searching" EOL);
            break;
        case e_Icb_SatelliteTrackingStatusType_tracking:
            ASN_PrintIndented("tracking" EOL);
            break;
        case e_Icb_SatelliteTrackingStatusType_collectedAndNotUsed:
            ASN_PrintIndented("collectedAndNotUsed" EOL);
            break;
        case e_Icb_SatelliteTrackingStatusType_collectedAndUsed:
            ASN_PrintIndented("collectedAndUsed" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_ExtendedChannelData of type ASNChoice
 */

Icb_ExtendedChannelData Icb_ExtendedChannelData_Create(ASN_Session session) {
    Icb_ExtendedChannelData value =
            (Icb_ExtendedChannelData)ASN_Malloc(session, sizeof(struct Icb_ExtendedChannelData_t));
    value->data = (Icb_ChannelCorrectionData)NULL;
    return value;
}

U32 Icb_ExtendedChannelData_EncodedSize(Icb_ExtendedChannelData ThisPtr) {
    U32 length = U32_EncodedSize(ThisPtr->choice, 0, 1);
    switch (ThisPtr->choice) {
        case e_Icb_ExtendedChannelData_notSupported:
            length += ASN_Null_EncodedSize(ThisPtr->notSupported);
            break;
        case e_Icb_ExtendedChannelData_data:
            length += Icb_ChannelCorrectionData_EncodedSize(ThisPtr->data);
            break;
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ExtendedChannelData_SessionSize() {
    U32 max = 0;
    U32 length;
    length = Icb_ChannelCorrectionData_SessionSize();
    if (length > max) max = length;

    return max + sizeof(struct Icb_ExtendedChannelData_t);
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ExtendedChannelData_Decode(Icb_ExtendedChannelData ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->choice, session, stream, 0, 1));
    ASN_SETTYPE_CHECK(Icb_ExtendedChannelData_SetType(ThisPtr, session, ThisPtr->choice));

    switch (ThisPtr->choice) {
        case e_Icb_ExtendedChannelData_notSupported:
            ASN_DECODE_CHECK(ASN_Null_Decode(&ThisPtr->notSupported, session, stream));
            break;

        case e_Icb_ExtendedChannelData_data:
            ASN_DECODE_CHECK(Icb_ChannelCorrectionData_Decode(ThisPtr->data, session, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ExtendedChannelData_Encode(Icb_ExtendedChannelData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->choice, stream, 0, 1));
    switch (ThisPtr->choice) {
        case e_Icb_ExtendedChannelData_notSupported:
            ASN_ENCODE_CHECK(ASN_Null_Encode(ThisPtr->notSupported, stream));
            break;

        case e_Icb_ExtendedChannelData_data:
            ASN_ENCODE_CHECK(Icb_ChannelCorrectionData_Encode(ThisPtr->data, stream));
            break;
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ExtendedChannelData_SetType(Icb_ExtendedChannelData ThisPtr, ASN_Session session, U32 type) {
    ASN_Result result = ASN_RESULT_OK;
    ThisPtr->choice = 0xffffffff;
    if (type == e_Icb_ExtendedChannelData_notSupported) {
        ThisPtr->choice = type;
    }
    if (type == e_Icb_ExtendedChannelData_data) {
        ThisPtr->choice = type;
        ThisPtr->data = Icb_ChannelCorrectionData_Create(session);
        ASN_MEM_CHECK(ThisPtr->data);
    } else
        ThisPtr->data = (Icb_ChannelCorrectionData)NULL;

    if (ThisPtr->choice == type)
        return ASN_RESULT_OK;
    else {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_NO_VALID_CHOICE;
        return result;
    }
}

#ifdef ASN_PRINT
void Icb_ExtendedChannelData_Print(Icb_ExtendedChannelData ThisPtr) {
    ASN_PrintSetIndent(1);
    switch (ThisPtr->choice) {
        case e_Icb_ExtendedChannelData_notSupported:
            ASN_PrintIndented("Icb_ExtendedChannelData is notSupported" EOL);
            ASN_PrintSetIndent(1);
            ASN_Null_Print(ThisPtr->notSupported);
            ASN_PrintSetIndent(-1);
            break;
        case e_Icb_ExtendedChannelData_data:
            ASN_PrintIndented("Icb_ExtendedChannelData is data" EOL);
            ASN_PrintSetIndent(1);
            Icb_ChannelCorrectionData_Print(ThisPtr->data);
            ASN_PrintSetIndent(-1);
            break;
        default:
            ASN_PrintIndented("illegal type ( %lu )" EOL);
            break;
    }
    ASN_PrintSetIndent(-1);
}

/*
 * End of Icb_ExtendedChannelData of type ASNChoice
 */

#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ChannelCorrectionData of type ASNSequence
 */

Icb_ChannelCorrectionData Icb_ChannelCorrectionData_Create(ASN_Session session) {
    Icb_ChannelCorrectionData value =
            (Icb_ChannelCorrectionData)ASN_Malloc(session, sizeof(struct Icb_ChannelCorrectionData_t));
    if (value != (Icb_ChannelCorrectionData)NULL) {
        value->pseudoRangeMetres = 0;
        value->pseudoRangeMillimetres = 0;
        value->rangeRate = 0;
        value->pseudoRangeCorrectionData = 0;
        value->selfEphemerisPredictionTime = 0;
    }
    return value;
}

U32 Icb_ChannelCorrectionData_EncodedSize(Icb_ChannelCorrectionData ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += S32_EncodedSize(ThisPtr->pseudoRangeMetres, -1000000000, 1000000000);
    length += U32_EncodedSize(ThisPtr->pseudoRangeMillimetres, 0, 999);
    length += S32_EncodedSize(ThisPtr->rangeRate, -1000000, 1000000);
    length += S32_EncodedSize(ThisPtr->pseudoRangeCorrectionData, -1000000, 1000000);
    length += U32_EncodedSize(ThisPtr->selfEphemerisPredictionTime, 0, 255);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ChannelCorrectionData_SessionSize() {
    U32 length = sizeof(struct Icb_ChannelCorrectionData_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_ChannelCorrectionData_Print(Icb_ChannelCorrectionData ThisPtr) {
    ASN_PrintIndented("pseudoRangeMetres" EOL);
    ASN_PrintSetIndent(1);
    S32_Print(ThisPtr->pseudoRangeMetres);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("pseudoRangeMillimetres" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->pseudoRangeMillimetres);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("rangeRate" EOL);
    ASN_PrintSetIndent(1);
    S32_Print(ThisPtr->rangeRate);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("pseudoRangeCorrectionData" EOL);
    ASN_PrintSetIndent(1);
    S32_Print(ThisPtr->pseudoRangeCorrectionData);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("selfEphemerisPredictionTime" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->selfEphemerisPredictionTime);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_ChannelCorrectionData_Decode(Icb_ChannelCorrectionData ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(S32_Decode(&ThisPtr->pseudoRangeMetres, session, stream, -1000000000, 1000000000));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->pseudoRangeMillimetres, session, stream, 0, 999));
    ASN_DECODE_CHECK(S32_Decode(&ThisPtr->rangeRate, session, stream, -1000000, 1000000));
    ASN_DECODE_CHECK(S32_Decode(&ThisPtr->pseudoRangeCorrectionData, session, stream, -1000000, 1000000));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->selfEphemerisPredictionTime, session, stream, 0, 255));
    return ASN_RESULT_OK;
}

ASN_Result Icb_ChannelCorrectionData_Encode(Icb_ChannelCorrectionData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(S32_Encode(ThisPtr->pseudoRangeMetres, stream, -1000000000, 1000000000));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->pseudoRangeMillimetres, stream, 0, 999));
    ASN_ENCODE_CHECK(S32_Encode(ThisPtr->rangeRate, stream, -1000000, 1000000));
    ASN_ENCODE_CHECK(S32_Encode(ThisPtr->pseudoRangeCorrectionData, stream, -1000000, 1000000));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->selfEphemerisPredictionTime, stream, 0, 255));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_ChannelCorrectionData of type ASNSequence
 */

/*
 * Start of Icb_AccuracyValues of type ASNSequence
 */

Icb_AccuracyValues Icb_AccuracyValues_Create(ASN_Session session) {
    Icb_AccuracyValues value = (Icb_AccuracyValues)ASN_Malloc(session, sizeof(struct Icb_AccuracyValues_t));
    if (value != (Icb_AccuracyValues)NULL) {
        value->rmsAccuracy = 0;
        value->sdLatitude = 0;
        value->sdLongitud = 0;
        value->sdAltitude = 0;
    }
    return value;
}

U32 Icb_AccuracyValues_EncodedSize(Icb_AccuracyValues ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->rmsAccuracy, 0, 100000);
    length += U32_EncodedSize(ThisPtr->sdLatitude, 0, 100000);
    length += U32_EncodedSize(ThisPtr->sdLongitud, 0, 100000);
    length += U32_EncodedSize(ThisPtr->sdAltitude, 0, 100000);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_AccuracyValues_SessionSize() {
    U32 length = sizeof(struct Icb_AccuracyValues_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_AccuracyValues_Print(Icb_AccuracyValues ThisPtr) {
    ASN_PrintIndented("rmsAccuracy" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->rmsAccuracy);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sdLatitude" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->sdLatitude);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sdLongitud" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->sdLongitud);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sdAltitude" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->sdAltitude);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_AccuracyValues_Decode(Icb_AccuracyValues ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->rmsAccuracy, session, stream, 0, 100000));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->sdLatitude, session, stream, 0, 100000));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->sdLongitud, session, stream, 0, 100000));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->sdAltitude, session, stream, 0, 100000));
    return ASN_RESULT_OK;
}

ASN_Result Icb_AccuracyValues_Encode(Icb_AccuracyValues ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->rmsAccuracy, stream, 0, 100000));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->sdLatitude, stream, 0, 100000));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->sdLongitud, stream, 0, 100000));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->sdAltitude, stream, 0, 100000));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_AccuracyValues of type ASNSequence
 */

/*
 * Start of Icb_OpRemoteDiagnosticLink_Notification of type ASNSequence
 */

Icb_OpRemoteDiagnosticLink_Notification Icb_OpRemoteDiagnosticLink_Notification_Create(ASN_Session session) {
    Icb_OpRemoteDiagnosticLink_Notification value = (Icb_OpRemoteDiagnosticLink_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpRemoteDiagnosticLink_Notification_t));
    if (value != (Icb_OpRemoteDiagnosticLink_Notification)NULL) {
        value->remoteDiagLink = 0;
    }
    return value;
}

U32 Icb_OpRemoteDiagnosticLink_Notification_EncodedSize(Icb_OpRemoteDiagnosticLink_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->remoteDiagLink);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpRemoteDiagnosticLink_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpRemoteDiagnosticLink_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpRemoteDiagnosticLink_Notification_Print(Icb_OpRemoteDiagnosticLink_Notification ThisPtr) {
    ASN_PrintIndented("remoteDiagLink" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->remoteDiagLink);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpRemoteDiagnosticLink_Notification_Decode(Icb_OpRemoteDiagnosticLink_Notification ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->remoteDiagLink, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpRemoteDiagnosticLink_Notification_Encode(Icb_OpRemoteDiagnosticLink_Notification ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->remoteDiagLink, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpRemoteDiagnosticLink_Notification of type ASNSequence
 */

static const U32 Icb_RemoteDiagInfo_EnumMap[] = {
        e_Icb_RemoteDiagInfo_closed,  /* Index = 0 */
        e_Icb_RemoteDiagInfo_started, /* Index = 1 */
        e_Icb_RemoteDiagInfo_failed   /* Index = 2 */
};

ASN_Result Icb_RemoteDiagInfo_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_RemoteDiagInfo_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_RemoteDiagInfo_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_RemoteDiagInfo_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_RemoteDiagInfo_Print(Icb_RemoteDiagInfo value) {
    switch (value) {
        case e_Icb_RemoteDiagInfo_closed:
            ASN_PrintIndented("closed" EOL);
            break;
        case e_Icb_RemoteDiagInfo_started:
            ASN_PrintIndented("started" EOL);
            break;
        case e_Icb_RemoteDiagInfo_failed:
            ASN_PrintIndented("failed" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpTextFromOperatorToUser_Notification of type ASNSequence
 */

Icb_OpTextFromOperatorToUser_Notification Icb_OpTextFromOperatorToUser_Notification_Create(ASN_Session session) {
    Icb_OpTextFromOperatorToUser_Notification value = (Icb_OpTextFromOperatorToUser_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpTextFromOperatorToUser_Notification_t));
    if (value != (Icb_OpTextFromOperatorToUser_Notification)NULL) {
        value->textChatMessage = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_OpTextFromOperatorToUser_Notification_EncodedSize(Icb_OpTextFromOperatorToUser_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_UTF8String_EncodedSize(ThisPtr->textChatMessage, 1, 256);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTextFromOperatorToUser_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpTextFromOperatorToUser_Notification_t);
    length += ASN_UTF8String_SessionSize(1, 256);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTextFromOperatorToUser_Notification_Print(Icb_OpTextFromOperatorToUser_Notification ThisPtr) {
    ASN_PrintIndented("textChatMessage" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->textChatMessage);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTextFromOperatorToUser_Notification_Decode(Icb_OpTextFromOperatorToUser_Notification ThisPtr,
                                                            ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->textChatMessage, session, stream, 1, 256));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTextFromOperatorToUser_Notification_Encode(Icb_OpTextFromOperatorToUser_Notification ThisPtr,
                                                            ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->textChatMessage, stream, 1, 256));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTextFromOperatorToUser_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpCurrentJ2534Session_Notification of type ASNSequence
 */

Icb_OpCurrentJ2534Session_Notification Icb_OpCurrentJ2534Session_Notification_Create(ASN_Session session) {
    Icb_OpCurrentJ2534Session_Notification value = (Icb_OpCurrentJ2534Session_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpCurrentJ2534Session_Notification_t));
    if (value != (Icb_OpCurrentJ2534Session_Notification)NULL) {
        value->sessionStatus = 0;
    }
    return value;
}

U32 Icb_OpCurrentJ2534Session_Notification_EncodedSize(Icb_OpCurrentJ2534Session_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->sessionStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCurrentJ2534Session_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpCurrentJ2534Session_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCurrentJ2534Session_Notification_Print(Icb_OpCurrentJ2534Session_Notification ThisPtr) {
    ASN_PrintIndented("sessionStatus" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->sessionStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCurrentJ2534Session_Notification_Decode(Icb_OpCurrentJ2534Session_Notification ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->sessionStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCurrentJ2534Session_Notification_Encode(Icb_OpCurrentJ2534Session_Notification ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->sessionStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCurrentJ2534Session_Notification of type ASNSequence
 */

static const U32 Icb_DoIPPhase_EnumMap[] = {
        e_Icb_DoIPPhase_none,         /* Index = 0 */
        e_Icb_DoIPPhase_announcement, /* Index = 1 */
        e_Icb_DoIPPhase_activation,   /* Index = 2 */
        e_Icb_DoIPPhase_session       /* Index = 3 */
};

ASN_Result Icb_DoIPPhase_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 3, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_DoIPPhase_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_DoIPPhase_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_DoIPPhase_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 3, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_DoIPPhase_Print(Icb_DoIPPhase value) {
    switch (value) {
        case e_Icb_DoIPPhase_none:
            ASN_PrintIndented("none" EOL);
            break;
        case e_Icb_DoIPPhase_announcement:
            ASN_PrintIndented("announcement" EOL);
            break;
        case e_Icb_DoIPPhase_activation:
            ASN_PrintIndented("activation" EOL);
            break;
        case e_Icb_DoIPPhase_session:
            ASN_PrintIndented("session" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_DoIPMode_EnumMap[] = {
        e_Icb_DoIPMode_none,  /* Index = 0 */
        e_Icb_DoIPMode_local, /* Index = 1 */
        e_Icb_DoIPMode_remote /* Index = 2 */
};

ASN_Result Icb_DoIPMode_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_DoIPMode_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_DoIPMode_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_DoIPMode_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_DoIPMode_Print(Icb_DoIPMode value) {
    switch (value) {
        case e_Icb_DoIPMode_none:
            ASN_PrintIndented("none" EOL);
            break;
        case e_Icb_DoIPMode_local:
            ASN_PrintIndented("local" EOL);
            break;
        case e_Icb_DoIPMode_remote:
            ASN_PrintIndented("remote" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_CurrentDoIPConn_EnumMap[] = {
        e_Icb_CurrentDoIPConn_none,        /* Index = 0 */
        e_Icb_CurrentDoIPConn_ethernetp2p, /* Index = 1 */
        e_Icb_CurrentDoIPConn_ethernetlan, /* Index = 2 */
        e_Icb_CurrentDoIPConn_wlan,        /* Index = 3 */
        e_Icb_CurrentDoIPConn_phone        /* Index = 4 */
};

ASN_Result Icb_CurrentDoIPConn_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 4, FALSE));

    if (*val >= 5) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_CurrentDoIPConn_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_CurrentDoIPConn_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_CurrentDoIPConn_EnumMap, 5);

    if (index == 5) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 4, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_CurrentDoIPConn_Print(Icb_CurrentDoIPConn value) {
    switch (value) {
        case e_Icb_CurrentDoIPConn_none:
            ASN_PrintIndented("none" EOL);
            break;
        case e_Icb_CurrentDoIPConn_ethernetp2p:
            ASN_PrintIndented("ethernetp2p" EOL);
            break;
        case e_Icb_CurrentDoIPConn_ethernetlan:
            ASN_PrintIndented("ethernetlan" EOL);
            break;
        case e_Icb_CurrentDoIPConn_wlan:
            ASN_PrintIndented("wlan" EOL);
            break;
        case e_Icb_CurrentDoIPConn_phone:
            ASN_PrintIndented("phone" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpRequestUserAuthentication_Request of type ASNSequence
 */

Icb_OpRequestUserAuthentication_Request Icb_OpRequestUserAuthentication_Request_Create(ASN_Session session) {
    Icb_OpRequestUserAuthentication_Request value = (Icb_OpRequestUserAuthentication_Request)ASN_Malloc(
            session, sizeof(struct Icb_OpRequestUserAuthentication_Request_t));
    if (value != (Icb_OpRequestUserAuthentication_Request)NULL) {
        value->operatorName = ASN_UTF8String_Create(session);
        value->serviceOrg = ASN_UTF8String_Create(session);
        value->sessionSafetyCode = 0;
    }
    return value;
}

U32 Icb_OpRequestUserAuthentication_Request_EncodedSize(Icb_OpRequestUserAuthentication_Request ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_UTF8String_EncodedSize(ThisPtr->operatorName, 1, 255);
    length += ASN_UTF8String_EncodedSize(ThisPtr->serviceOrg, 1, 255);
    length += U32_EncodedSize(ThisPtr->sessionSafetyCode, 0, 9999);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpRequestUserAuthentication_Request_SessionSize() {
    U32 length = sizeof(struct Icb_OpRequestUserAuthentication_Request_t);
    length += ASN_UTF8String_SessionSize(1, 255);
    length += ASN_UTF8String_SessionSize(1, 255);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpRequestUserAuthentication_Request_Print(Icb_OpRequestUserAuthentication_Request ThisPtr) {
    ASN_PrintIndented("operatorName" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->operatorName);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("serviceOrg" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->serviceOrg);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sessionSafetyCode" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->sessionSafetyCode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpRequestUserAuthentication_Request_Decode(Icb_OpRequestUserAuthentication_Request ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->operatorName, session, stream, 1, 255));
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->serviceOrg, session, stream, 1, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->sessionSafetyCode, session, stream, 0, 9999));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpRequestUserAuthentication_Request_Encode(Icb_OpRequestUserAuthentication_Request ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->operatorName, stream, 1, 255));
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->serviceOrg, stream, 1, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->sessionSafetyCode, stream, 0, 9999));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpRequestUserAuthentication_Request of type ASNSequence
 */

static const U32 Icb_UserAuthCredentials_EnumMap[] = {
        e_Icb_UserAuthCredentials_reject, /* Index = 0 */
        e_Icb_UserAuthCredentials_accept  /* Index = 1 */
};

ASN_Result Icb_UserAuthCredentials_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 1, FALSE));

    if (*val >= 2) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_UserAuthCredentials_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_UserAuthCredentials_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_UserAuthCredentials_EnumMap, 2);

    if (index == 2) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 1, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_UserAuthCredentials_Print(Icb_UserAuthCredentials value) {
    switch (value) {
        case e_Icb_UserAuthCredentials_reject:
            ASN_PrintIndented("reject" EOL);
            break;
        case e_Icb_UserAuthCredentials_accept:
            ASN_PrintIndented("accept" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpTextFromUserToOperator_Notification of type ASNSequence
 */

Icb_OpTextFromUserToOperator_Notification Icb_OpTextFromUserToOperator_Notification_Create(ASN_Session session) {
    Icb_OpTextFromUserToOperator_Notification value = (Icb_OpTextFromUserToOperator_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpTextFromUserToOperator_Notification_t));
    if (value != (Icb_OpTextFromUserToOperator_Notification)NULL) {
        value->textChatMessage = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_OpTextFromUserToOperator_Notification_EncodedSize(Icb_OpTextFromUserToOperator_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_UTF8String_EncodedSize(ThisPtr->textChatMessage, 1, 256);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTextFromUserToOperator_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpTextFromUserToOperator_Notification_t);
    length += ASN_UTF8String_SessionSize(1, 256);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTextFromUserToOperator_Notification_Print(Icb_OpTextFromUserToOperator_Notification ThisPtr) {
    ASN_PrintIndented("textChatMessage" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->textChatMessage);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTextFromUserToOperator_Notification_Decode(Icb_OpTextFromUserToOperator_Notification ThisPtr,
                                                            ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->textChatMessage, session, stream, 1, 256));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTextFromUserToOperator_Notification_Encode(Icb_OpTextFromUserToOperator_Notification ThisPtr,
                                                            ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->textChatMessage, stream, 1, 256));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTextFromUserToOperator_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpRequestRemoteDiagnostics_Notification of type ASNSequence
 */

Icb_OpRequestRemoteDiagnostics_Notification Icb_OpRequestRemoteDiagnostics_Notification_Create(ASN_Session session) {
    Icb_OpRequestRemoteDiagnostics_Notification value = (Icb_OpRequestRemoteDiagnostics_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpRequestRemoteDiagnostics_Notification_t));
    if (value != (Icb_OpRequestRemoteDiagnostics_Notification)NULL) {
        value->request = 0;
    }
    return value;
}

U32 Icb_OpRequestRemoteDiagnostics_Notification_EncodedSize(Icb_OpRequestRemoteDiagnostics_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->request);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpRequestRemoteDiagnostics_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpRequestRemoteDiagnostics_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpRequestRemoteDiagnostics_Notification_Print(Icb_OpRequestRemoteDiagnostics_Notification ThisPtr) {
    ASN_PrintIndented("request" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->request);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpRequestRemoteDiagnostics_Notification_Decode(Icb_OpRequestRemoteDiagnostics_Notification ThisPtr,
                                                              ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->request, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpRequestRemoteDiagnostics_Notification_Encode(Icb_OpRequestRemoteDiagnostics_Notification ThisPtr,
                                                              ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->request, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpRequestRemoteDiagnostics_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpAbortRemoteDiagnostics_Notification of type ASNSequence
 */

Icb_OpAbortRemoteDiagnostics_Notification Icb_OpAbortRemoteDiagnostics_Notification_Create(ASN_Session session) {
    Icb_OpAbortRemoteDiagnostics_Notification value = (Icb_OpAbortRemoteDiagnostics_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpAbortRemoteDiagnostics_Notification_t));
    if (value != (Icb_OpAbortRemoteDiagnostics_Notification)NULL) {
        value->abort = 0;
    }
    return value;
}

U32 Icb_OpAbortRemoteDiagnostics_Notification_EncodedSize(Icb_OpAbortRemoteDiagnostics_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->abort);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpAbortRemoteDiagnostics_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpAbortRemoteDiagnostics_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpAbortRemoteDiagnostics_Notification_Print(Icb_OpAbortRemoteDiagnostics_Notification ThisPtr) {
    ASN_PrintIndented("abort" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->abort);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpAbortRemoteDiagnostics_Notification_Decode(Icb_OpAbortRemoteDiagnostics_Notification ThisPtr,
                                                            ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->abort, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpAbortRemoteDiagnostics_Notification_Encode(Icb_OpAbortRemoteDiagnostics_Notification ThisPtr,
                                                            ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->abort, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpAbortRemoteDiagnostics_Notification of type ASNSequence
 */

static const U32 Icb_UpdateDacMode_EnumMap[] = {
        e_Icb_UpdateDacMode_automatic,     /* Index = 0 */
        e_Icb_UpdateDacMode_semiautomatic, /* Index = 1 */
        e_Icb_UpdateDacMode_manual         /* Index = 2 */
};

ASN_Result Icb_UpdateDacMode_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_UpdateDacMode_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_UpdateDacMode_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_UpdateDacMode_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_UpdateDacMode_Print(Icb_UpdateDacMode value) {
    switch (value) {
        case e_Icb_UpdateDacMode_automatic:
            ASN_PrintIndented("automatic" EOL);
            break;
        case e_Icb_UpdateDacMode_semiautomatic:
            ASN_PrintIndented("semiautomatic" EOL);
            break;
        case e_Icb_UpdateDacMode_manual:
            ASN_PrintIndented("manual" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_ApprovalStatusType of type ASNSequence
 */

Icb_ApprovalStatusType Icb_ApprovalStatusType_Create(ASN_Session session) {
    Icb_ApprovalStatusType value = (Icb_ApprovalStatusType)ASN_Malloc(session, sizeof(struct Icb_ApprovalStatusType_t));
    if (value != (Icb_ApprovalStatusType)NULL) {
        value->typeName = ASN_UTF8String_Create(session);
        value->status = 0;
        value->tcVersion = 0;
    }
    return value;
}

U32 Icb_ApprovalStatusType_EncodedSize(Icb_ApprovalStatusType ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += ASN_UTF8String_EncodedSize(ThisPtr->typeName, 1, 20);
    length += BOOL_EncodedSize(ThisPtr->status);
    length += U32_EncodedSize(ThisPtr->tcVersion, 0, 65535);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ApprovalStatusType_SessionSize() {
    U32 length = sizeof(struct Icb_ApprovalStatusType_t);
    length += ASN_UTF8String_SessionSize(1, 20);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_ApprovalStatusType_Print(Icb_ApprovalStatusType ThisPtr) {
    ASN_PrintIndented("typeName" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->typeName);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("tcVersion" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->tcVersion);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_ApprovalStatusType_Decode(Icb_ApprovalStatusType ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->typeName, session, stream, 1, 20));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->status, session, stream));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->tcVersion, session, stream, 0, 65535));
    return ASN_RESULT_OK;
}

ASN_Result Icb_ApprovalStatusType_Encode(Icb_ApprovalStatusType ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->typeName, stream, 1, 20));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->status, stream));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->tcVersion, stream, 0, 65535));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_ApprovalStatusType of type ASNSequence
 */

static const U32 Icb_DownloadStatus_EnumMap[] = {
        e_Icb_DownloadStatus_idle,     /* Index = 0 */
        e_Icb_DownloadStatus_active,   /* Index = 1 */
        e_Icb_DownloadStatus_noService /* Index = 2 */
};

ASN_Result Icb_DownloadStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 2, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_DownloadStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_DownloadStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_DownloadStatus_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 2, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_DownloadStatus_Print(Icb_DownloadStatus value) {
    switch (value) {
        case e_Icb_DownloadStatus_idle:
            ASN_PrintIndented("idle" EOL);
            break;
        case e_Icb_DownloadStatus_active:
            ASN_PrintIndented("active" EOL);
            break;
        case e_Icb_DownloadStatus_noService:
            ASN_PrintIndented("noService" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_DownloadState_EnumMap[] = {
        e_Icb_DownloadState_queued,                            /* Index = 0 */
        e_Icb_DownloadState_requestDownloadInfo,               /* Index = 1 */
        e_Icb_DownloadState_requestDownloadInfo_Halted,        /* Index = 2 */
        e_Icb_DownloadState_validatingConfig,                  /* Index = 3 */
        e_Icb_DownloadState_configValidated,                   /* Index = 4 */
        e_Icb_DownloadState_downloading,                       /* Index = 5 */
        e_Icb_DownloadState_downloading_Halted,                /* Index = 6 */
        e_Icb_DownloadState_downloaded,                        /* Index = 7 */
        e_Icb_DownloadState_installing,                        /* Index = 8 */
        e_Icb_DownloadState_installed_Waitreset,               /* Index = 9 */
        e_Icb_DownloadState_installed,                         /* Index = 10 */
        e_Icb_DownloadState_errorNoStorage,                    /* Index = 11 */
        e_Icb_DownloadState_errorSoftwareNotOk,                /* Index = 12 */
        e_Icb_DownloadState_errorDownloadFileFailed,           /* Index = 13 */
        e_Icb_DownloadState_errorTimeToLiveExceeded,           /* Index = 14 */
        e_Icb_DownloadState_errorValidationFailed,             /* Index = 15 */
        e_Icb_DownloadState_errorInstallationFailed,           /* Index = 16 */
        e_Icb_DownloadState_errorInstallationFailedMemoryFull, /* Index = 17 */
        e_Icb_DownloadState_errorNoDiagResponse,               /* Index = 18 */
        e_Icb_DownloadState_errorDownloadInfoRequestFailed,    /* Index = 19 */
        e_Icb_DownloadState_cancelling,                        /* Index = 20 */
        e_Icb_DownloadState_cancelled                          /* Index = 21 */
};

ASN_Result Icb_DownloadState_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 21, FALSE));

    if (*val >= 22) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_DownloadState_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_DownloadState_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_DownloadState_EnumMap, 22);

    if (index == 22) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 21, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_DownloadState_Print(Icb_DownloadState value) {
    switch (value) {
        case e_Icb_DownloadState_queued:
            ASN_PrintIndented("queued" EOL);
            break;
        case e_Icb_DownloadState_requestDownloadInfo:
            ASN_PrintIndented("requestDownloadInfo" EOL);
            break;
        case e_Icb_DownloadState_requestDownloadInfo_Halted:
            ASN_PrintIndented("requestDownloadInfo_Halted" EOL);
            break;
        case e_Icb_DownloadState_validatingConfig:
            ASN_PrintIndented("validatingConfig" EOL);
            break;
        case e_Icb_DownloadState_configValidated:
            ASN_PrintIndented("configValidated" EOL);
            break;
        case e_Icb_DownloadState_downloading:
            ASN_PrintIndented("downloading" EOL);
            break;
        case e_Icb_DownloadState_downloading_Halted:
            ASN_PrintIndented("downloading_Halted" EOL);
            break;
        case e_Icb_DownloadState_downloaded:
            ASN_PrintIndented("downloaded" EOL);
            break;
        case e_Icb_DownloadState_installing:
            ASN_PrintIndented("installing" EOL);
            break;
        case e_Icb_DownloadState_installed_Waitreset:
            ASN_PrintIndented("installed_Waitreset" EOL);
            break;
        case e_Icb_DownloadState_installed:
            ASN_PrintIndented("installed" EOL);
            break;
        case e_Icb_DownloadState_errorNoStorage:
            ASN_PrintIndented("errorNoStorage" EOL);
            break;
        case e_Icb_DownloadState_errorSoftwareNotOk:
            ASN_PrintIndented("errorSoftwareNotOk" EOL);
            break;
        case e_Icb_DownloadState_errorDownloadFileFailed:
            ASN_PrintIndented("errorDownloadFileFailed" EOL);
            break;
        case e_Icb_DownloadState_errorTimeToLiveExceeded:
            ASN_PrintIndented("errorTimeToLiveExceeded" EOL);
            break;
        case e_Icb_DownloadState_errorValidationFailed:
            ASN_PrintIndented("errorValidationFailed" EOL);
            break;
        case e_Icb_DownloadState_errorInstallationFailed:
            ASN_PrintIndented("errorInstallationFailed" EOL);
            break;
        case e_Icb_DownloadState_errorInstallationFailedMemoryFull:
            ASN_PrintIndented("errorInstallationFailedMemoryFull" EOL);
            break;
        case e_Icb_DownloadState_errorNoDiagResponse:
            ASN_PrintIndented("errorNoDiagResponse" EOL);
            break;
        case e_Icb_DownloadState_errorDownloadInfoRequestFailed:
            ASN_PrintIndented("errorDownloadInfoRequestFailed" EOL);
            break;
        case e_Icb_DownloadState_cancelling:
            ASN_PrintIndented("cancelling" EOL);
            break;
        case e_Icb_DownloadState_cancelled:
            ASN_PrintIndented("cancelled" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpCancelDownload_SetRequest of type ASNSequence
 */

Icb_OpCancelDownload_SetRequest Icb_OpCancelDownload_SetRequest_Create(ASN_Session session) {
    Icb_OpCancelDownload_SetRequest value =
            (Icb_OpCancelDownload_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpCancelDownload_SetRequest_t));
    if (value != (Icb_OpCancelDownload_SetRequest)NULL) {
        value->software = Icb_UUID_Create(session);
    }
    return value;
}

U32 Icb_OpCancelDownload_SetRequest_EncodedSize(Icb_OpCancelDownload_SetRequest ThisPtr) {
    U32 length = 0;
    length += Icb_UUID_EncodedSize(ThisPtr->software);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCancelDownload_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpCancelDownload_SetRequest_t);
    length += Icb_UUID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCancelDownload_SetRequest_Print(Icb_OpCancelDownload_SetRequest ThisPtr) {
    ASN_PrintIndented("software" EOL);
    ASN_PrintSetIndent(1);
    Icb_UUID_Print(ThisPtr->software);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCancelDownload_SetRequest_Decode(Icb_OpCancelDownload_SetRequest ThisPtr, ASN_Session session,
                                                  ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_UUID_Decode(ThisPtr->software, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCancelDownload_SetRequest_Encode(Icb_OpCancelDownload_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_UUID_Encode(ThisPtr->software, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCancelDownload_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpCancelDownload_Response of type ASNSequence
 */

Icb_OpCancelDownload_Response Icb_OpCancelDownload_Response_Create(ASN_Session session) {
    Icb_OpCancelDownload_Response value =
            (Icb_OpCancelDownload_Response)ASN_Malloc(session, sizeof(struct Icb_OpCancelDownload_Response_t));
    if (value != (Icb_OpCancelDownload_Response)NULL) {
        value->status = 0;
    }
    return value;
}

U32 Icb_OpCancelDownload_Response_EncodedSize(Icb_OpCancelDownload_Response ThisPtr) {
    U32 length = 0;
    length += Icb_GenericOkStatus_EncodedSize(ThisPtr->status);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCancelDownload_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpCancelDownload_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCancelDownload_Response_Print(Icb_OpCancelDownload_Response ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_GenericOkStatus_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCancelDownload_Response_Decode(Icb_OpCancelDownload_Response ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_GenericOkStatus_Decode(&ThisPtr->status, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCancelDownload_Response_Encode(Icb_OpCancelDownload_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_GenericOkStatus_Encode(ThisPtr->status, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCancelDownload_Response of type ASNSequence
 */

static const U32 Icb_InstallCommand_EnumMap[] = {
        e_Icb_InstallCommand_install,      /* Index = 0 */
        e_Icb_InstallCommand_useSoftware,  /* Index = 1 */
        e_Icb_InstallCommand_cancelInstall /* Index = 2 */
};

ASN_Result Icb_InstallCommand_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 255, FALSE));

    if (*val >= 3) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_InstallCommand_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_InstallCommand_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_InstallCommand_EnumMap, 3);

    if (index == 3) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 255, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_InstallCommand_Print(Icb_InstallCommand value) {
    switch (value) {
        case e_Icb_InstallCommand_install:
            ASN_PrintIndented("install" EOL);
            break;
        case e_Icb_InstallCommand_useSoftware:
            ASN_PrintIndented("useSoftware" EOL);
            break;
        case e_Icb_InstallCommand_cancelInstall:
            ASN_PrintIndented("cancelInstall" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_Uri of type ASNSequence
 */

Icb_Uri Icb_Uri_Create(ASN_Session session) {
    Icb_Uri value = (Icb_Uri)ASN_Malloc(session, sizeof(struct Icb_Uri_t));
    if (value != (Icb_Uri)NULL) {
        value->uri = ASN_UTF8String_Create(session);
    }
    return value;
}

U32 Icb_Uri_EncodedSize(Icb_Uri ThisPtr) {
    U32 length = 0;
    length += ASN_UTF8String_EncodedSize(ThisPtr->uri, 0, 500);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_Uri_SessionSize() {
    U32 length = sizeof(struct Icb_Uri_t);
    length += ASN_UTF8String_SessionSize(0, 500);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_Uri_Print(Icb_Uri ThisPtr) {
    ASN_PrintIndented("uri" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->uri);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_Uri_Decode(Icb_Uri ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->uri, session, stream, 0, 500));
    return ASN_RESULT_OK;
}

ASN_Result Icb_Uri_Encode(Icb_Uri ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->uri, stream, 0, 500));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_Uri of type ASNSequence
 */

/*
 * Start of Icb_InstallationData of type ASNSequence
 */

Icb_InstallationData Icb_InstallationData_Create(ASN_Session session) {
    Icb_InstallationData value = (Icb_InstallationData)ASN_Malloc(session, sizeof(struct Icb_InstallationData_t));
    if (value != (Icb_InstallationData)NULL) {
        value->identifier = Icb_PartIdentifier_Create(session);
        value->name = Icb_Uri_Create(session);
        value->rebootNeeded = 0;
    }
    return value;
}

U32 Icb_InstallationData_EncodedSize(Icb_InstallationData ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_PartIdentifier_EncodedSize(ThisPtr->identifier);
    length += Icb_Uri_EncodedSize(ThisPtr->name);
    length += BOOL_EncodedSize(ThisPtr->rebootNeeded);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_InstallationData_SessionSize() {
    U32 length = sizeof(struct Icb_InstallationData_t);
    length += Icb_PartIdentifier_SessionSize();
    length += Icb_Uri_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_InstallationData_Print(Icb_InstallationData ThisPtr) {
    ASN_PrintIndented("identifier" EOL);
    ASN_PrintSetIndent(1);
    Icb_PartIdentifier_Print(ThisPtr->identifier);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("name" EOL);
    ASN_PrintSetIndent(1);
    Icb_Uri_Print(ThisPtr->name);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("rebootNeeded" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->rebootNeeded);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_InstallationData_Decode(Icb_InstallationData ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_PartIdentifier_Decode(ThisPtr->identifier, session, stream));
    ASN_DECODE_CHECK(Icb_Uri_Decode(ThisPtr->name, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->rebootNeeded, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_InstallationData_Encode(Icb_InstallationData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_PartIdentifier_Encode(ThisPtr->identifier, stream));
    ASN_ENCODE_CHECK(Icb_Uri_Encode(ThisPtr->name, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->rebootNeeded, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_InstallationData of type ASNSequence
 */

static const U32 Icb_InstallStatus_EnumMap[] = {
        e_Icb_InstallStatus_idle,                   /* Index = 0 */
        e_Icb_InstallStatus_installing,             /* Index = 1 */
        e_Icb_InstallStatus_installationComplete,   /* Index = 2 */
        e_Icb_InstallStatus_installationPendingCmd, /* Index = 3 */
        e_Icb_InstallStatus_cancelled,              /* Index = 4 */
        e_Icb_InstallStatus_failed,                 /* Index = 5 */
        e_Icb_InstallStatus_failedMemoryFull,       /* Index = 6 */
        e_Icb_InstallStatus_installationWaitReboot, /* Index = 7 */
        e_Icb_InstallStatus_failedValidation        /* Index = 8 */
};

ASN_Result Icb_InstallStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 255, FALSE));

    if (*val >= 9) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_InstallStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_InstallStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_InstallStatus_EnumMap, 9);

    if (index == 9) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 255, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_InstallStatus_Print(Icb_InstallStatus value) {
    switch (value) {
        case e_Icb_InstallStatus_idle:
            ASN_PrintIndented("idle" EOL);
            break;
        case e_Icb_InstallStatus_installing:
            ASN_PrintIndented("installing" EOL);
            break;
        case e_Icb_InstallStatus_installationComplete:
            ASN_PrintIndented("installationComplete" EOL);
            break;
        case e_Icb_InstallStatus_installationPendingCmd:
            ASN_PrintIndented("installationPendingCmd" EOL);
            break;
        case e_Icb_InstallStatus_cancelled:
            ASN_PrintIndented("cancelled" EOL);
            break;
        case e_Icb_InstallStatus_failed:
            ASN_PrintIndented("failed" EOL);
            break;
        case e_Icb_InstallStatus_failedMemoryFull:
            ASN_PrintIndented("failedMemoryFull" EOL);
            break;
        case e_Icb_InstallStatus_installationWaitReboot:
            ASN_PrintIndented("installationWaitReboot" EOL);
            break;
        case e_Icb_InstallStatus_failedValidation:
            ASN_PrintIndented("failedValidation" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */

static const U32 Icb_FileInstallationStatus_EnumMap[] = {
        e_Icb_FileInstallationStatus_pending,    /* Index = 0 */
        e_Icb_FileInstallationStatus_installing, /* Index = 1 */
        e_Icb_FileInstallationStatus_installed,  /* Index = 2 */
        e_Icb_FileInstallationStatus_failed      /* Index = 3 */
};

ASN_Result Icb_FileInstallationStatus_Decode(U32 *val, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(ENUM_Decode(val, session, stream, 0, 255, FALSE));

    if (*val >= 4) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    *val = Icb_FileInstallationStatus_EnumMap[*val];
    return ASN_RESULT_OK;
}

ASN_Result Icb_FileInstallationStatus_Encode(U32 val, ASN_Stream stream) {
    U32 index;
    ASN_Result result = ASN_RESULT_OK;

    index = findIndex(val, Icb_FileInstallationStatus_EnumMap, 4);

    if (index == 4) {
        result = ASN_Stream_GetResult(stream);
        result->error = ASN_ERROR_VALUE_NOT_WITHIN_RANGE;
        return result;
    }

    ASN_ENCODE_CHECK(ENUM_Encode(index, stream, 0, 255, FALSE));

    return ASN_RESULT_OK;
}

#ifdef ASN_PRINT
void Icb_FileInstallationStatus_Print(Icb_FileInstallationStatus value) {
    switch (value) {
        case e_Icb_FileInstallationStatus_pending:
            ASN_PrintIndented("pending" EOL);
            break;
        case e_Icb_FileInstallationStatus_installing:
            ASN_PrintIndented("installing" EOL);
            break;
        case e_Icb_FileInstallationStatus_installed:
            ASN_PrintIndented("installed" EOL);
            break;
        case e_Icb_FileInstallationStatus_failed:
            ASN_PrintIndented("failed" EOL);
            break;
        default:
            ASN_PrintIndented("Unknown ( %lu )" EOL, (unsigned long)value);
    }
}
#endif /* #ifdef ASN_PRINT */
/*
 * Start of Icb_OpLocalStorage_Response of type ASNSequence
 */

Icb_OpLocalStorage_Response Icb_OpLocalStorage_Response_Create(ASN_Session session) {
    Icb_OpLocalStorage_Response value =
            (Icb_OpLocalStorage_Response)ASN_Malloc(session, sizeof(struct Icb_OpLocalStorage_Response_t));
    if (value != (Icb_OpLocalStorage_Response)NULL) {
        value->available = 0;
    }
    return value;
}

U32 Icb_OpLocalStorage_Response_EncodedSize(Icb_OpLocalStorage_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->available);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpLocalStorage_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpLocalStorage_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpLocalStorage_Response_Print(Icb_OpLocalStorage_Response ThisPtr) {
    ASN_PrintIndented("available" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->available);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpLocalStorage_Response_Decode(Icb_OpLocalStorage_Response ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->available, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpLocalStorage_Response_Encode(Icb_OpLocalStorage_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->available, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpLocalStorage_Response of type ASNSequence
 */

/*
 * Start of Icb_OpTvmVehicleInfo_Response of type ASNSequence
 */

Icb_OpTvmVehicleInfo_Response Icb_OpTvmVehicleInfo_Response_Create(ASN_Session session) {
    Icb_OpTvmVehicleInfo_Response value =
            (Icb_OpTvmVehicleInfo_Response)ASN_Malloc(session, sizeof(struct Icb_OpTvmVehicleInfo_Response_t));
    if (value != (Icb_OpTvmVehicleInfo_Response)NULL) {
        value->utcTime = Icb_DateTime_Create(session);
    }
    return value;
}

U32 Icb_OpTvmVehicleInfo_Response_EncodedSize(Icb_OpTvmVehicleInfo_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_DateTime_EncodedSize(ThisPtr->utcTime);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTvmVehicleInfo_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpTvmVehicleInfo_Response_t);
    length += Icb_DateTime_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTvmVehicleInfo_Response_Print(Icb_OpTvmVehicleInfo_Response ThisPtr) {
    ASN_PrintIndented("utcTime" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->utcTime);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTvmVehicleInfo_Response_Decode(Icb_OpTvmVehicleInfo_Response ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->utcTime, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTvmVehicleInfo_Response_Encode(Icb_OpTvmVehicleInfo_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->utcTime, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTvmVehicleInfo_Response of type ASNSequence
 */

/*
 * Start of Icb_OpTvmVehicleInfo_Notification of type ASNSequence
 */

Icb_OpTvmVehicleInfo_Notification Icb_OpTvmVehicleInfo_Notification_Create(ASN_Session session) {
    Icb_OpTvmVehicleInfo_Notification value =
            (Icb_OpTvmVehicleInfo_Notification)ASN_Malloc(session, sizeof(struct Icb_OpTvmVehicleInfo_Notification_t));
    if (value != (Icb_OpTvmVehicleInfo_Notification)NULL) {
        value->utcTime = Icb_DateTime_Create(session);
    }
    return value;
}

U32 Icb_OpTvmVehicleInfo_Notification_EncodedSize(Icb_OpTvmVehicleInfo_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_DateTime_EncodedSize(ThisPtr->utcTime);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTvmVehicleInfo_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpTvmVehicleInfo_Notification_t);
    length += Icb_DateTime_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTvmVehicleInfo_Notification_Print(Icb_OpTvmVehicleInfo_Notification ThisPtr) {
    ASN_PrintIndented("utcTime" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->utcTime);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTvmVehicleInfo_Notification_Decode(Icb_OpTvmVehicleInfo_Notification ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->utcTime, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTvmVehicleInfo_Notification_Encode(Icb_OpTvmVehicleInfo_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->utcTime, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTvmVehicleInfo_Notification of type ASNSequence
 */

/*
 * Start of Icb_ArrayOf_ClimateTimer of type ASNArray
 */

Icb_ArrayOf_ClimateTimer Icb_ArrayOf_ClimateTimer_Create(ASN_Session session) {
    Icb_ArrayOf_ClimateTimer value =
            (Icb_ArrayOf_ClimateTimer)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_ClimateTimer_t));

    if (value != (Icb_ArrayOf_ClimateTimer)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_ClimateTimer *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_ClimateTimer_EncodedSize(Icb_ArrayOf_ClimateTimer ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_ClimateTimer_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_ClimateTimer_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_ClimateTimer_t) +
           max * (sizeof(Icb_ClimateTimer) + Icb_ClimateTimer_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_ClimateTimer_Encode(Icb_ArrayOf_ClimateTimer ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_ClimateTimer_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_ClimateTimer_SetSize(Icb_ArrayOf_ClimateTimer ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_ClimateTimer *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_ClimateTimer *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_ClimateTimer_Create(session);
        if (ThisPtr->data_array[i] == (Icb_ClimateTimer)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_ClimateTimer_Decode(Icb_ArrayOf_ClimateTimer ThisPtr, ASN_Session session, ASN_Stream stream,
                                           S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_ClimateTimer_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_ClimateTimer_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_ClimateTimer Icb_ArrayOf_ClimateTimer_GetIndex(Icb_ArrayOf_ClimateTimer ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_ClimateTimer)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_ClimateTimer_Print(Icb_ArrayOf_ClimateTimer ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_ClimateTimer,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_ClimateTimer_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_OnOff of type ASNArray
 */

Icb_ArrayOf_OnOff Icb_ArrayOf_OnOff_Create(ASN_Session session) {
    Icb_ArrayOf_OnOff value = (Icb_ArrayOf_OnOff)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_OnOff_t));

    if (value != (Icb_ArrayOf_OnOff)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_OnOff *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_OnOff_EncodedSize(Icb_ArrayOf_OnOff ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_OnOff_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_OnOff_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_OnOff_t) + max * (sizeof(Icb_OnOff) + Icb_OnOff_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_OnOff_Encode(Icb_ArrayOf_OnOff ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_OnOff_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_OnOff_SetSize(Icb_ArrayOf_OnOff ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_OnOff *)ASN_Malloc(session, size * sizeof(Icb_OnOff));
    if (ThisPtr->data_array == (Icb_OnOff *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = 0;
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_OnOff_Decode(Icb_ArrayOf_OnOff ThisPtr, ASN_Session session, ASN_Stream stream, S32 min,
                                    S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_OnOff_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_OnOff_Decode(&ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_OnOff Icb_ArrayOf_OnOff_GetIndex(Icb_ArrayOf_OnOff ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_OnOff)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_OnOff_Print(Icb_ArrayOf_OnOff ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_OnOff,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_OnOff_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

#define ASN_INTERNAL_SIZE_Icb_OpGenericSettingSynch_Request_settingIDs(max, min) \
    {                                                                            \
        value->min_size = min;                                                   \
        value->max_size = max;                                                   \
    }
/*
 * Start of Icb_OpGenericSettingSynch_Request_settingIDs of type ASNArray
 */

Icb_OpGenericSettingSynch_Request_settingIDs Icb_OpGenericSettingSynch_Request_settingIDs_Create(ASN_Session session) {
    Icb_OpGenericSettingSynch_Request_settingIDs value = (Icb_OpGenericSettingSynch_Request_settingIDs)ASN_Malloc(
            session, sizeof(struct Icb_OpGenericSettingSynch_Request_settingIDs_t));

    if (value != (Icb_OpGenericSettingSynch_Request_settingIDs)NULL) {
        ASN_INTERNAL_SIZE_Icb_OpGenericSettingSynch_Request_settingIDs(0, 50);
        value->actual_size = 0;
        value->data_array = (U32 *)NULL;
    }
    return value;
}

U32 Icb_OpGenericSettingSynch_Request_settingIDs_EncodedSize(Icb_OpGenericSettingSynch_Request_settingIDs ThisPtr) {
    U32 i;
    U32 length = ASN_U32CountBits(0, 50);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += U32_EncodedSize(ThisPtr->data_array[i], 0, 65535);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpGenericSettingSynch_Request_settingIDs_SessionSize() {
    return sizeof(struct Icb_OpGenericSettingSynch_Request_settingIDs_t) +
           ASN_MAX(0, 50) * (sizeof(U32) + U32_SessionSize(0, 65535));
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_OpGenericSettingSynch_Request_settingIDs_Encode(Icb_OpGenericSettingSynch_Request_settingIDs ThisPtr,
                                                               ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, 0, 50));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(U32_Encode(ThisPtr->data_array[i], stream, 0, 65535));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGenericSettingSynch_Request_settingIDs_SetSize(Icb_OpGenericSettingSynch_Request_settingIDs ThisPtr,
                                                                ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (U32 *)ASN_Malloc(session, size * sizeof(U32));
    if (ThisPtr->data_array == (U32 *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = 0;
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGenericSettingSynch_Request_settingIDs_Decode(Icb_OpGenericSettingSynch_Request_settingIDs ThisPtr,
                                                               ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, 0, 50));
    ASN_SETSIZE_CHECK(Icb_OpGenericSettingSynch_Request_settingIDs_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(U32_Decode(&ThisPtr->data_array[i], session, stream, 0, 65535));
    }
    return ASN_RESULT_OK;
}

U32 Icb_OpGenericSettingSynch_Request_settingIDs_GetIndex(Icb_OpGenericSettingSynch_Request_settingIDs ThisPtr,
                                                          U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (U32)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_OpGenericSettingSynch_Request_settingIDs_Print(Icb_OpGenericSettingSynch_Request_settingIDs ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_OpGenericSettingSynch_Request_settingIDs,Size = %lu" EOL,
                      (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        U32_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_Setting of type ASNArray
 */

Icb_ArrayOf_Setting Icb_ArrayOf_Setting_Create(ASN_Session session) {
    Icb_ArrayOf_Setting value = (Icb_ArrayOf_Setting)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_Setting_t));

    if (value != (Icb_ArrayOf_Setting)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_Setting *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_Setting_EncodedSize(Icb_ArrayOf_Setting ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_Setting_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_Setting_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_Setting_t) + max * (sizeof(Icb_Setting) + Icb_Setting_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_Setting_Encode(Icb_ArrayOf_Setting ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_Setting_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_Setting_SetSize(Icb_ArrayOf_Setting ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_Setting *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_Setting *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_Setting_Create(session);
        if (ThisPtr->data_array[i] == (Icb_Setting)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_Setting_Decode(Icb_ArrayOf_Setting ThisPtr, ASN_Session session, ASN_Stream stream, S32 min,
                                      S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_Setting_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_Setting_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_Setting Icb_ArrayOf_Setting_GetIndex(Icb_ArrayOf_Setting ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_Setting)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_Setting_Print(Icb_ArrayOf_Setting ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_Setting,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_Setting_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_SBWarning of type ASNArray
 */

Icb_ArrayOf_SBWarning Icb_ArrayOf_SBWarning_Create(ASN_Session session) {
    Icb_ArrayOf_SBWarning value = (Icb_ArrayOf_SBWarning)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_SBWarning_t));

    if (value != (Icb_ArrayOf_SBWarning)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_SBWarning *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_SBWarning_EncodedSize(Icb_ArrayOf_SBWarning ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_SBWarning_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_SBWarning_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_SBWarning_t) + max * (sizeof(Icb_SBWarning) + Icb_SBWarning_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_SBWarning_Encode(Icb_ArrayOf_SBWarning ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_SBWarning_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_SBWarning_SetSize(Icb_ArrayOf_SBWarning ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_SBWarning *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_SBWarning *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_SBWarning_Create(session);
        if (ThisPtr->data_array[i] == (Icb_SBWarning)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_SBWarning_Decode(Icb_ArrayOf_SBWarning ThisPtr, ASN_Session session, ASN_Stream stream, S32 min,
                                        S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_SBWarning_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_SBWarning_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_SBWarning Icb_ArrayOf_SBWarning_GetIndex(Icb_ArrayOf_SBWarning ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_SBWarning)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_SBWarning_Print(Icb_ArrayOf_SBWarning ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_SBWarning,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_SBWarning_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_WLANFrequencyBand of type ASNArray
 */

Icb_ArrayOf_WLANFrequencyBand Icb_ArrayOf_WLANFrequencyBand_Create(ASN_Session session) {
    Icb_ArrayOf_WLANFrequencyBand value =
            (Icb_ArrayOf_WLANFrequencyBand)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_WLANFrequencyBand_t));

    if (value != (Icb_ArrayOf_WLANFrequencyBand)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_WLANFrequencyBand *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_WLANFrequencyBand_EncodedSize(Icb_ArrayOf_WLANFrequencyBand ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_WLANFrequencyBand_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_WLANFrequencyBand_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_WLANFrequencyBand_t) +
           max * (sizeof(Icb_WLANFrequencyBand) + Icb_WLANFrequencyBand_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_WLANFrequencyBand_Encode(Icb_ArrayOf_WLANFrequencyBand ThisPtr, ASN_Stream stream, S32 min,
                                                S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_WLANFrequencyBand_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_WLANFrequencyBand_SetSize(Icb_ArrayOf_WLANFrequencyBand ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_WLANFrequencyBand *)ASN_Malloc(session, size * sizeof(Icb_WLANFrequencyBand));
    if (ThisPtr->data_array == (Icb_WLANFrequencyBand *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = 0;
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_WLANFrequencyBand_Decode(Icb_ArrayOf_WLANFrequencyBand ThisPtr, ASN_Session session,
                                                ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_WLANFrequencyBand_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_WLANFrequencyBand_Decode(&ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_WLANFrequencyBand Icb_ArrayOf_WLANFrequencyBand_GetIndex(Icb_ArrayOf_WLANFrequencyBand ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_WLANFrequencyBand)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_WLANFrequencyBand_Print(Icb_ArrayOf_WLANFrequencyBand ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_WLANFrequencyBand,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_WLANFrequencyBand_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_WLANConnDevice of type ASNArray
 */

Icb_ArrayOf_WLANConnDevice Icb_ArrayOf_WLANConnDevice_Create(ASN_Session session) {
    Icb_ArrayOf_WLANConnDevice value =
            (Icb_ArrayOf_WLANConnDevice)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_WLANConnDevice_t));

    if (value != (Icb_ArrayOf_WLANConnDevice)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_WLANConnDevice *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_WLANConnDevice_EncodedSize(Icb_ArrayOf_WLANConnDevice ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_WLANConnDevice_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_WLANConnDevice_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_WLANConnDevice_t) +
           max * (sizeof(Icb_WLANConnDevice) + Icb_WLANConnDevice_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_WLANConnDevice_Encode(Icb_ArrayOf_WLANConnDevice ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_WLANConnDevice_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_WLANConnDevice_SetSize(Icb_ArrayOf_WLANConnDevice ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_WLANConnDevice *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_WLANConnDevice *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_WLANConnDevice_Create(session);
        if (ThisPtr->data_array[i] == (Icb_WLANConnDevice)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_WLANConnDevice_Decode(Icb_ArrayOf_WLANConnDevice ThisPtr, ASN_Session session, ASN_Stream stream,
                                             S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_WLANConnDevice_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_WLANConnDevice_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_WLANConnDevice Icb_ArrayOf_WLANConnDevice_GetIndex(Icb_ArrayOf_WLANConnDevice ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_WLANConnDevice)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_WLANConnDevice_Print(Icb_ArrayOf_WLANConnDevice ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_WLANConnDevice,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_WLANConnDevice_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_AvailableNetworkInformation of type ASNArray
 */

Icb_ArrayOf_AvailableNetworkInformation Icb_ArrayOf_AvailableNetworkInformation_Create(ASN_Session session) {
    Icb_ArrayOf_AvailableNetworkInformation value = (Icb_ArrayOf_AvailableNetworkInformation)ASN_Malloc(
            session, sizeof(struct Icb_ArrayOf_AvailableNetworkInformation_t));

    if (value != (Icb_ArrayOf_AvailableNetworkInformation)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_AvailableNetworkInformation *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_AvailableNetworkInformation_EncodedSize(Icb_ArrayOf_AvailableNetworkInformation ThisPtr, S32 min,
                                                        S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_AvailableNetworkInformation_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_AvailableNetworkInformation_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_AvailableNetworkInformation_t) +
           max * (sizeof(Icb_AvailableNetworkInformation) + Icb_AvailableNetworkInformation_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_AvailableNetworkInformation_Encode(Icb_ArrayOf_AvailableNetworkInformation ThisPtr,
                                                          ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_AvailableNetworkInformation_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_AvailableNetworkInformation_SetSize(Icb_ArrayOf_AvailableNetworkInformation ThisPtr,
                                                           ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_AvailableNetworkInformation *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_AvailableNetworkInformation *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_AvailableNetworkInformation_Create(session);
        if (ThisPtr->data_array[i] == (Icb_AvailableNetworkInformation)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_AvailableNetworkInformation_Decode(Icb_ArrayOf_AvailableNetworkInformation ThisPtr,
                                                          ASN_Session session, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_AvailableNetworkInformation_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_AvailableNetworkInformation_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_AvailableNetworkInformation Icb_ArrayOf_AvailableNetworkInformation_GetIndex(
        Icb_ArrayOf_AvailableNetworkInformation ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_AvailableNetworkInformation)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_AvailableNetworkInformation_Print(Icb_ArrayOf_AvailableNetworkInformation ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_AvailableNetworkInformation,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_AvailableNetworkInformation_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_SSID of type ASNArray
 */

Icb_ArrayOf_SSID Icb_ArrayOf_SSID_Create(ASN_Session session) {
    Icb_ArrayOf_SSID value = (Icb_ArrayOf_SSID)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_SSID_t));

    if (value != (Icb_ArrayOf_SSID)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_SSID *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_SSID_EncodedSize(Icb_ArrayOf_SSID ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_SSID_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_SSID_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_SSID_t) + max * (sizeof(Icb_SSID) + Icb_SSID_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_SSID_Encode(Icb_ArrayOf_SSID ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_SSID_SetSize(Icb_ArrayOf_SSID ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_SSID *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_SSID *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_SSID_Create(session);
        if (ThisPtr->data_array[i] == (Icb_SSID)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_SSID_Decode(Icb_ArrayOf_SSID ThisPtr, ASN_Session session, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_SSID_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_SSID Icb_ArrayOf_SSID_GetIndex(Icb_ArrayOf_SSID ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_SSID)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_SSID_Print(Icb_ArrayOf_SSID ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_SSID,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_SSID_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_NetworkOperator of type ASNArray
 */

Icb_ArrayOf_NetworkOperator Icb_ArrayOf_NetworkOperator_Create(ASN_Session session) {
    Icb_ArrayOf_NetworkOperator value =
            (Icb_ArrayOf_NetworkOperator)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_NetworkOperator_t));

    if (value != (Icb_ArrayOf_NetworkOperator)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_NetworkOperator *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_NetworkOperator_EncodedSize(Icb_ArrayOf_NetworkOperator ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_NetworkOperator_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_NetworkOperator_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_NetworkOperator_t) +
           max * (sizeof(Icb_NetworkOperator) + Icb_NetworkOperator_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_NetworkOperator_Encode(Icb_ArrayOf_NetworkOperator ThisPtr, ASN_Stream stream, S32 min,
                                              S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_NetworkOperator_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_NetworkOperator_SetSize(Icb_ArrayOf_NetworkOperator ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_NetworkOperator *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_NetworkOperator *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_NetworkOperator_Create(session);
        if (ThisPtr->data_array[i] == (Icb_NetworkOperator)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_NetworkOperator_Decode(Icb_ArrayOf_NetworkOperator ThisPtr, ASN_Session session,
                                              ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_NetworkOperator_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_NetworkOperator_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_NetworkOperator Icb_ArrayOf_NetworkOperator_GetIndex(Icb_ArrayOf_NetworkOperator ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_NetworkOperator)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_NetworkOperator_Print(Icb_ArrayOf_NetworkOperator ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_NetworkOperator,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_NetworkOperator_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_RadioFrequencyHz of type ASNArray
 */

Icb_ArrayOf_RadioFrequencyHz Icb_ArrayOf_RadioFrequencyHz_Create(ASN_Session session) {
    Icb_ArrayOf_RadioFrequencyHz value =
            (Icb_ArrayOf_RadioFrequencyHz)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_RadioFrequencyHz_t));

    if (value != (Icb_ArrayOf_RadioFrequencyHz)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_RadioFrequencyHz *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_RadioFrequencyHz_EncodedSize(Icb_ArrayOf_RadioFrequencyHz ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_RadioFrequencyHz_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_RadioFrequencyHz_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_RadioFrequencyHz_t) +
           max * (sizeof(Icb_RadioFrequencyHz) + Icb_RadioFrequencyHz_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_RadioFrequencyHz_Encode(Icb_ArrayOf_RadioFrequencyHz ThisPtr, ASN_Stream stream, S32 min,
                                               S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_RadioFrequencyHz_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_RadioFrequencyHz_SetSize(Icb_ArrayOf_RadioFrequencyHz ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_RadioFrequencyHz *)ASN_Malloc(session, size * sizeof(Icb_RadioFrequencyHz));
    if (ThisPtr->data_array == (Icb_RadioFrequencyHz *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = 0;
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_RadioFrequencyHz_Decode(Icb_ArrayOf_RadioFrequencyHz ThisPtr, ASN_Session session,
                                               ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_RadioFrequencyHz_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_RadioFrequencyHz_Decode(&ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_RadioFrequencyHz Icb_ArrayOf_RadioFrequencyHz_GetIndex(Icb_ArrayOf_RadioFrequencyHz ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_RadioFrequencyHz)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_RadioFrequencyHz_Print(Icb_ArrayOf_RadioFrequencyHz ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_RadioFrequencyHz,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_RadioFrequencyHz_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_ApprovalStatusType of type ASNArray
 */

Icb_ArrayOf_ApprovalStatusType Icb_ArrayOf_ApprovalStatusType_Create(ASN_Session session) {
    Icb_ArrayOf_ApprovalStatusType value =
            (Icb_ArrayOf_ApprovalStatusType)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_ApprovalStatusType_t));

    if (value != (Icb_ArrayOf_ApprovalStatusType)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_ApprovalStatusType *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_ApprovalStatusType_EncodedSize(Icb_ArrayOf_ApprovalStatusType ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_ApprovalStatusType_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_ApprovalStatusType_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_ApprovalStatusType_t) +
           max * (sizeof(Icb_ApprovalStatusType) + Icb_ApprovalStatusType_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_ApprovalStatusType_Encode(Icb_ArrayOf_ApprovalStatusType ThisPtr, ASN_Stream stream, S32 min,
                                                 S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_ApprovalStatusType_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_ApprovalStatusType_SetSize(Icb_ArrayOf_ApprovalStatusType ThisPtr, ASN_Session session,
                                                  U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_ApprovalStatusType *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_ApprovalStatusType *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_ApprovalStatusType_Create(session);
        if (ThisPtr->data_array[i] == (Icb_ApprovalStatusType)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_ApprovalStatusType_Decode(Icb_ArrayOf_ApprovalStatusType ThisPtr, ASN_Session session,
                                                 ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_ApprovalStatusType_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_ApprovalStatusType_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_ApprovalStatusType Icb_ArrayOf_ApprovalStatusType_GetIndex(Icb_ArrayOf_ApprovalStatusType ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_ApprovalStatusType)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_ApprovalStatusType_Print(Icb_ArrayOf_ApprovalStatusType ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_ApprovalStatusType,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_ApprovalStatusType_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_SoftwareProduct of type ASNArray
 */

Icb_ArrayOf_SoftwareProduct Icb_ArrayOf_SoftwareProduct_Create(ASN_Session session) {
    Icb_ArrayOf_SoftwareProduct value =
            (Icb_ArrayOf_SoftwareProduct)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_SoftwareProduct_t));

    if (value != (Icb_ArrayOf_SoftwareProduct)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_SoftwareProduct *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_SoftwareProduct_EncodedSize(Icb_ArrayOf_SoftwareProduct ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_SoftwareProduct_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_SoftwareProduct_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_SoftwareProduct_t) +
           max * (sizeof(Icb_SoftwareProduct) + Icb_SoftwareProduct_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_SoftwareProduct_Encode(Icb_ArrayOf_SoftwareProduct ThisPtr, ASN_Stream stream, S32 min,
                                              S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_SoftwareProduct_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_SoftwareProduct_SetSize(Icb_ArrayOf_SoftwareProduct ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_SoftwareProduct *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_SoftwareProduct *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_SoftwareProduct_Create(session);
        if (ThisPtr->data_array[i] == (Icb_SoftwareProduct)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_SoftwareProduct_Decode(Icb_ArrayOf_SoftwareProduct ThisPtr, ASN_Session session,
                                              ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_SoftwareProduct_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_SoftwareProduct_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_SoftwareProduct Icb_ArrayOf_SoftwareProduct_GetIndex(Icb_ArrayOf_SoftwareProduct ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_SoftwareProduct)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_SoftwareProduct_Print(Icb_ArrayOf_SoftwareProduct ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_SoftwareProduct,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_SoftwareProduct_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_UUID of type ASNArray
 */

Icb_ArrayOf_UUID Icb_ArrayOf_UUID_Create(ASN_Session session) {
    Icb_ArrayOf_UUID value = (Icb_ArrayOf_UUID)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_UUID_t));

    if (value != (Icb_ArrayOf_UUID)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_UUID *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_UUID_EncodedSize(Icb_ArrayOf_UUID ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_UUID_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_UUID_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_UUID_t) + max * (sizeof(Icb_UUID) + Icb_UUID_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_UUID_Encode(Icb_ArrayOf_UUID ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_UUID_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_UUID_SetSize(Icb_ArrayOf_UUID ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_UUID *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_UUID *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_UUID_Create(session);
        if (ThisPtr->data_array[i] == (Icb_UUID)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_UUID_Decode(Icb_ArrayOf_UUID ThisPtr, ASN_Session session, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_UUID_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_UUID_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_UUID Icb_ArrayOf_UUID_GetIndex(Icb_ArrayOf_UUID ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_UUID)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_UUID_Print(Icb_ArrayOf_UUID ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_UUID,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_UUID_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_PartIdentifier of type ASNArray
 */

Icb_ArrayOf_PartIdentifier Icb_ArrayOf_PartIdentifier_Create(ASN_Session session) {
    Icb_ArrayOf_PartIdentifier value =
            (Icb_ArrayOf_PartIdentifier)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_PartIdentifier_t));

    if (value != (Icb_ArrayOf_PartIdentifier)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_PartIdentifier *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_PartIdentifier_EncodedSize(Icb_ArrayOf_PartIdentifier ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_PartIdentifier_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_PartIdentifier_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_PartIdentifier_t) +
           max * (sizeof(Icb_PartIdentifier) + Icb_PartIdentifier_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_PartIdentifier_Encode(Icb_ArrayOf_PartIdentifier ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_PartIdentifier_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_PartIdentifier_SetSize(Icb_ArrayOf_PartIdentifier ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_PartIdentifier *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_PartIdentifier *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_PartIdentifier_Create(session);
        if (ThisPtr->data_array[i] == (Icb_PartIdentifier)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_PartIdentifier_Decode(Icb_ArrayOf_PartIdentifier ThisPtr, ASN_Session session, ASN_Stream stream,
                                             S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_PartIdentifier_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_PartIdentifier_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_PartIdentifier Icb_ArrayOf_PartIdentifier_GetIndex(Icb_ArrayOf_PartIdentifier ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_PartIdentifier)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_PartIdentifier_Print(Icb_ArrayOf_PartIdentifier ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_PartIdentifier,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_PartIdentifier_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_InstallationData of type ASNArray
 */

Icb_ArrayOf_InstallationData Icb_ArrayOf_InstallationData_Create(ASN_Session session) {
    Icb_ArrayOf_InstallationData value =
            (Icb_ArrayOf_InstallationData)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_InstallationData_t));

    if (value != (Icb_ArrayOf_InstallationData)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_InstallationData *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_InstallationData_EncodedSize(Icb_ArrayOf_InstallationData ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_InstallationData_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_InstallationData_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_InstallationData_t) +
           max * (sizeof(Icb_InstallationData) + Icb_InstallationData_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_InstallationData_Encode(Icb_ArrayOf_InstallationData ThisPtr, ASN_Stream stream, S32 min,
                                               S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_InstallationData_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_InstallationData_SetSize(Icb_ArrayOf_InstallationData ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_InstallationData *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_InstallationData *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_InstallationData_Create(session);
        if (ThisPtr->data_array[i] == (Icb_InstallationData)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_InstallationData_Decode(Icb_ArrayOf_InstallationData ThisPtr, ASN_Session session,
                                               ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_InstallationData_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_InstallationData_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_InstallationData Icb_ArrayOf_InstallationData_GetIndex(Icb_ArrayOf_InstallationData ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_InstallationData)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_InstallationData_Print(Icb_ArrayOf_InstallationData ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_InstallationData,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_InstallationData_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_ArrayOf_InstalledData of type ASNArray
 */

Icb_ArrayOf_InstalledData Icb_ArrayOf_InstalledData_Create(ASN_Session session) {
    Icb_ArrayOf_InstalledData value =
            (Icb_ArrayOf_InstalledData)ASN_Malloc(session, sizeof(struct Icb_ArrayOf_InstalledData_t));

    if (value != (Icb_ArrayOf_InstalledData)NULL) {
        value->min_size = 0;
        value->max_size = 0;
        value->actual_size = 0;
        value->data_array = (Icb_InstalledData *)NULL;
    }
    return value;
}

U32 Icb_ArrayOf_InstalledData_EncodedSize(Icb_ArrayOf_InstalledData ThisPtr, S32 min, S32 max) {
    U32 i;
    U32 length = ASN_U32CountBits(min, max);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        length += Icb_InstalledData_EncodedSize(ThisPtr->data_array[i]);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ArrayOf_InstalledData_SessionSize(S32 min, S32 max) {
    return sizeof(struct Icb_ArrayOf_InstalledData_t) +
           max * (sizeof(Icb_InstalledData) + Icb_InstalledData_SessionSize());
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

ASN_Result Icb_ArrayOf_InstalledData_Encode(Icb_ArrayOf_InstalledData ThisPtr, ASN_Stream stream, S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->actual_size, stream, min, max));
    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_ENCODE_CHECK(Icb_InstalledData_Encode(ThisPtr->data_array[i], stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_InstalledData_SetSize(Icb_ArrayOf_InstalledData ThisPtr, ASN_Session session, U32 size) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;

    ThisPtr->data_array = (Icb_InstalledData *)ASN_Malloc(session, size * sizeof(void *));
    if (ThisPtr->data_array == (Icb_InstalledData *)NULL) {
        result = ASN_Session_GetResult(session);
        result->error = ASN_ERROR_MEMORY;
        result->linenumber = __LINE__;
        return result;
    }
    for (i = 0; i < size; i++) {
        ThisPtr->data_array[i] = Icb_InstalledData_Create(session);
        if (ThisPtr->data_array[i] == (Icb_InstalledData)NULL) {
            result = ASN_Session_GetResult(session);
            result->error = ASN_ERROR_MEMORY;
            result->linenumber = __LINE__;
            return result;
        }
    }
    ThisPtr->actual_size = size;
    return ASN_RESULT_OK;
}

ASN_Result Icb_ArrayOf_InstalledData_Decode(Icb_ArrayOf_InstalledData ThisPtr, ASN_Session session, ASN_Stream stream,
                                            S32 min, S32 max) {
    ASN_Result result = ASN_RESULT_OK;
    U32 i;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->actual_size, session, stream, min, max));
    ASN_SETSIZE_CHECK(Icb_ArrayOf_InstalledData_SetSize(ThisPtr, session, ThisPtr->actual_size));

    for (i = 0; i < ThisPtr->actual_size; i++) {
        ASN_DECODE_CHECK(Icb_InstalledData_Decode(ThisPtr->data_array[i], session, stream));
    }
    return ASN_RESULT_OK;
}

Icb_InstalledData Icb_ArrayOf_InstalledData_GetIndex(Icb_ArrayOf_InstalledData ThisPtr, U32 index) {
    if (index < ThisPtr->min_size || index > ThisPtr->max_size) return (Icb_InstalledData)NULL;
    return ThisPtr->data_array[index];
}
#ifdef ASN_PRINT
void Icb_ArrayOf_InstalledData_Print(Icb_ArrayOf_InstalledData ThisPtr) {
    U32 i;
    ASN_PrintIndented("Icb_ArrayOf_InstalledData,Size = %lu" EOL, (unsigned long)ThisPtr->actual_size);
    ASN_PrintSetIndent(1);
    for (i = 0; i < ThisPtr->actual_size; i++) {
        Icb_InstalledData_Print(ThisPtr->data_array[i]);
    }
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

/*
 * Start of Icb_OpGeneric_Error of type ASNSequence
 */

Icb_OpGeneric_Error Icb_OpGeneric_Error_Create(ASN_Session session) {
    Icb_OpGeneric_Error value = (Icb_OpGeneric_Error)ASN_Malloc(session, sizeof(struct Icb_OpGeneric_Error_t));
    if (value != (Icb_OpGeneric_Error)NULL) {
        value->exists__optional__errorInfo = 0;
        value->errorCode = 0;
        value->errorInfo = 0;
    }
    return value;
}

U32 Icb_OpGeneric_Error_EncodedSize(Icb_OpGeneric_Error ThisPtr) {
    U32 length = 0;
    length += BOOL_EncodedSize(ThisPtr->exists__optional__errorInfo);
    length += Icb_ErrorCode_EncodedSize(ThisPtr->errorCode);
    if (ThisPtr->exists__optional__errorInfo == TRUE) {
        length += U32_EncodedSize(ThisPtr->errorInfo, 0, 65535);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpGeneric_Error_SessionSize() {
    U32 length = sizeof(struct Icb_OpGeneric_Error_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpGeneric_Error_Print(Icb_OpGeneric_Error ThisPtr) {
    ASN_PrintIndented("exists__optional__errorInfo" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__errorInfo);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("errorCode" EOL);
    ASN_PrintSetIndent(1);
    Icb_ErrorCode_Print(ThisPtr->errorCode);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__errorInfo == TRUE) {
        ASN_PrintIndented("errorInfo" EOL);
        ASN_PrintSetIndent(1);
        U32_Print(ThisPtr->errorInfo);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpGeneric_Error_Decode(Icb_OpGeneric_Error ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__errorInfo, session, stream));
    ASN_DECODE_CHECK(Icb_ErrorCode_Decode(&ThisPtr->errorCode, session, stream));
    if (ThisPtr->exists__optional__errorInfo == TRUE) {
        ASN_DECODE_CHECK(U32_Decode(&ThisPtr->errorInfo, session, stream, 0, 65535));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGeneric_Error_Encode(Icb_OpGeneric_Error ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__errorInfo, stream));
    ASN_ENCODE_CHECK(Icb_ErrorCode_Encode(ThisPtr->errorCode, stream));
    if (ThisPtr->exists__optional__errorInfo == TRUE) {
        ASN_ENCODE_CHECK(U32_Encode(ThisPtr->errorInfo, stream, 0, 65535));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpGeneric_Error of type ASNSequence
 */

/*
 * Start of Icb_OpTelematicSettings_SetRequest of type ASNSequence
 */

Icb_OpTelematicSettings_SetRequest Icb_OpTelematicSettings_SetRequest_Create(ASN_Session session) {
    Icb_OpTelematicSettings_SetRequest value = (Icb_OpTelematicSettings_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpTelematicSettings_SetRequest_t));
    if (value != (Icb_OpTelematicSettings_SetRequest)NULL) {
        value->exists__optional__telemSetting = 0;
        value->telemSetting = Icb_TelemSettings_Create(session);
    }
    return value;
}

U32 Icb_OpTelematicSettings_SetRequest_EncodedSize(Icb_OpTelematicSettings_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__telemSetting);
    if (ThisPtr->exists__optional__telemSetting == TRUE) {
        length += Icb_TelemSettings_EncodedSize(ThisPtr->telemSetting);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTelematicSettings_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpTelematicSettings_SetRequest_t);
    length += Icb_TelemSettings_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTelematicSettings_SetRequest_Print(Icb_OpTelematicSettings_SetRequest ThisPtr) {
    ASN_PrintIndented("exists__optional__telemSetting" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__telemSetting);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__telemSetting == TRUE) {
        ASN_PrintIndented("telemSetting" EOL);
        ASN_PrintSetIndent(1);
        Icb_TelemSettings_Print(ThisPtr->telemSetting);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTelematicSettings_SetRequest_Decode(Icb_OpTelematicSettings_SetRequest ThisPtr, ASN_Session session,
                                                     ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__telemSetting, session, stream));
    if (ThisPtr->exists__optional__telemSetting == TRUE) {
        ASN_DECODE_CHECK(Icb_TelemSettings_Decode(ThisPtr->telemSetting, session, stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTelematicSettings_SetRequest_Encode(Icb_OpTelematicSettings_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__telemSetting, stream));
    if (ThisPtr->exists__optional__telemSetting == TRUE) {
        ASN_ENCODE_CHECK(Icb_TelemSettings_Encode(ThisPtr->telemSetting, stream));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTelematicSettings_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpTelematicSettings_Response of type ASNSequence
 */

Icb_OpTelematicSettings_Response Icb_OpTelematicSettings_Response_Create(ASN_Session session) {
    Icb_OpTelematicSettings_Response value =
            (Icb_OpTelematicSettings_Response)ASN_Malloc(session, sizeof(struct Icb_OpTelematicSettings_Response_t));
    if (value != (Icb_OpTelematicSettings_Response)NULL) {
        value->telemSetting = Icb_TelemSettings_Create(session);
    }
    return value;
}

U32 Icb_OpTelematicSettings_Response_EncodedSize(Icb_OpTelematicSettings_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_TelemSettings_EncodedSize(ThisPtr->telemSetting);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTelematicSettings_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpTelematicSettings_Response_t);
    length += Icb_TelemSettings_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTelematicSettings_Response_Print(Icb_OpTelematicSettings_Response ThisPtr) {
    ASN_PrintIndented("telemSetting" EOL);
    ASN_PrintSetIndent(1);
    Icb_TelemSettings_Print(ThisPtr->telemSetting);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTelematicSettings_Response_Decode(Icb_OpTelematicSettings_Response ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_TelemSettings_Decode(ThisPtr->telemSetting, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTelematicSettings_Response_Encode(Icb_OpTelematicSettings_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_TelemSettings_Encode(ThisPtr->telemSetting, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTelematicSettings_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPositionData_Response of type ASNSequence
 */

Icb_OpPositionData_Response Icb_OpPositionData_Response_Create(ASN_Session session) {
    Icb_OpPositionData_Response value =
            (Icb_OpPositionData_Response)ASN_Malloc(session, sizeof(struct Icb_OpPositionData_Response_t));
    if (value != (Icb_OpPositionData_Response)NULL) {
        value->position = Icb_SimpleVehiclePosition_Create(session);
    }
    return value;
}

U32 Icb_OpPositionData_Response_EncodedSize(Icb_OpPositionData_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SimpleVehiclePosition_EncodedSize(ThisPtr->position);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPositionData_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPositionData_Response_t);
    length += Icb_SimpleVehiclePosition_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPositionData_Response_Print(Icb_OpPositionData_Response ThisPtr) {
    ASN_PrintIndented("position" EOL);
    ASN_PrintSetIndent(1);
    Icb_SimpleVehiclePosition_Print(ThisPtr->position);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPositionData_Response_Decode(Icb_OpPositionData_Response ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SimpleVehiclePosition_Decode(ThisPtr->position, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPositionData_Response_Encode(Icb_OpPositionData_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SimpleVehiclePosition_Encode(ThisPtr->position, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPositionData_Response of type ASNSequence
 */

/*
 * Start of Icb_WGS84SimplePositionData of type ASNSequence
 */

Icb_WGS84SimplePositionData Icb_WGS84SimplePositionData_Create(ASN_Session session) {
    Icb_WGS84SimplePositionData value =
            (Icb_WGS84SimplePositionData)ASN_Malloc(session, sizeof(struct Icb_WGS84SimplePositionData_t));
    if (value != (Icb_WGS84SimplePositionData)NULL) {
        value->longLat = Icb_CoordinatesLongLat_Create(session);
        value->fixTime = Icb_DateTime_Create(session);
        value->fixType = 0;
        value->drType = 0;
    }
    return value;
}

U32 Icb_WGS84SimplePositionData_EncodedSize(Icb_WGS84SimplePositionData ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_CoordinatesLongLat_EncodedSize(ThisPtr->longLat);
    length += Icb_DateTime_EncodedSize(ThisPtr->fixTime);
    length += Icb_GnssFixType_EncodedSize(ThisPtr->fixType);
    length += Icb_DeadReckoningType_EncodedSize(ThisPtr->drType);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_WGS84SimplePositionData_SessionSize() {
    U32 length = sizeof(struct Icb_WGS84SimplePositionData_t);
    length += Icb_CoordinatesLongLat_SessionSize();
    length += Icb_DateTime_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_WGS84SimplePositionData_Print(Icb_WGS84SimplePositionData ThisPtr) {
    ASN_PrintIndented("longLat" EOL);
    ASN_PrintSetIndent(1);
    Icb_CoordinatesLongLat_Print(ThisPtr->longLat);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("fixTime" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->fixTime);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("fixType" EOL);
    ASN_PrintSetIndent(1);
    Icb_GnssFixType_Print(ThisPtr->fixType);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("drType" EOL);
    ASN_PrintSetIndent(1);
    Icb_DeadReckoningType_Print(ThisPtr->drType);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_WGS84SimplePositionData_Decode(Icb_WGS84SimplePositionData ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_CoordinatesLongLat_Decode(ThisPtr->longLat, session, stream));
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->fixTime, session, stream));
    ASN_DECODE_CHECK(Icb_GnssFixType_Decode(&ThisPtr->fixType, session, stream));
    ASN_DECODE_CHECK(Icb_DeadReckoningType_Decode(&ThisPtr->drType, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_WGS84SimplePositionData_Encode(Icb_WGS84SimplePositionData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_CoordinatesLongLat_Encode(ThisPtr->longLat, stream));
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->fixTime, stream));
    ASN_ENCODE_CHECK(Icb_GnssFixType_Encode(ThisPtr->fixType, stream));
    ASN_ENCODE_CHECK(Icb_DeadReckoningType_Encode(ThisPtr->drType, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_WGS84SimplePositionData of type ASNSequence
 */

/*
 * Start of Icb_OpSubscriptionActivation_SetRequest of type ASNSequence
 */

Icb_OpSubscriptionActivation_SetRequest Icb_OpSubscriptionActivation_SetRequest_Create(ASN_Session session) {
    Icb_OpSubscriptionActivation_SetRequest value = (Icb_OpSubscriptionActivation_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpSubscriptionActivation_SetRequest_t));
    if (value != (Icb_OpSubscriptionActivation_SetRequest)NULL) {
        value->exists__optional__activationCode = 0;
        value->newStatus = 0;
        value->activationCode = 0;
    }
    return value;
}

U32 Icb_OpSubscriptionActivation_SetRequest_EncodedSize(Icb_OpSubscriptionActivation_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__activationCode);
    length += Icb_ActivationStatusChange_EncodedSize(ThisPtr->newStatus);
    if (ThisPtr->exists__optional__activationCode == TRUE) {
        length += U32_EncodedSize(ThisPtr->activationCode, 0, 4294967295U);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSubscriptionActivation_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpSubscriptionActivation_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSubscriptionActivation_SetRequest_Print(Icb_OpSubscriptionActivation_SetRequest ThisPtr) {
    ASN_PrintIndented("exists__optional__activationCode" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__activationCode);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("newStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_ActivationStatusChange_Print(ThisPtr->newStatus);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__activationCode == TRUE) {
        ASN_PrintIndented("activationCode" EOL);
        ASN_PrintSetIndent(1);
        U32_Print(ThisPtr->activationCode);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSubscriptionActivation_SetRequest_Decode(Icb_OpSubscriptionActivation_SetRequest ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__activationCode, session, stream));
    ASN_DECODE_CHECK(Icb_ActivationStatusChange_Decode(&ThisPtr->newStatus, session, stream));
    if (ThisPtr->exists__optional__activationCode == TRUE) {
        ASN_DECODE_CHECK(U32_Decode(&ThisPtr->activationCode, session, stream, 0, 4294967295U));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSubscriptionActivation_SetRequest_Encode(Icb_OpSubscriptionActivation_SetRequest ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__activationCode, stream));
    ASN_ENCODE_CHECK(Icb_ActivationStatusChange_Encode(ThisPtr->newStatus, stream));
    if (ThisPtr->exists__optional__activationCode == TRUE) {
        ASN_ENCODE_CHECK(U32_Encode(ThisPtr->activationCode, stream, 0, 4294967295U));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSubscriptionActivation_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpSubscriptionActivation_Response of type ASNSequence
 */

Icb_OpSubscriptionActivation_Response Icb_OpSubscriptionActivation_Response_Create(ASN_Session session) {
    Icb_OpSubscriptionActivation_Response value = (Icb_OpSubscriptionActivation_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpSubscriptionActivation_Response_t));
    if (value != (Icb_OpSubscriptionActivation_Response)NULL) {
        value->status = 0;
    }
    return value;
}

U32 Icb_OpSubscriptionActivation_Response_EncodedSize(Icb_OpSubscriptionActivation_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ActivationStatus_EncodedSize(ThisPtr->status);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSubscriptionActivation_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpSubscriptionActivation_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSubscriptionActivation_Response_Print(Icb_OpSubscriptionActivation_Response ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_ActivationStatus_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSubscriptionActivation_Response_Decode(Icb_OpSubscriptionActivation_Response ThisPtr,
                                                        ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ActivationStatus_Decode(&ThisPtr->status, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSubscriptionActivation_Response_Encode(Icb_OpSubscriptionActivation_Response ThisPtr,
                                                        ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ActivationStatus_Encode(ThisPtr->status, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSubscriptionActivation_Response of type ASNSequence
 */

/*
 * Start of Icb_OpSubscriptionActivation_Notification of type ASNSequence
 */

Icb_OpSubscriptionActivation_Notification Icb_OpSubscriptionActivation_Notification_Create(ASN_Session session) {
    Icb_OpSubscriptionActivation_Notification value = (Icb_OpSubscriptionActivation_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpSubscriptionActivation_Notification_t));
    if (value != (Icb_OpSubscriptionActivation_Notification)NULL) {
        value->status = 0;
    }
    return value;
}

U32 Icb_OpSubscriptionActivation_Notification_EncodedSize(Icb_OpSubscriptionActivation_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ActivationStatus_EncodedSize(ThisPtr->status);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSubscriptionActivation_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpSubscriptionActivation_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSubscriptionActivation_Notification_Print(Icb_OpSubscriptionActivation_Notification ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_ActivationStatus_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSubscriptionActivation_Notification_Decode(Icb_OpSubscriptionActivation_Notification ThisPtr,
                                                            ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ActivationStatus_Decode(&ThisPtr->status, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSubscriptionActivation_Notification_Encode(Icb_OpSubscriptionActivation_Notification ThisPtr,
                                                            ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ActivationStatus_Encode(ThisPtr->status, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSubscriptionActivation_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpServiceActivation_SetRequest of type ASNSequence
 */

Icb_OpServiceActivation_SetRequest Icb_OpServiceActivation_SetRequest_Create(ASN_Session session) {
    Icb_OpServiceActivation_SetRequest value = (Icb_OpServiceActivation_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpServiceActivation_SetRequest_t));
    if (value != (Icb_OpServiceActivation_SetRequest)NULL) {
        value->service = 0;
        value->action = 0;
    }
    return value;
}

U32 Icb_OpServiceActivation_SetRequest_EncodedSize(Icb_OpServiceActivation_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_OnCallService_EncodedSize(ThisPtr->service);
    length += Icb_OnOffSetting_EncodedSize(ThisPtr->action);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpServiceActivation_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpServiceActivation_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpServiceActivation_SetRequest_Print(Icb_OpServiceActivation_SetRequest ThisPtr) {
    ASN_PrintIndented("service" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnCallService_Print(ThisPtr->service);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("action" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffSetting_Print(ThisPtr->action);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpServiceActivation_SetRequest_Decode(Icb_OpServiceActivation_SetRequest ThisPtr, ASN_Session session,
                                                     ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_OnCallService_Decode(&ThisPtr->service, session, stream));
    ASN_DECODE_CHECK(Icb_OnOffSetting_Decode(&ThisPtr->action, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpServiceActivation_SetRequest_Encode(Icb_OpServiceActivation_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_OnCallService_Encode(ThisPtr->service, stream));
    ASN_ENCODE_CHECK(Icb_OnOffSetting_Encode(ThisPtr->action, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpServiceActivation_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpRescueStatus_Response of type ASNSequence
 */

Icb_OpRescueStatus_Response Icb_OpRescueStatus_Response_Create(ASN_Session session) {
    Icb_OpRescueStatus_Response value =
            (Icb_OpRescueStatus_Response)ASN_Malloc(session, sizeof(struct Icb_OpRescueStatus_Response_t));
    if (value != (Icb_OpRescueStatus_Response)NULL) {
        value->raStatus = 0;
        value->eaStatus = 0;
        value->sdnStatus = 0;
        value->voiceStatus = 0;
        value->voiceSource = 0;
        value->messageStatus = 0;
        value->buttonStatus = 0;
        value->psapConfirmStatus = 0;
        value->backupAudioStatus = 0;
    }
    return value;
}

U32 Icb_OpRescueStatus_Response_EncodedSize(Icb_OpRescueStatus_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_RescueStatus_EncodedSize(ThisPtr->raStatus);
    length += Icb_RescueStatus_EncodedSize(ThisPtr->eaStatus);
    length += Icb_RescueStatus_EncodedSize(ThisPtr->sdnStatus);
    length += Icb_VoiceStatus_EncodedSize(ThisPtr->voiceStatus);
    length += Icb_SourceStatus_EncodedSize(ThisPtr->voiceSource);
    length += Icb_MessageStatus_EncodedSize(ThisPtr->messageStatus);
    length += Icb_ButtonStatus_EncodedSize(ThisPtr->buttonStatus);
    length += Icb_PSAPStatus_EncodedSize(ThisPtr->psapConfirmStatus);
    length += Icb_GenericOkStatus_EncodedSize(ThisPtr->backupAudioStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpRescueStatus_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpRescueStatus_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpRescueStatus_Response_Print(Icb_OpRescueStatus_Response ThisPtr) {
    ASN_PrintIndented("raStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_RescueStatus_Print(ThisPtr->raStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("eaStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_RescueStatus_Print(ThisPtr->eaStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sdnStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_RescueStatus_Print(ThisPtr->sdnStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("voiceStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_VoiceStatus_Print(ThisPtr->voiceStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("voiceSource" EOL);
    ASN_PrintSetIndent(1);
    Icb_SourceStatus_Print(ThisPtr->voiceSource);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("messageStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_MessageStatus_Print(ThisPtr->messageStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("buttonStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_ButtonStatus_Print(ThisPtr->buttonStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("psapConfirmStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_PSAPStatus_Print(ThisPtr->psapConfirmStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("backupAudioStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_GenericOkStatus_Print(ThisPtr->backupAudioStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpRescueStatus_Response_Decode(Icb_OpRescueStatus_Response ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_RescueStatus_Decode(&ThisPtr->raStatus, session, stream));
    ASN_DECODE_CHECK(Icb_RescueStatus_Decode(&ThisPtr->eaStatus, session, stream));
    ASN_DECODE_CHECK(Icb_RescueStatus_Decode(&ThisPtr->sdnStatus, session, stream));
    ASN_DECODE_CHECK(Icb_VoiceStatus_Decode(&ThisPtr->voiceStatus, session, stream));
    ASN_DECODE_CHECK(Icb_SourceStatus_Decode(&ThisPtr->voiceSource, session, stream));
    ASN_DECODE_CHECK(Icb_MessageStatus_Decode(&ThisPtr->messageStatus, session, stream));
    ASN_DECODE_CHECK(Icb_ButtonStatus_Decode(&ThisPtr->buttonStatus, session, stream));
    ASN_DECODE_CHECK(Icb_PSAPStatus_Decode(&ThisPtr->psapConfirmStatus, session, stream));
    ASN_DECODE_CHECK(Icb_GenericOkStatus_Decode(&ThisPtr->backupAudioStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpRescueStatus_Response_Encode(Icb_OpRescueStatus_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_RescueStatus_Encode(ThisPtr->raStatus, stream));
    ASN_ENCODE_CHECK(Icb_RescueStatus_Encode(ThisPtr->eaStatus, stream));
    ASN_ENCODE_CHECK(Icb_RescueStatus_Encode(ThisPtr->sdnStatus, stream));
    ASN_ENCODE_CHECK(Icb_VoiceStatus_Encode(ThisPtr->voiceStatus, stream));
    ASN_ENCODE_CHECK(Icb_SourceStatus_Encode(ThisPtr->voiceSource, stream));
    ASN_ENCODE_CHECK(Icb_MessageStatus_Encode(ThisPtr->messageStatus, stream));
    ASN_ENCODE_CHECK(Icb_ButtonStatus_Encode(ThisPtr->buttonStatus, stream));
    ASN_ENCODE_CHECK(Icb_PSAPStatus_Encode(ThisPtr->psapConfirmStatus, stream));
    ASN_ENCODE_CHECK(Icb_GenericOkStatus_Encode(ThisPtr->backupAudioStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpRescueStatus_Response of type ASNSequence
 */

/*
 * Start of Icb_OpRescueStatus_Notification of type ASNSequence
 */

Icb_OpRescueStatus_Notification Icb_OpRescueStatus_Notification_Create(ASN_Session session) {
    Icb_OpRescueStatus_Notification value =
            (Icb_OpRescueStatus_Notification)ASN_Malloc(session, sizeof(struct Icb_OpRescueStatus_Notification_t));
    if (value != (Icb_OpRescueStatus_Notification)NULL) {
        value->raStatus = 0;
        value->eaStatus = 0;
        value->sdnStatus = 0;
        value->voiceStatus = 0;
        value->voiceSource = 0;
        value->messageStatus = 0;
        value->buttonStatus = 0;
        value->psapConfirmStatus = 0;
        value->backupAudioStatus = 0;
    }
    return value;
}

U32 Icb_OpRescueStatus_Notification_EncodedSize(Icb_OpRescueStatus_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_RescueStatus_EncodedSize(ThisPtr->raStatus);
    length += Icb_RescueStatus_EncodedSize(ThisPtr->eaStatus);
    length += Icb_RescueStatus_EncodedSize(ThisPtr->sdnStatus);
    length += Icb_VoiceStatus_EncodedSize(ThisPtr->voiceStatus);
    length += Icb_SourceStatus_EncodedSize(ThisPtr->voiceSource);
    length += Icb_MessageStatus_EncodedSize(ThisPtr->messageStatus);
    length += Icb_ButtonStatus_EncodedSize(ThisPtr->buttonStatus);
    length += Icb_PSAPStatus_EncodedSize(ThisPtr->psapConfirmStatus);
    length += Icb_GenericOkStatus_EncodedSize(ThisPtr->backupAudioStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpRescueStatus_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpRescueStatus_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpRescueStatus_Notification_Print(Icb_OpRescueStatus_Notification ThisPtr) {
    ASN_PrintIndented("raStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_RescueStatus_Print(ThisPtr->raStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("eaStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_RescueStatus_Print(ThisPtr->eaStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sdnStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_RescueStatus_Print(ThisPtr->sdnStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("voiceStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_VoiceStatus_Print(ThisPtr->voiceStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("voiceSource" EOL);
    ASN_PrintSetIndent(1);
    Icb_SourceStatus_Print(ThisPtr->voiceSource);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("messageStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_MessageStatus_Print(ThisPtr->messageStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("buttonStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_ButtonStatus_Print(ThisPtr->buttonStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("psapConfirmStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_PSAPStatus_Print(ThisPtr->psapConfirmStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("backupAudioStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_GenericOkStatus_Print(ThisPtr->backupAudioStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpRescueStatus_Notification_Decode(Icb_OpRescueStatus_Notification ThisPtr, ASN_Session session,
                                                  ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_RescueStatus_Decode(&ThisPtr->raStatus, session, stream));
    ASN_DECODE_CHECK(Icb_RescueStatus_Decode(&ThisPtr->eaStatus, session, stream));
    ASN_DECODE_CHECK(Icb_RescueStatus_Decode(&ThisPtr->sdnStatus, session, stream));
    ASN_DECODE_CHECK(Icb_VoiceStatus_Decode(&ThisPtr->voiceStatus, session, stream));
    ASN_DECODE_CHECK(Icb_SourceStatus_Decode(&ThisPtr->voiceSource, session, stream));
    ASN_DECODE_CHECK(Icb_MessageStatus_Decode(&ThisPtr->messageStatus, session, stream));
    ASN_DECODE_CHECK(Icb_ButtonStatus_Decode(&ThisPtr->buttonStatus, session, stream));
    ASN_DECODE_CHECK(Icb_PSAPStatus_Decode(&ThisPtr->psapConfirmStatus, session, stream));
    ASN_DECODE_CHECK(Icb_GenericOkStatus_Decode(&ThisPtr->backupAudioStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpRescueStatus_Notification_Encode(Icb_OpRescueStatus_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_RescueStatus_Encode(ThisPtr->raStatus, stream));
    ASN_ENCODE_CHECK(Icb_RescueStatus_Encode(ThisPtr->eaStatus, stream));
    ASN_ENCODE_CHECK(Icb_RescueStatus_Encode(ThisPtr->sdnStatus, stream));
    ASN_ENCODE_CHECK(Icb_VoiceStatus_Encode(ThisPtr->voiceStatus, stream));
    ASN_ENCODE_CHECK(Icb_SourceStatus_Encode(ThisPtr->voiceSource, stream));
    ASN_ENCODE_CHECK(Icb_MessageStatus_Encode(ThisPtr->messageStatus, stream));
    ASN_ENCODE_CHECK(Icb_ButtonStatus_Encode(ThisPtr->buttonStatus, stream));
    ASN_ENCODE_CHECK(Icb_PSAPStatus_Encode(ThisPtr->psapConfirmStatus, stream));
    ASN_ENCODE_CHECK(Icb_GenericOkStatus_Encode(ThisPtr->backupAudioStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpRescueStatus_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpSendToCarConfirmation_SetRequest of type ASNSequence
 */

Icb_OpSendToCarConfirmation_SetRequest Icb_OpSendToCarConfirmation_SetRequest_Create(ASN_Session session) {
    Icb_OpSendToCarConfirmation_SetRequest value = (Icb_OpSendToCarConfirmation_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpSendToCarConfirmation_SetRequest_t));
    if (value != (Icb_OpSendToCarConfirmation_SetRequest)NULL) {
        value->confirmation = 0;
        value->confirmedId = 0;
    }
    return value;
}

U32 Icb_OpSendToCarConfirmation_SetRequest_EncodedSize(Icb_OpSendToCarConfirmation_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SendToCarConfirmation_EncodedSize(ThisPtr->confirmation);
    length += Icb_SendToCarId_EncodedSize(ThisPtr->confirmedId);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSendToCarConfirmation_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpSendToCarConfirmation_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSendToCarConfirmation_SetRequest_Print(Icb_OpSendToCarConfirmation_SetRequest ThisPtr) {
    ASN_PrintIndented("confirmation" EOL);
    ASN_PrintSetIndent(1);
    Icb_SendToCarConfirmation_Print(ThisPtr->confirmation);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("confirmedId" EOL);
    ASN_PrintSetIndent(1);
    Icb_SendToCarId_Print(ThisPtr->confirmedId);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSendToCarConfirmation_SetRequest_Decode(Icb_OpSendToCarConfirmation_SetRequest ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SendToCarConfirmation_Decode(&ThisPtr->confirmation, session, stream));
    ASN_DECODE_CHECK(Icb_SendToCarId_Decode(&ThisPtr->confirmedId, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSendToCarConfirmation_SetRequest_Encode(Icb_OpSendToCarConfirmation_SetRequest ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SendToCarConfirmation_Encode(ThisPtr->confirmation, stream));
    ASN_ENCODE_CHECK(Icb_SendToCarId_Encode(ThisPtr->confirmedId, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSendToCarConfirmation_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpSendToCarConfirmation_Response of type ASNSequence
 */

Icb_OpSendToCarConfirmation_Response Icb_OpSendToCarConfirmation_Response_Create(ASN_Session session) {
    Icb_OpSendToCarConfirmation_Response value = (Icb_OpSendToCarConfirmation_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpSendToCarConfirmation_Response_t));
    if (value != (Icb_OpSendToCarConfirmation_Response)NULL) {
        value->confirmation = 0;
        value->confirmedId = 0;
    }
    return value;
}

U32 Icb_OpSendToCarConfirmation_Response_EncodedSize(Icb_OpSendToCarConfirmation_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SendToCarConfirmation_EncodedSize(ThisPtr->confirmation);
    length += Icb_SendToCarId_EncodedSize(ThisPtr->confirmedId);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSendToCarConfirmation_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpSendToCarConfirmation_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSendToCarConfirmation_Response_Print(Icb_OpSendToCarConfirmation_Response ThisPtr) {
    ASN_PrintIndented("confirmation" EOL);
    ASN_PrintSetIndent(1);
    Icb_SendToCarConfirmation_Print(ThisPtr->confirmation);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("confirmedId" EOL);
    ASN_PrintSetIndent(1);
    Icb_SendToCarId_Print(ThisPtr->confirmedId);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSendToCarConfirmation_Response_Decode(Icb_OpSendToCarConfirmation_Response ThisPtr,
                                                       ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SendToCarConfirmation_Decode(&ThisPtr->confirmation, session, stream));
    ASN_DECODE_CHECK(Icb_SendToCarId_Decode(&ThisPtr->confirmedId, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSendToCarConfirmation_Response_Encode(Icb_OpSendToCarConfirmation_Response ThisPtr,
                                                       ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SendToCarConfirmation_Encode(ThisPtr->confirmation, stream));
    ASN_ENCODE_CHECK(Icb_SendToCarId_Encode(ThisPtr->confirmedId, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSendToCarConfirmation_Response of type ASNSequence
 */

/*
 * Start of Icb_EcalSettings of type ASNSequence
 */

Icb_EcalSettings Icb_EcalSettings_Create(ASN_Session session) {
    Icb_EcalSettings value = (Icb_EcalSettings)ASN_Malloc(session, sizeof(struct Icb_EcalSettings_t));
    if (value != (Icb_EcalSettings)NULL) {
        value->preferredEcall = 0;
    }
    return value;
}

U32 Icb_EcalSettings_EncodedSize(Icb_EcalSettings ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_PreferredEcalls_EncodedSize(ThisPtr->preferredEcall);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_EcalSettings_SessionSize() {
    U32 length = sizeof(struct Icb_EcalSettings_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_EcalSettings_Print(Icb_EcalSettings ThisPtr) {
    ASN_PrintIndented("preferredEcall" EOL);
    ASN_PrintSetIndent(1);
    Icb_PreferredEcalls_Print(ThisPtr->preferredEcall);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_EcalSettings_Decode(Icb_EcalSettings ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_PreferredEcalls_Decode(&ThisPtr->preferredEcall, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_EcalSettings_Encode(Icb_EcalSettings ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_PreferredEcalls_Encode(ThisPtr->preferredEcall, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_EcalSettings of type ASNSequence
 */

/*
 * Start of Icb_OpSendToCar_SetRequest of type ASNSequence
 */

Icb_OpSendToCar_SetRequest Icb_OpSendToCar_SetRequest_Create(ASN_Session session) {
    Icb_OpSendToCar_SetRequest value =
            (Icb_OpSendToCar_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpSendToCar_SetRequest_t));
    if (value != (Icb_OpSendToCar_SetRequest)NULL) {
        value->requestId = 0;
        value->longLat = Icb_CoordinatesLongLat_Create(session);
        value->name = ASN_UTF8String_Create(session);
        value->description = ASN_UTF8String_Create(session);
        value->gpxFile = ASN_OctetString_Create(session);
    }
    return value;
}

U32 Icb_OpSendToCar_SetRequest_EncodedSize(Icb_OpSendToCar_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SendToCarId_EncodedSize(ThisPtr->requestId);
    length += Icb_CoordinatesLongLat_EncodedSize(ThisPtr->longLat);
    length += ASN_UTF8String_EncodedSize(ThisPtr->name, 0, 30);
    length += ASN_UTF8String_EncodedSize(ThisPtr->description, 0, 100);
    length += ASN_OctetString_EncodedSize(ThisPtr->gpxFile, 0, 1048575);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSendToCar_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpSendToCar_SetRequest_t);
    length += Icb_CoordinatesLongLat_SessionSize();
    length += ASN_UTF8String_SessionSize(0, 30);
    length += ASN_UTF8String_SessionSize(0, 100);
    length += ASN_OctetString_SessionSize(0, 1048575);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSendToCar_SetRequest_Print(Icb_OpSendToCar_SetRequest ThisPtr) {
    ASN_PrintIndented("requestId" EOL);
    ASN_PrintSetIndent(1);
    Icb_SendToCarId_Print(ThisPtr->requestId);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("longLat" EOL);
    ASN_PrintSetIndent(1);
    Icb_CoordinatesLongLat_Print(ThisPtr->longLat);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("name" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->name);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("description" EOL);
    ASN_PrintSetIndent(1);
    ASN_UTF8String_Print(ThisPtr->description);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("gpxFile" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->gpxFile);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSendToCar_SetRequest_Decode(Icb_OpSendToCar_SetRequest ThisPtr, ASN_Session session,
                                             ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SendToCarId_Decode(&ThisPtr->requestId, session, stream));
    ASN_DECODE_CHECK(Icb_CoordinatesLongLat_Decode(ThisPtr->longLat, session, stream));
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->name, session, stream, 0, 30));
    ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->description, session, stream, 0, 100));
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->gpxFile, session, stream, 0, 1048575));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSendToCar_SetRequest_Encode(Icb_OpSendToCar_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SendToCarId_Encode(ThisPtr->requestId, stream));
    ASN_ENCODE_CHECK(Icb_CoordinatesLongLat_Encode(ThisPtr->longLat, stream));
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->name, stream, 0, 30));
    ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->description, stream, 0, 100));
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->gpxFile, stream, 0, 1048575));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSendToCar_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpUserPrivacySettings_Notification of type ASNSequence
 */

Icb_OpUserPrivacySettings_Notification Icb_OpUserPrivacySettings_Notification_Create(ASN_Session session) {
    Icb_OpUserPrivacySettings_Notification value = (Icb_OpUserPrivacySettings_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpUserPrivacySettings_Notification_t));
    if (value != (Icb_OpUserPrivacySettings_Notification)NULL) {
        value->userPrivacySetting = Icb_UserPrivacySettings_Create(session);
    }
    return value;
}

U32 Icb_OpUserPrivacySettings_Notification_EncodedSize(Icb_OpUserPrivacySettings_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_UserPrivacySettings_EncodedSize(ThisPtr->userPrivacySetting);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpUserPrivacySettings_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpUserPrivacySettings_Notification_t);
    length += Icb_UserPrivacySettings_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpUserPrivacySettings_Notification_Print(Icb_OpUserPrivacySettings_Notification ThisPtr) {
    ASN_PrintIndented("userPrivacySetting" EOL);
    ASN_PrintSetIndent(1);
    Icb_UserPrivacySettings_Print(ThisPtr->userPrivacySetting);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpUserPrivacySettings_Notification_Decode(Icb_OpUserPrivacySettings_Notification ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_UserPrivacySettings_Decode(ThisPtr->userPrivacySetting, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpUserPrivacySettings_Notification_Encode(Icb_OpUserPrivacySettings_Notification ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_UserPrivacySettings_Encode(ThisPtr->userPrivacySetting, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpUserPrivacySettings_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpClimateTimers_SetRequest of type ASNSequence
 */

Icb_OpClimateTimers_SetRequest Icb_OpClimateTimers_SetRequest_Create(ASN_Session session) {
    Icb_OpClimateTimers_SetRequest value =
            (Icb_OpClimateTimers_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpClimateTimers_SetRequest_t));
    if (value != (Icb_OpClimateTimers_SetRequest)NULL) {
        value->timestamp = Icb_DateTime_Create(session);
        value->timers = Icb_ArrayOf_ClimateTimer_Create(session);
    }
    return value;
}

U32 Icb_OpClimateTimers_SetRequest_EncodedSize(Icb_OpClimateTimers_SetRequest ThisPtr) {
    U32 length = 0;
    length += Icb_DateTime_EncodedSize(ThisPtr->timestamp);
    length += Icb_ArrayOf_ClimateTimer_EncodedSize(ThisPtr->timers, 0, 31);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpClimateTimers_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpClimateTimers_SetRequest_t);
    length += Icb_DateTime_SessionSize();
    length += Icb_ArrayOf_ClimateTimer_SessionSize(0, 31);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpClimateTimers_SetRequest_Print(Icb_OpClimateTimers_SetRequest ThisPtr) {
    ASN_PrintIndented("timestamp" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->timestamp);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("timers" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_ClimateTimer_Print(ThisPtr->timers);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpClimateTimers_SetRequest_Decode(Icb_OpClimateTimers_SetRequest ThisPtr, ASN_Session session,
                                                 ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->timestamp, session, stream));
    ASN_DECODE_CHECK(Icb_ArrayOf_ClimateTimer_Decode(ThisPtr->timers, session, stream, 0, 31));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpClimateTimers_SetRequest_Encode(Icb_OpClimateTimers_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->timestamp, stream));
    ASN_ENCODE_CHECK(Icb_ArrayOf_ClimateTimer_Encode(ThisPtr->timers, stream, 0, 31));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpClimateTimers_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpClimateTimers_Response of type ASNSequence
 */

Icb_OpClimateTimers_Response Icb_OpClimateTimers_Response_Create(ASN_Session session) {
    Icb_OpClimateTimers_Response value =
            (Icb_OpClimateTimers_Response)ASN_Malloc(session, sizeof(struct Icb_OpClimateTimers_Response_t));
    if (value != (Icb_OpClimateTimers_Response)NULL) {
        value->timestamp = Icb_DateTime_Create(session);
        value->timers = Icb_ArrayOf_ClimateTimer_Create(session);
        value->errorMessage = Icb_ClimateTimerError_Create(session);
    }
    return value;
}

U32 Icb_OpClimateTimers_Response_EncodedSize(Icb_OpClimateTimers_Response ThisPtr) {
    U32 length = 0;
    length += Icb_DateTime_EncodedSize(ThisPtr->timestamp);
    length += Icb_ArrayOf_ClimateTimer_EncodedSize(ThisPtr->timers, 0, 31);
    length += Icb_ClimateTimerError_EncodedSize(ThisPtr->errorMessage);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpClimateTimers_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpClimateTimers_Response_t);
    length += Icb_DateTime_SessionSize();
    length += Icb_ArrayOf_ClimateTimer_SessionSize(0, 31);
    length += Icb_ClimateTimerError_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpClimateTimers_Response_Print(Icb_OpClimateTimers_Response ThisPtr) {
    ASN_PrintIndented("timestamp" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->timestamp);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("timers" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_ClimateTimer_Print(ThisPtr->timers);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("errorMessage" EOL);
    ASN_PrintSetIndent(1);
    Icb_ClimateTimerError_Print(ThisPtr->errorMessage);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpClimateTimers_Response_Decode(Icb_OpClimateTimers_Response ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->timestamp, session, stream));
    ASN_DECODE_CHECK(Icb_ArrayOf_ClimateTimer_Decode(ThisPtr->timers, session, stream, 0, 31));
    ASN_DECODE_CHECK(Icb_ClimateTimerError_Decode(ThisPtr->errorMessage, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpClimateTimers_Response_Encode(Icb_OpClimateTimers_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->timestamp, stream));
    ASN_ENCODE_CHECK(Icb_ArrayOf_ClimateTimer_Encode(ThisPtr->timers, stream, 0, 31));
    ASN_ENCODE_CHECK(Icb_ClimateTimerError_Encode(ThisPtr->errorMessage, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpClimateTimers_Response of type ASNSequence
 */

/*
 * Start of Icb_TimerDays of type ASNSequence
 */

Icb_TimerDays Icb_TimerDays_Create(ASN_Session session) {
    Icb_TimerDays value = (Icb_TimerDays)ASN_Malloc(session, sizeof(struct Icb_TimerDays_t));
    if (value != (Icb_TimerDays)NULL) {
        value->days = Icb_ArrayOf_OnOff_Create(session);
    }
    return value;
}

U32 Icb_TimerDays_EncodedSize(Icb_TimerDays ThisPtr) {
    U32 length = 0;
    length += Icb_ArrayOf_OnOff_EncodedSize(ThisPtr->days, 7, 7);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_TimerDays_SessionSize() {
    U32 length = sizeof(struct Icb_TimerDays_t);
    length += Icb_ArrayOf_OnOff_SessionSize(7, 7);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_TimerDays_Print(Icb_TimerDays ThisPtr) {
    ASN_PrintIndented("days" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_OnOff_Print(ThisPtr->days);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_TimerDays_Decode(Icb_TimerDays ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_ArrayOf_OnOff_Decode(ThisPtr->days, session, stream, 7, 7));
    return ASN_RESULT_OK;
}

ASN_Result Icb_TimerDays_Encode(Icb_TimerDays ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_ArrayOf_OnOff_Encode(ThisPtr->days, stream, 7, 7));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_TimerDays of type ASNSequence
 */

/*
 * Start of Icb_OpGenericSettingSynch_Request of type ASNSequence
 */

Icb_OpGenericSettingSynch_Request Icb_OpGenericSettingSynch_Request_Create(ASN_Session session) {
    Icb_OpGenericSettingSynch_Request value =
            (Icb_OpGenericSettingSynch_Request)ASN_Malloc(session, sizeof(struct Icb_OpGenericSettingSynch_Request_t));
    if (value != (Icb_OpGenericSettingSynch_Request)NULL) {
        value->time = Icb_DateTime_Create(session);
        value->settingIDs = Icb_OpGenericSettingSynch_Request_settingIDs_Create(session);
    }
    return value;
}

U32 Icb_OpGenericSettingSynch_Request_EncodedSize(Icb_OpGenericSettingSynch_Request ThisPtr) {
    U32 length = 0;
    length += Icb_DateTime_EncodedSize(ThisPtr->time);
    length += Icb_OpGenericSettingSynch_Request_settingIDs_EncodedSize(ThisPtr->settingIDs);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpGenericSettingSynch_Request_SessionSize() {
    U32 length = sizeof(struct Icb_OpGenericSettingSynch_Request_t);
    length += Icb_DateTime_SessionSize();
    length += Icb_OpGenericSettingSynch_Request_settingIDs_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpGenericSettingSynch_Request_Print(Icb_OpGenericSettingSynch_Request ThisPtr) {
    ASN_PrintIndented("time" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->time);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("settingIDs" EOL);
    ASN_PrintSetIndent(1);
    Icb_OpGenericSettingSynch_Request_settingIDs_Print(ThisPtr->settingIDs);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpGenericSettingSynch_Request_Decode(Icb_OpGenericSettingSynch_Request ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->time, session, stream));
    ASN_DECODE_CHECK(Icb_OpGenericSettingSynch_Request_settingIDs_Decode(ThisPtr->settingIDs, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGenericSettingSynch_Request_Encode(Icb_OpGenericSettingSynch_Request ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->time, stream));
    ASN_ENCODE_CHECK(Icb_OpGenericSettingSynch_Request_settingIDs_Encode(ThisPtr->settingIDs, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpGenericSettingSynch_Request of type ASNSequence
 */

/*
 * Start of Icb_OpGenericSettingSynch_SetRequest of type ASNSequence
 */

Icb_OpGenericSettingSynch_SetRequest Icb_OpGenericSettingSynch_SetRequest_Create(ASN_Session session) {
    Icb_OpGenericSettingSynch_SetRequest value = (Icb_OpGenericSettingSynch_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpGenericSettingSynch_SetRequest_t));
    if (value != (Icb_OpGenericSettingSynch_SetRequest)NULL) {
        value->time = Icb_DateTime_Create(session);
        value->settings = Icb_ArrayOf_Setting_Create(session);
    }
    return value;
}

U32 Icb_OpGenericSettingSynch_SetRequest_EncodedSize(Icb_OpGenericSettingSynch_SetRequest ThisPtr) {
    U32 length = 0;
    length += Icb_DateTime_EncodedSize(ThisPtr->time);
    length += Icb_ArrayOf_Setting_EncodedSize(ThisPtr->settings, 0, 50);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpGenericSettingSynch_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpGenericSettingSynch_SetRequest_t);
    length += Icb_DateTime_SessionSize();
    length += Icb_ArrayOf_Setting_SessionSize(0, 50);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpGenericSettingSynch_SetRequest_Print(Icb_OpGenericSettingSynch_SetRequest ThisPtr) {
    ASN_PrintIndented("time" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->time);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("settings" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_Setting_Print(ThisPtr->settings);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpGenericSettingSynch_SetRequest_Decode(Icb_OpGenericSettingSynch_SetRequest ThisPtr,
                                                       ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->time, session, stream));
    ASN_DECODE_CHECK(Icb_ArrayOf_Setting_Decode(ThisPtr->settings, session, stream, 0, 50));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGenericSettingSynch_SetRequest_Encode(Icb_OpGenericSettingSynch_SetRequest ThisPtr,
                                                       ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->time, stream));
    ASN_ENCODE_CHECK(Icb_ArrayOf_Setting_Encode(ThisPtr->settings, stream, 0, 50));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpGenericSettingSynch_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpGenericSettingSynch_Response of type ASNSequence
 */

Icb_OpGenericSettingSynch_Response Icb_OpGenericSettingSynch_Response_Create(ASN_Session session) {
    Icb_OpGenericSettingSynch_Response value = (Icb_OpGenericSettingSynch_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpGenericSettingSynch_Response_t));
    if (value != (Icb_OpGenericSettingSynch_Response)NULL) {
        value->time = Icb_DateTime_Create(session);
        value->settings = Icb_ArrayOf_Setting_Create(session);
    }
    return value;
}

U32 Icb_OpGenericSettingSynch_Response_EncodedSize(Icb_OpGenericSettingSynch_Response ThisPtr) {
    U32 length = 0;
    length += Icb_DateTime_EncodedSize(ThisPtr->time);
    length += Icb_ArrayOf_Setting_EncodedSize(ThisPtr->settings, 0, 50);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpGenericSettingSynch_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpGenericSettingSynch_Response_t);
    length += Icb_DateTime_SessionSize();
    length += Icb_ArrayOf_Setting_SessionSize(0, 50);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpGenericSettingSynch_Response_Print(Icb_OpGenericSettingSynch_Response ThisPtr) {
    ASN_PrintIndented("time" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->time);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("settings" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_Setting_Print(ThisPtr->settings);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpGenericSettingSynch_Response_Decode(Icb_OpGenericSettingSynch_Response ThisPtr, ASN_Session session,
                                                     ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->time, session, stream));
    ASN_DECODE_CHECK(Icb_ArrayOf_Setting_Decode(ThisPtr->settings, session, stream, 0, 50));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGenericSettingSynch_Response_Encode(Icb_OpGenericSettingSynch_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->time, stream));
    ASN_ENCODE_CHECK(Icb_ArrayOf_Setting_Encode(ThisPtr->settings, stream, 0, 50));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpGenericSettingSynch_Response of type ASNSequence
 */

/*
 * Start of Icb_OpGenericSettingSynch_Notification of type ASNSequence
 */

Icb_OpGenericSettingSynch_Notification Icb_OpGenericSettingSynch_Notification_Create(ASN_Session session) {
    Icb_OpGenericSettingSynch_Notification value = (Icb_OpGenericSettingSynch_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpGenericSettingSynch_Notification_t));
    if (value != (Icb_OpGenericSettingSynch_Notification)NULL) {
        value->time = Icb_DateTime_Create(session);
        value->settings = Icb_ArrayOf_Setting_Create(session);
    }
    return value;
}

U32 Icb_OpGenericSettingSynch_Notification_EncodedSize(Icb_OpGenericSettingSynch_Notification ThisPtr) {
    U32 length = 0;
    length += Icb_DateTime_EncodedSize(ThisPtr->time);
    length += Icb_ArrayOf_Setting_EncodedSize(ThisPtr->settings, 0, 50);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpGenericSettingSynch_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpGenericSettingSynch_Notification_t);
    length += Icb_DateTime_SessionSize();
    length += Icb_ArrayOf_Setting_SessionSize(0, 50);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpGenericSettingSynch_Notification_Print(Icb_OpGenericSettingSynch_Notification ThisPtr) {
    ASN_PrintIndented("time" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->time);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("settings" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_Setting_Print(ThisPtr->settings);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpGenericSettingSynch_Notification_Decode(Icb_OpGenericSettingSynch_Notification ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->time, session, stream));
    ASN_DECODE_CHECK(Icb_ArrayOf_Setting_Decode(ThisPtr->settings, session, stream, 0, 50));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGenericSettingSynch_Notification_Encode(Icb_OpGenericSettingSynch_Notification ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->time, stream));
    ASN_ENCODE_CHECK(Icb_ArrayOf_Setting_Encode(ThisPtr->settings, stream, 0, 50));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpGenericSettingSynch_Notification of type ASNSequence
 */

/*
 * Start of Icb_Setting of type ASNSequence
 */

Icb_Setting Icb_Setting_Create(ASN_Session session) {
    Icb_Setting value = (Icb_Setting)ASN_Malloc(session, sizeof(struct Icb_Setting_t));
    if (value != (Icb_Setting)NULL) {
        value->id = 0;
        value->sType = 0;
        value->length = 0;
        value->value = ASN_OctetString_Create(session);
    }
    return value;
}

U32 Icb_Setting_EncodedSize(Icb_Setting ThisPtr) {
    U32 length = 0;
    length += U32_EncodedSize(ThisPtr->id, 0, 65535);
    length += Icb_SettingType_EncodedSize(ThisPtr->sType);
    length += U32_EncodedSize(ThisPtr->length, 0, 65535);
    length += ASN_OctetString_EncodedSize(ThisPtr->value, 0, 1023);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_Setting_SessionSize() {
    U32 length = sizeof(struct Icb_Setting_t);
    length += ASN_OctetString_SessionSize(0, 1023);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_Setting_Print(Icb_Setting ThisPtr) {
    ASN_PrintIndented("id" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->id);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sType" EOL);
    ASN_PrintSetIndent(1);
    Icb_SettingType_Print(ThisPtr->sType);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("length" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->length);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("value" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->value);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_Setting_Decode(Icb_Setting ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->id, session, stream, 0, 65535));
    ASN_DECODE_CHECK(Icb_SettingType_Decode(&ThisPtr->sType, session, stream));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->length, session, stream, 0, 65535));
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->value, session, stream, 0, 1023));
    return ASN_RESULT_OK;
}

ASN_Result Icb_Setting_Encode(Icb_Setting ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->id, stream, 0, 65535));
    ASN_ENCODE_CHECK(Icb_SettingType_Encode(ThisPtr->sType, stream));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->length, stream, 0, 65535));
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->value, stream, 0, 1023));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_Setting of type ASNSequence
 */

/*
 * Start of Icb_OpSoHPacketSend_SetRequestNoReturn of type ASNSequence
 */

Icb_OpSoHPacketSend_SetRequestNoReturn Icb_OpSoHPacketSend_SetRequestNoReturn_Create(ASN_Session session) {
    Icb_OpSoHPacketSend_SetRequestNoReturn value = (Icb_OpSoHPacketSend_SetRequestNoReturn)ASN_Malloc(
            session, sizeof(struct Icb_OpSoHPacketSend_SetRequestNoReturn_t));
    if (value != (Icb_OpSoHPacketSend_SetRequestNoReturn)NULL) {
        value->exists__optional__sbText = 0;
        value->exists__optional__sbMainCause = 0;
        value->sbTrigger = 0;
        value->sbText = ASN_UTF8String_Create(session);
        value->sbMainCause = Icb_SBWarning_Create(session);
        value->sbWarnings = Icb_ArrayOf_SBWarning_Create(session);
    }
    return value;
}

U32 Icb_OpSoHPacketSend_SetRequestNoReturn_EncodedSize(Icb_OpSoHPacketSend_SetRequestNoReturn ThisPtr) {
    U32 length = 0;
    length += BOOL_EncodedSize(ThisPtr->exists__optional__sbText);
    length += BOOL_EncodedSize(ThisPtr->exists__optional__sbMainCause);
    length += Icb_SBTrigger_EncodedSize(ThisPtr->sbTrigger);
    if (ThisPtr->exists__optional__sbText == TRUE) {
        length += ASN_UTF8String_EncodedSize(ThisPtr->sbText, 0, 5);
    }
    if (ThisPtr->exists__optional__sbMainCause == TRUE) {
        length += Icb_SBWarning_EncodedSize(ThisPtr->sbMainCause);
    }
    length += Icb_ArrayOf_SBWarning_EncodedSize(ThisPtr->sbWarnings, 0, 255);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpSoHPacketSend_SetRequestNoReturn_SessionSize() {
    U32 length = sizeof(struct Icb_OpSoHPacketSend_SetRequestNoReturn_t);
    length += ASN_UTF8String_SessionSize(0, 5);
    length += Icb_SBWarning_SessionSize();
    length += Icb_ArrayOf_SBWarning_SessionSize(0, 255);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpSoHPacketSend_SetRequestNoReturn_Print(Icb_OpSoHPacketSend_SetRequestNoReturn ThisPtr) {
    ASN_PrintIndented("exists__optional__sbText" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__sbText);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("exists__optional__sbMainCause" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__sbMainCause);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sbTrigger" EOL);
    ASN_PrintSetIndent(1);
    Icb_SBTrigger_Print(ThisPtr->sbTrigger);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__sbText == TRUE) {
        ASN_PrintIndented("sbText" EOL);
        ASN_PrintSetIndent(1);
        ASN_UTF8String_Print(ThisPtr->sbText);
        ASN_PrintSetIndent(-1);
    }
    if (ThisPtr->exists__optional__sbMainCause == TRUE) {
        ASN_PrintIndented("sbMainCause" EOL);
        ASN_PrintSetIndent(1);
        Icb_SBWarning_Print(ThisPtr->sbMainCause);
        ASN_PrintSetIndent(-1);
    }
    ASN_PrintIndented("sbWarnings" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_SBWarning_Print(ThisPtr->sbWarnings);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpSoHPacketSend_SetRequestNoReturn_Decode(Icb_OpSoHPacketSend_SetRequestNoReturn ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__sbText, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__sbMainCause, session, stream));
    ASN_DECODE_CHECK(Icb_SBTrigger_Decode(&ThisPtr->sbTrigger, session, stream));
    if (ThisPtr->exists__optional__sbText == TRUE) {
        ASN_DECODE_CHECK(ASN_UTF8String_Decode(ThisPtr->sbText, session, stream, 0, 5));
    }
    if (ThisPtr->exists__optional__sbMainCause == TRUE) {
        ASN_DECODE_CHECK(Icb_SBWarning_Decode(ThisPtr->sbMainCause, session, stream));
    }
    ASN_DECODE_CHECK(Icb_ArrayOf_SBWarning_Decode(ThisPtr->sbWarnings, session, stream, 0, 255));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpSoHPacketSend_SetRequestNoReturn_Encode(Icb_OpSoHPacketSend_SetRequestNoReturn ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__sbText, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__sbMainCause, stream));
    ASN_ENCODE_CHECK(Icb_SBTrigger_Encode(ThisPtr->sbTrigger, stream));
    if (ThisPtr->exists__optional__sbText == TRUE) {
        ASN_ENCODE_CHECK(ASN_UTF8String_Encode(ThisPtr->sbText, stream, 0, 5));
    }
    if (ThisPtr->exists__optional__sbMainCause == TRUE) {
        ASN_ENCODE_CHECK(Icb_SBWarning_Encode(ThisPtr->sbMainCause, stream));
    }
    ASN_ENCODE_CHECK(Icb_ArrayOf_SBWarning_Encode(ThisPtr->sbWarnings, stream, 0, 255));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpSoHPacketSend_SetRequestNoReturn of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMDataCounter_Response of type ASNSequence
 */

Icb_OpPSIMDataCounter_Response Icb_OpPSIMDataCounter_Response_Create(ASN_Session session) {
    Icb_OpPSIMDataCounter_Response value =
            (Icb_OpPSIMDataCounter_Response)ASN_Malloc(session, sizeof(struct Icb_OpPSIMDataCounter_Response_t));
    if (value != (Icb_OpPSIMDataCounter_Response)NULL) {
        value->byteCount = 0;
        value->counter = 0;
        value->dateTime = Icb_DateTime_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMDataCounter_Response_EncodedSize(Icb_OpPSIMDataCounter_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_DataCounterValue_EncodedSize(ThisPtr->byteCount);
    length += Icb_DataCounter_EncodedSize(ThisPtr->counter);
    length += Icb_DateTime_EncodedSize(ThisPtr->dateTime);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMDataCounter_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMDataCounter_Response_t);
    length += Icb_DateTime_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMDataCounter_Response_Print(Icb_OpPSIMDataCounter_Response ThisPtr) {
    ASN_PrintIndented("byteCount" EOL);
    ASN_PrintSetIndent(1);
    Icb_DataCounterValue_Print(ThisPtr->byteCount);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("counter" EOL);
    ASN_PrintSetIndent(1);
    Icb_DataCounter_Print(ThisPtr->counter);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("dateTime" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->dateTime);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMDataCounter_Response_Decode(Icb_OpPSIMDataCounter_Response ThisPtr, ASN_Session session,
                                                 ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_DataCounterValue_Decode(&ThisPtr->byteCount, session, stream));
    ASN_DECODE_CHECK(Icb_DataCounter_Decode(&ThisPtr->counter, session, stream));
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->dateTime, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMDataCounter_Response_Encode(Icb_OpPSIMDataCounter_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_DataCounterValue_Encode(ThisPtr->byteCount, stream));
    ASN_ENCODE_CHECK(Icb_DataCounter_Encode(ThisPtr->counter, stream));
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->dateTime, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMDataCounter_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMNetworkConfiguration_SetRequest of type ASNSequence
 */

Icb_OpPSIMNetworkConfiguration_SetRequest Icb_OpPSIMNetworkConfiguration_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMNetworkConfiguration_SetRequest value = (Icb_OpPSIMNetworkConfiguration_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMNetworkConfiguration_SetRequest_t));
    if (value != (Icb_OpPSIMNetworkConfiguration_SetRequest)NULL) {
        value->selection = Icb_APNSelection_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMNetworkConfiguration_SetRequest_EncodedSize(Icb_OpPSIMNetworkConfiguration_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_APNSelection_EncodedSize(ThisPtr->selection);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMNetworkConfiguration_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMNetworkConfiguration_SetRequest_t);
    length += Icb_APNSelection_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMNetworkConfiguration_SetRequest_Print(Icb_OpPSIMNetworkConfiguration_SetRequest ThisPtr) {
    ASN_PrintIndented("selection" EOL);
    ASN_PrintSetIndent(1);
    Icb_APNSelection_Print(ThisPtr->selection);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMNetworkConfiguration_SetRequest_Decode(Icb_OpPSIMNetworkConfiguration_SetRequest ThisPtr,
                                                            ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_APNSelection_Decode(ThisPtr->selection, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMNetworkConfiguration_SetRequest_Encode(Icb_OpPSIMNetworkConfiguration_SetRequest ThisPtr,
                                                            ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_APNSelection_Encode(ThisPtr->selection, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMNetworkConfiguration_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMNetworkConfiguration_Response of type ASNSequence
 */

Icb_OpPSIMNetworkConfiguration_Response Icb_OpPSIMNetworkConfiguration_Response_Create(ASN_Session session) {
    Icb_OpPSIMNetworkConfiguration_Response value = (Icb_OpPSIMNetworkConfiguration_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMNetworkConfiguration_Response_t));
    if (value != (Icb_OpPSIMNetworkConfiguration_Response)NULL) {
        value->selection = Icb_APNSelection_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMNetworkConfiguration_Response_EncodedSize(Icb_OpPSIMNetworkConfiguration_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_APNSelection_EncodedSize(ThisPtr->selection);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMNetworkConfiguration_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMNetworkConfiguration_Response_t);
    length += Icb_APNSelection_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMNetworkConfiguration_Response_Print(Icb_OpPSIMNetworkConfiguration_Response ThisPtr) {
    ASN_PrintIndented("selection" EOL);
    ASN_PrintSetIndent(1);
    Icb_APNSelection_Print(ThisPtr->selection);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMNetworkConfiguration_Response_Decode(Icb_OpPSIMNetworkConfiguration_Response ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_APNSelection_Decode(ThisPtr->selection, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMNetworkConfiguration_Response_Encode(Icb_OpPSIMNetworkConfiguration_Response ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_APNSelection_Encode(ThisPtr->selection, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMNetworkConfiguration_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMConnectionStatus_Response of type ASNSequence
 */

Icb_OpPSIMConnectionStatus_Response Icb_OpPSIMConnectionStatus_Response_Create(ASN_Session session) {
    Icb_OpPSIMConnectionStatus_Response value = (Icb_OpPSIMConnectionStatus_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMConnectionStatus_Response_t));
    if (value != (Icb_OpPSIMConnectionStatus_Response)NULL) {
        value->status = 0;
        value->technology = 0;
    }
    return value;
}

U32 Icb_OpPSIMConnectionStatus_Response_EncodedSize(Icb_OpPSIMConnectionStatus_Response ThisPtr) {
    U32 length = 0;
    length += Icb_PSIMConnectionStatus_EncodedSize(ThisPtr->status);
    length += Icb_WirelessTechnology_EncodedSize(ThisPtr->technology);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMConnectionStatus_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMConnectionStatus_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMConnectionStatus_Response_Print(Icb_OpPSIMConnectionStatus_Response ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_PSIMConnectionStatus_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("technology" EOL);
    ASN_PrintSetIndent(1);
    Icb_WirelessTechnology_Print(ThisPtr->technology);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMConnectionStatus_Response_Decode(Icb_OpPSIMConnectionStatus_Response ThisPtr, ASN_Session session,
                                                      ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_PSIMConnectionStatus_Decode(&ThisPtr->status, session, stream));
    ASN_DECODE_CHECK(Icb_WirelessTechnology_Decode(&ThisPtr->technology, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMConnectionStatus_Response_Encode(Icb_OpPSIMConnectionStatus_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_PSIMConnectionStatus_Encode(ThisPtr->status, stream));
    ASN_ENCODE_CHECK(Icb_WirelessTechnology_Encode(ThisPtr->technology, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMConnectionStatus_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMConnectionStatus_Notification of type ASNSequence
 */

Icb_OpPSIMConnectionStatus_Notification Icb_OpPSIMConnectionStatus_Notification_Create(ASN_Session session) {
    Icb_OpPSIMConnectionStatus_Notification value = (Icb_OpPSIMConnectionStatus_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMConnectionStatus_Notification_t));
    if (value != (Icb_OpPSIMConnectionStatus_Notification)NULL) {
        value->status = 0;
        value->technology = 0;
    }
    return value;
}

U32 Icb_OpPSIMConnectionStatus_Notification_EncodedSize(Icb_OpPSIMConnectionStatus_Notification ThisPtr) {
    U32 length = 0;
    length += Icb_PSIMConnectionStatus_EncodedSize(ThisPtr->status);
    length += Icb_WirelessTechnology_EncodedSize(ThisPtr->technology);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMConnectionStatus_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMConnectionStatus_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMConnectionStatus_Notification_Print(Icb_OpPSIMConnectionStatus_Notification ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_PSIMConnectionStatus_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("technology" EOL);
    ASN_PrintSetIndent(1);
    Icb_WirelessTechnology_Print(ThisPtr->technology);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMConnectionStatus_Notification_Decode(Icb_OpPSIMConnectionStatus_Notification ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_PSIMConnectionStatus_Decode(&ThisPtr->status, session, stream));
    ASN_DECODE_CHECK(Icb_WirelessTechnology_Decode(&ThisPtr->technology, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMConnectionStatus_Notification_Encode(Icb_OpPSIMConnectionStatus_Notification ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_PSIMConnectionStatus_Encode(ThisPtr->status, stream));
    ASN_ENCODE_CHECK(Icb_WirelessTechnology_Encode(ThisPtr->technology, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMConnectionStatus_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpInternetGateway_SetRequest of type ASNSequence
 */

Icb_OpInternetGateway_SetRequest Icb_OpInternetGateway_SetRequest_Create(ASN_Session session) {
    Icb_OpInternetGateway_SetRequest value =
            (Icb_OpInternetGateway_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpInternetGateway_SetRequest_t));
    if (value != (Icb_OpInternetGateway_SetRequest)NULL) {
        value->internetGateway = 0;
    }
    return value;
}

U32 Icb_OpInternetGateway_SetRequest_EncodedSize(Icb_OpInternetGateway_SetRequest ThisPtr) {
    U32 length = 0;
    length += Icb_Ecu_EncodedSize(ThisPtr->internetGateway);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpInternetGateway_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpInternetGateway_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpInternetGateway_SetRequest_Print(Icb_OpInternetGateway_SetRequest ThisPtr) {
    ASN_PrintIndented("internetGateway" EOL);
    ASN_PrintSetIndent(1);
    Icb_Ecu_Print(ThisPtr->internetGateway);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpInternetGateway_SetRequest_Decode(Icb_OpInternetGateway_SetRequest ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_Ecu_Decode(&ThisPtr->internetGateway, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpInternetGateway_SetRequest_Encode(Icb_OpInternetGateway_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_Ecu_Encode(ThisPtr->internetGateway, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpInternetGateway_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpInternetGateway_Response of type ASNSequence
 */

Icb_OpInternetGateway_Response Icb_OpInternetGateway_Response_Create(ASN_Session session) {
    Icb_OpInternetGateway_Response value =
            (Icb_OpInternetGateway_Response)ASN_Malloc(session, sizeof(struct Icb_OpInternetGateway_Response_t));
    if (value != (Icb_OpInternetGateway_Response)NULL) {
        value->internetGateway = 0;
    }
    return value;
}

U32 Icb_OpInternetGateway_Response_EncodedSize(Icb_OpInternetGateway_Response ThisPtr) {
    U32 length = 0;
    length += Icb_Ecu_EncodedSize(ThisPtr->internetGateway);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpInternetGateway_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpInternetGateway_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpInternetGateway_Response_Print(Icb_OpInternetGateway_Response ThisPtr) {
    ASN_PrintIndented("internetGateway" EOL);
    ASN_PrintSetIndent(1);
    Icb_Ecu_Print(ThisPtr->internetGateway);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpInternetGateway_Response_Decode(Icb_OpInternetGateway_Response ThisPtr, ASN_Session session,
                                                 ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_Ecu_Decode(&ThisPtr->internetGateway, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpInternetGateway_Response_Encode(Icb_OpInternetGateway_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_Ecu_Encode(ThisPtr->internetGateway, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpInternetGateway_Response of type ASNSequence
 */

/*
 * Start of Icb_OpConnectWorkshopWlan_Notification of type ASNSequence
 */

Icb_OpConnectWorkshopWlan_Notification Icb_OpConnectWorkshopWlan_Notification_Create(ASN_Session session) {
    Icb_OpConnectWorkshopWlan_Notification value = (Icb_OpConnectWorkshopWlan_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpConnectWorkshopWlan_Notification_t));
    if (value != (Icb_OpConnectWorkshopWlan_Notification)NULL) {
        value->connectionResult = 0;
    }
    return value;
}

U32 Icb_OpConnectWorkshopWlan_Notification_EncodedSize(Icb_OpConnectWorkshopWlan_Notification ThisPtr) {
    U32 length = 0;
    length += Icb_WorkshopWlanConnectionResult_EncodedSize(ThisPtr->connectionResult);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpConnectWorkshopWlan_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpConnectWorkshopWlan_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpConnectWorkshopWlan_Notification_Print(Icb_OpConnectWorkshopWlan_Notification ThisPtr) {
    ASN_PrintIndented("connectionResult" EOL);
    ASN_PrintSetIndent(1);
    Icb_WorkshopWlanConnectionResult_Print(ThisPtr->connectionResult);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpConnectWorkshopWlan_Notification_Decode(Icb_OpConnectWorkshopWlan_Notification ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_WorkshopWlanConnectionResult_Decode(&ThisPtr->connectionResult, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpConnectWorkshopWlan_Notification_Encode(Icb_OpConnectWorkshopWlan_Notification ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_WorkshopWlanConnectionResult_Encode(ThisPtr->connectionResult, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpConnectWorkshopWlan_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpCurrentInternetSource_SetRequest of type ASNSequence
 */

Icb_OpCurrentInternetSource_SetRequest Icb_OpCurrentInternetSource_SetRequest_Create(ASN_Session session) {
    Icb_OpCurrentInternetSource_SetRequest value = (Icb_OpCurrentInternetSource_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpCurrentInternetSource_SetRequest_t));
    if (value != (Icb_OpCurrentInternetSource_SetRequest)NULL) {
        value->currentinternetsource = 0;
    }
    return value;
}

U32 Icb_OpCurrentInternetSource_SetRequest_EncodedSize(Icb_OpCurrentInternetSource_SetRequest ThisPtr) {
    U32 length = 0;
    length += Icb_InternetSource_EncodedSize(ThisPtr->currentinternetsource);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCurrentInternetSource_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpCurrentInternetSource_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCurrentInternetSource_SetRequest_Print(Icb_OpCurrentInternetSource_SetRequest ThisPtr) {
    ASN_PrintIndented("currentinternetsource" EOL);
    ASN_PrintSetIndent(1);
    Icb_InternetSource_Print(ThisPtr->currentinternetsource);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCurrentInternetSource_SetRequest_Decode(Icb_OpCurrentInternetSource_SetRequest ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_InternetSource_Decode(&ThisPtr->currentinternetsource, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCurrentInternetSource_SetRequest_Encode(Icb_OpCurrentInternetSource_SetRequest ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_InternetSource_Encode(ThisPtr->currentinternetsource, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCurrentInternetSource_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpCurrentInternetSource_Response of type ASNSequence
 */

Icb_OpCurrentInternetSource_Response Icb_OpCurrentInternetSource_Response_Create(ASN_Session session) {
    Icb_OpCurrentInternetSource_Response value = (Icb_OpCurrentInternetSource_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpCurrentInternetSource_Response_t));
    if (value != (Icb_OpCurrentInternetSource_Response)NULL) {
        value->currentinternetsource = 0;
    }
    return value;
}

U32 Icb_OpCurrentInternetSource_Response_EncodedSize(Icb_OpCurrentInternetSource_Response ThisPtr) {
    U32 length = 0;
    length += Icb_InternetSource_EncodedSize(ThisPtr->currentinternetsource);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCurrentInternetSource_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpCurrentInternetSource_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCurrentInternetSource_Response_Print(Icb_OpCurrentInternetSource_Response ThisPtr) {
    ASN_PrintIndented("currentinternetsource" EOL);
    ASN_PrintSetIndent(1);
    Icb_InternetSource_Print(ThisPtr->currentinternetsource);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCurrentInternetSource_Response_Decode(Icb_OpCurrentInternetSource_Response ThisPtr,
                                                       ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_InternetSource_Decode(&ThisPtr->currentinternetsource, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCurrentInternetSource_Response_Encode(Icb_OpCurrentInternetSource_Response ThisPtr,
                                                       ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_InternetSource_Encode(ThisPtr->currentinternetsource, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCurrentInternetSource_Response of type ASNSequence
 */

/*
 * Start of Icb_OpCurrentInternetSource_Notification of type ASNSequence
 */

Icb_OpCurrentInternetSource_Notification Icb_OpCurrentInternetSource_Notification_Create(ASN_Session session) {
    Icb_OpCurrentInternetSource_Notification value = (Icb_OpCurrentInternetSource_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpCurrentInternetSource_Notification_t));
    if (value != (Icb_OpCurrentInternetSource_Notification)NULL) {
        value->currentinternetsource = 0;
    }
    return value;
}

U32 Icb_OpCurrentInternetSource_Notification_EncodedSize(Icb_OpCurrentInternetSource_Notification ThisPtr) {
    U32 length = 0;
    length += Icb_InternetSource_EncodedSize(ThisPtr->currentinternetsource);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCurrentInternetSource_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpCurrentInternetSource_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCurrentInternetSource_Notification_Print(Icb_OpCurrentInternetSource_Notification ThisPtr) {
    ASN_PrintIndented("currentinternetsource" EOL);
    ASN_PrintSetIndent(1);
    Icb_InternetSource_Print(ThisPtr->currentinternetsource);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCurrentInternetSource_Notification_Decode(Icb_OpCurrentInternetSource_Notification ThisPtr,
                                                           ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_InternetSource_Decode(&ThisPtr->currentinternetsource, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCurrentInternetSource_Notification_Encode(Icb_OpCurrentInternetSource_Notification ThisPtr,
                                                           ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_InternetSource_Encode(ThisPtr->currentinternetsource, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCurrentInternetSource_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpWLANMode_SetRequest of type ASNSequence
 */

Icb_OpWLANMode_SetRequest Icb_OpWLANMode_SetRequest_Create(ASN_Session session) {
    Icb_OpWLANMode_SetRequest value =
            (Icb_OpWLANMode_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpWLANMode_SetRequest_t));
    if (value != (Icb_OpWLANMode_SetRequest)NULL) {
        value->wLANMode = 0;
    }
    return value;
}

U32 Icb_OpWLANMode_SetRequest_EncodedSize(Icb_OpWLANMode_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANMode_EncodedSize(ThisPtr->wLANMode);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANMode_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANMode_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANMode_SetRequest_Print(Icb_OpWLANMode_SetRequest ThisPtr) {
    ASN_PrintIndented("wLANMode" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANMode_Print(ThisPtr->wLANMode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANMode_SetRequest_Decode(Icb_OpWLANMode_SetRequest ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANMode_Decode(&ThisPtr->wLANMode, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANMode_SetRequest_Encode(Icb_OpWLANMode_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANMode_Encode(ThisPtr->wLANMode, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANMode_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpWLANMode_Response of type ASNSequence
 */

Icb_OpWLANMode_Response Icb_OpWLANMode_Response_Create(ASN_Session session) {
    Icb_OpWLANMode_Response value =
            (Icb_OpWLANMode_Response)ASN_Malloc(session, sizeof(struct Icb_OpWLANMode_Response_t));
    if (value != (Icb_OpWLANMode_Response)NULL) {
        value->wLANMode = 0;
    }
    return value;
}

U32 Icb_OpWLANMode_Response_EncodedSize(Icb_OpWLANMode_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANMode_EncodedSize(ThisPtr->wLANMode);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANMode_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANMode_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANMode_Response_Print(Icb_OpWLANMode_Response ThisPtr) {
    ASN_PrintIndented("wLANMode" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANMode_Print(ThisPtr->wLANMode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANMode_Response_Decode(Icb_OpWLANMode_Response ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANMode_Decode(&ThisPtr->wLANMode, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANMode_Response_Encode(Icb_OpWLANMode_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANMode_Encode(ThisPtr->wLANMode, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANMode_Response of type ASNSequence
 */

/*
 * Start of Icb_OpWLANMode_Notification of type ASNSequence
 */

Icb_OpWLANMode_Notification Icb_OpWLANMode_Notification_Create(ASN_Session session) {
    Icb_OpWLANMode_Notification value =
            (Icb_OpWLANMode_Notification)ASN_Malloc(session, sizeof(struct Icb_OpWLANMode_Notification_t));
    if (value != (Icb_OpWLANMode_Notification)NULL) {
        value->wLANMode = 0;
    }
    return value;
}

U32 Icb_OpWLANMode_Notification_EncodedSize(Icb_OpWLANMode_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANMode_EncodedSize(ThisPtr->wLANMode);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANMode_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANMode_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANMode_Notification_Print(Icb_OpWLANMode_Notification ThisPtr) {
    ASN_PrintIndented("wLANMode" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANMode_Print(ThisPtr->wLANMode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANMode_Notification_Decode(Icb_OpWLANMode_Notification ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANMode_Decode(&ThisPtr->wLANMode, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANMode_Notification_Encode(Icb_OpWLANMode_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANMode_Encode(ThisPtr->wLANMode, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANMode_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpWLANFreqBandSelect_SetRequest of type ASNSequence
 */

Icb_OpWLANFreqBandSelect_SetRequest Icb_OpWLANFreqBandSelect_SetRequest_Create(ASN_Session session) {
    Icb_OpWLANFreqBandSelect_SetRequest value = (Icb_OpWLANFreqBandSelect_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpWLANFreqBandSelect_SetRequest_t));
    if (value != (Icb_OpWLANFreqBandSelect_SetRequest)NULL) {
        value->wLANNewFrequencyBand = 0;
    }
    return value;
}

U32 Icb_OpWLANFreqBandSelect_SetRequest_EncodedSize(Icb_OpWLANFreqBandSelect_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANFrequencyBand_EncodedSize(ThisPtr->wLANNewFrequencyBand);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANFreqBandSelect_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANFreqBandSelect_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANFreqBandSelect_SetRequest_Print(Icb_OpWLANFreqBandSelect_SetRequest ThisPtr) {
    ASN_PrintIndented("wLANNewFrequencyBand" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANFrequencyBand_Print(ThisPtr->wLANNewFrequencyBand);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANFreqBandSelect_SetRequest_Decode(Icb_OpWLANFreqBandSelect_SetRequest ThisPtr, ASN_Session session,
                                                      ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANFrequencyBand_Decode(&ThisPtr->wLANNewFrequencyBand, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANFreqBandSelect_SetRequest_Encode(Icb_OpWLANFreqBandSelect_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANFrequencyBand_Encode(ThisPtr->wLANNewFrequencyBand, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANFreqBandSelect_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpWLANFreqBandSelect_Response of type ASNSequence
 */

Icb_OpWLANFreqBandSelect_Response Icb_OpWLANFreqBandSelect_Response_Create(ASN_Session session) {
    Icb_OpWLANFreqBandSelect_Response value =
            (Icb_OpWLANFreqBandSelect_Response)ASN_Malloc(session, sizeof(struct Icb_OpWLANFreqBandSelect_Response_t));
    if (value != (Icb_OpWLANFreqBandSelect_Response)NULL) {
        value->wLANCurrentFrequencyBand = 0;
        value->availableFrequencyList = Icb_ArrayOf_WLANFrequencyBand_Create(session);
    }
    return value;
}

U32 Icb_OpWLANFreqBandSelect_Response_EncodedSize(Icb_OpWLANFreqBandSelect_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANFrequencyBand_EncodedSize(ThisPtr->wLANCurrentFrequencyBand);
    length += Icb_ArrayOf_WLANFrequencyBand_EncodedSize(ThisPtr->availableFrequencyList, 0, 1);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANFreqBandSelect_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANFreqBandSelect_Response_t);
    length += Icb_ArrayOf_WLANFrequencyBand_SessionSize(0, 1);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANFreqBandSelect_Response_Print(Icb_OpWLANFreqBandSelect_Response ThisPtr) {
    ASN_PrintIndented("wLANCurrentFrequencyBand" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANFrequencyBand_Print(ThisPtr->wLANCurrentFrequencyBand);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("availableFrequencyList" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_WLANFrequencyBand_Print(ThisPtr->availableFrequencyList);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANFreqBandSelect_Response_Decode(Icb_OpWLANFreqBandSelect_Response ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANFrequencyBand_Decode(&ThisPtr->wLANCurrentFrequencyBand, session, stream));
    ASN_DECODE_CHECK(Icb_ArrayOf_WLANFrequencyBand_Decode(ThisPtr->availableFrequencyList, session, stream, 0, 1));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANFreqBandSelect_Response_Encode(Icb_OpWLANFreqBandSelect_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANFrequencyBand_Encode(ThisPtr->wLANCurrentFrequencyBand, stream));
    ASN_ENCODE_CHECK(Icb_ArrayOf_WLANFrequencyBand_Encode(ThisPtr->availableFrequencyList, stream, 0, 1));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANFreqBandSelect_Response of type ASNSequence
 */

/*
 * Start of Icb_WLANChannelInfo of type ASNSequence
 */

Icb_WLANChannelInfo Icb_WLANChannelInfo_Create(ASN_Session session) {
    Icb_WLANChannelInfo value = (Icb_WLANChannelInfo)ASN_Malloc(session, sizeof(struct Icb_WLANChannelInfo_t));
    if (value != (Icb_WLANChannelInfo)NULL) {
        value->wlan24GhzChannelNumber = 0;
        value->wLANChWidth = 0;
    }
    return value;
}

U32 Icb_WLANChannelInfo_EncodedSize(Icb_WLANChannelInfo ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->wlan24GhzChannelNumber, 0, 14);
    length += Icb_WLANChannelWidthData_EncodedSize(ThisPtr->wLANChWidth);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_WLANChannelInfo_SessionSize() {
    U32 length = sizeof(struct Icb_WLANChannelInfo_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_WLANChannelInfo_Print(Icb_WLANChannelInfo ThisPtr) {
    ASN_PrintIndented("wlan24GhzChannelNumber" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->wlan24GhzChannelNumber);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("wLANChWidth" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANChannelWidthData_Print(ThisPtr->wLANChWidth);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_WLANChannelInfo_Decode(Icb_WLANChannelInfo ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->wlan24GhzChannelNumber, session, stream, 0, 14));
    ASN_DECODE_CHECK(Icb_WLANChannelWidthData_Decode(&ThisPtr->wLANChWidth, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_WLANChannelInfo_Encode(Icb_WLANChannelInfo ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->wlan24GhzChannelNumber, stream, 0, 14));
    ASN_ENCODE_CHECK(Icb_WLANChannelWidthData_Encode(ThisPtr->wLANChWidth, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_WLANChannelInfo of type ASNSequence
 */

/*
 * Start of Icb_OpWLANAPSSID_SetRequest of type ASNSequence
 */

Icb_OpWLANAPSSID_SetRequest Icb_OpWLANAPSSID_SetRequest_Create(ASN_Session session) {
    Icb_OpWLANAPSSID_SetRequest value =
            (Icb_OpWLANAPSSID_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpWLANAPSSID_SetRequest_t));
    if (value != (Icb_OpWLANAPSSID_SetRequest)NULL) {
        value->wLANnewSSID = Icb_SSID_Create(session);
    }
    return value;
}

U32 Icb_OpWLANAPSSID_SetRequest_EncodedSize(Icb_OpWLANAPSSID_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SSID_EncodedSize(ThisPtr->wLANnewSSID);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANAPSSID_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANAPSSID_SetRequest_t);
    length += Icb_SSID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANAPSSID_SetRequest_Print(Icb_OpWLANAPSSID_SetRequest ThisPtr) {
    ASN_PrintIndented("wLANnewSSID" EOL);
    ASN_PrintSetIndent(1);
    Icb_SSID_Print(ThisPtr->wLANnewSSID);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANAPSSID_SetRequest_Decode(Icb_OpWLANAPSSID_SetRequest ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->wLANnewSSID, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANAPSSID_SetRequest_Encode(Icb_OpWLANAPSSID_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->wLANnewSSID, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANAPSSID_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpWLANAPSSID_Response of type ASNSequence
 */

Icb_OpWLANAPSSID_Response Icb_OpWLANAPSSID_Response_Create(ASN_Session session) {
    Icb_OpWLANAPSSID_Response value =
            (Icb_OpWLANAPSSID_Response)ASN_Malloc(session, sizeof(struct Icb_OpWLANAPSSID_Response_t));
    if (value != (Icb_OpWLANAPSSID_Response)NULL) {
        value->wLANcurrentSSID = Icb_SSID_Create(session);
    }
    return value;
}

U32 Icb_OpWLANAPSSID_Response_EncodedSize(Icb_OpWLANAPSSID_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SSID_EncodedSize(ThisPtr->wLANcurrentSSID);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANAPSSID_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANAPSSID_Response_t);
    length += Icb_SSID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANAPSSID_Response_Print(Icb_OpWLANAPSSID_Response ThisPtr) {
    ASN_PrintIndented("wLANcurrentSSID" EOL);
    ASN_PrintSetIndent(1);
    Icb_SSID_Print(ThisPtr->wLANcurrentSSID);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANAPSSID_Response_Decode(Icb_OpWLANAPSSID_Response ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->wLANcurrentSSID, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANAPSSID_Response_Encode(Icb_OpWLANAPSSID_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->wLANcurrentSSID, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANAPSSID_Response of type ASNSequence
 */

/*
 * Start of Icb_OpWLANAPPasswd_SetRequest of type ASNSequence
 */

Icb_OpWLANAPPasswd_SetRequest Icb_OpWLANAPPasswd_SetRequest_Create(ASN_Session session) {
    Icb_OpWLANAPPasswd_SetRequest value =
            (Icb_OpWLANAPPasswd_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpWLANAPPasswd_SetRequest_t));
    if (value != (Icb_OpWLANAPPasswd_SetRequest)NULL) {
        value->wLANNewPassword = Icb_WLAN_Password_Create(session);
    }
    return value;
}

U32 Icb_OpWLANAPPasswd_SetRequest_EncodedSize(Icb_OpWLANAPPasswd_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLAN_Password_EncodedSize(ThisPtr->wLANNewPassword);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANAPPasswd_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANAPPasswd_SetRequest_t);
    length += Icb_WLAN_Password_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANAPPasswd_SetRequest_Print(Icb_OpWLANAPPasswd_SetRequest ThisPtr) {
    ASN_PrintIndented("wLANNewPassword" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLAN_Password_Print(ThisPtr->wLANNewPassword);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANAPPasswd_SetRequest_Decode(Icb_OpWLANAPPasswd_SetRequest ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLAN_Password_Decode(ThisPtr->wLANNewPassword, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANAPPasswd_SetRequest_Encode(Icb_OpWLANAPPasswd_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLAN_Password_Encode(ThisPtr->wLANNewPassword, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANAPPasswd_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpWLANAPPasswd_Response of type ASNSequence
 */

Icb_OpWLANAPPasswd_Response Icb_OpWLANAPPasswd_Response_Create(ASN_Session session) {
    Icb_OpWLANAPPasswd_Response value =
            (Icb_OpWLANAPPasswd_Response)ASN_Malloc(session, sizeof(struct Icb_OpWLANAPPasswd_Response_t));
    if (value != (Icb_OpWLANAPPasswd_Response)NULL) {
        value->wLANCurrentPassword = Icb_WLAN_Password_Create(session);
    }
    return value;
}

U32 Icb_OpWLANAPPasswd_Response_EncodedSize(Icb_OpWLANAPPasswd_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLAN_Password_EncodedSize(ThisPtr->wLANCurrentPassword);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANAPPasswd_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANAPPasswd_Response_t);
    length += Icb_WLAN_Password_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANAPPasswd_Response_Print(Icb_OpWLANAPPasswd_Response ThisPtr) {
    ASN_PrintIndented("wLANCurrentPassword" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLAN_Password_Print(ThisPtr->wLANCurrentPassword);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANAPPasswd_Response_Decode(Icb_OpWLANAPPasswd_Response ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLAN_Password_Decode(ThisPtr->wLANCurrentPassword, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANAPPasswd_Response_Encode(Icb_OpWLANAPPasswd_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLAN_Password_Encode(ThisPtr->wLANCurrentPassword, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANAPPasswd_Response of type ASNSequence
 */

/*
 * Start of Icb_OpWLANAPConnDev_Response of type ASNSequence
 */

Icb_OpWLANAPConnDev_Response Icb_OpWLANAPConnDev_Response_Create(ASN_Session session) {
    Icb_OpWLANAPConnDev_Response value =
            (Icb_OpWLANAPConnDev_Response)ASN_Malloc(session, sizeof(struct Icb_OpWLANAPConnDev_Response_t));
    if (value != (Icb_OpWLANAPConnDev_Response)NULL) {
        value->wLANCurrentConnDevices = Icb_ArrayOf_WLANConnDevice_Create(session);
    }
    return value;
}

U32 Icb_OpWLANAPConnDev_Response_EncodedSize(Icb_OpWLANAPConnDev_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_WLANConnDevice_EncodedSize(ThisPtr->wLANCurrentConnDevices, 0, 8);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANAPConnDev_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANAPConnDev_Response_t);
    length += Icb_ArrayOf_WLANConnDevice_SessionSize(0, 8);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANAPConnDev_Response_Print(Icb_OpWLANAPConnDev_Response ThisPtr) {
    ASN_PrintIndented("wLANCurrentConnDevices" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_WLANConnDevice_Print(ThisPtr->wLANCurrentConnDevices);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANAPConnDev_Response_Decode(Icb_OpWLANAPConnDev_Response ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_WLANConnDevice_Decode(ThisPtr->wLANCurrentConnDevices, session, stream, 0, 8));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANAPConnDev_Response_Encode(Icb_OpWLANAPConnDev_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_WLANConnDevice_Encode(ThisPtr->wLANCurrentConnDevices, stream, 0, 8));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANAPConnDev_Response of type ASNSequence
 */

/*
 * Start of Icb_OpWLANAPConnDev_Notification of type ASNSequence
 */

Icb_OpWLANAPConnDev_Notification Icb_OpWLANAPConnDev_Notification_Create(ASN_Session session) {
    Icb_OpWLANAPConnDev_Notification value =
            (Icb_OpWLANAPConnDev_Notification)ASN_Malloc(session, sizeof(struct Icb_OpWLANAPConnDev_Notification_t));
    if (value != (Icb_OpWLANAPConnDev_Notification)NULL) {
        value->wLANCurrentConnDevices = Icb_ArrayOf_WLANConnDevice_Create(session);
    }
    return value;
}

U32 Icb_OpWLANAPConnDev_Notification_EncodedSize(Icb_OpWLANAPConnDev_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_WLANConnDevice_EncodedSize(ThisPtr->wLANCurrentConnDevices, 0, 8);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANAPConnDev_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANAPConnDev_Notification_t);
    length += Icb_ArrayOf_WLANConnDevice_SessionSize(0, 8);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANAPConnDev_Notification_Print(Icb_OpWLANAPConnDev_Notification ThisPtr) {
    ASN_PrintIndented("wLANCurrentConnDevices" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_WLANConnDevice_Print(ThisPtr->wLANCurrentConnDevices);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANAPConnDev_Notification_Decode(Icb_OpWLANAPConnDev_Notification ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_WLANConnDevice_Decode(ThisPtr->wLANCurrentConnDevices, session, stream, 0, 8));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANAPConnDev_Notification_Encode(Icb_OpWLANAPConnDev_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_WLANConnDevice_Encode(ThisPtr->wLANCurrentConnDevices, stream, 0, 8));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANAPConnDev_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpWLANSTAConnect_SetRequest of type ASNSequence
 */

Icb_OpWLANSTAConnect_SetRequest Icb_OpWLANSTAConnect_SetRequest_Create(ASN_Session session) {
    Icb_OpWLANSTAConnect_SetRequest value =
            (Icb_OpWLANSTAConnect_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpWLANSTAConnect_SetRequest_t));
    if (value != (Icb_OpWLANSTAConnect_SetRequest)NULL) {
        value->wLANPassword = Icb_WLANExternalPassword_Create(session);
        value->newSSID = Icb_SSID_Create(session);
    }
    return value;
}

U32 Icb_OpWLANSTAConnect_SetRequest_EncodedSize(Icb_OpWLANSTAConnect_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANExternalPassword_EncodedSize(ThisPtr->wLANPassword);
    length += Icb_SSID_EncodedSize(ThisPtr->newSSID);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANSTAConnect_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANSTAConnect_SetRequest_t);
    length += Icb_WLANExternalPassword_SessionSize();
    length += Icb_SSID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANSTAConnect_SetRequest_Print(Icb_OpWLANSTAConnect_SetRequest ThisPtr) {
    ASN_PrintIndented("wLANPassword" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANExternalPassword_Print(ThisPtr->wLANPassword);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("newSSID" EOL);
    ASN_PrintSetIndent(1);
    Icb_SSID_Print(ThisPtr->newSSID);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANSTAConnect_SetRequest_Decode(Icb_OpWLANSTAConnect_SetRequest ThisPtr, ASN_Session session,
                                                  ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANExternalPassword_Decode(ThisPtr->wLANPassword, session, stream));
    ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->newSSID, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANSTAConnect_SetRequest_Encode(Icb_OpWLANSTAConnect_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANExternalPassword_Encode(ThisPtr->wLANPassword, stream));
    ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->newSSID, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANSTAConnect_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpWLANSTAConnect_Response of type ASNSequence
 */

Icb_OpWLANSTAConnect_Response Icb_OpWLANSTAConnect_Response_Create(ASN_Session session) {
    Icb_OpWLANSTAConnect_Response value =
            (Icb_OpWLANSTAConnect_Response)ASN_Malloc(session, sizeof(struct Icb_OpWLANSTAConnect_Response_t));
    if (value != (Icb_OpWLANSTAConnect_Response)NULL) {
        value->currentSSID = Icb_SSID_Create(session);
        value->wLANConnectStatus = 0;
    }
    return value;
}

U32 Icb_OpWLANSTAConnect_Response_EncodedSize(Icb_OpWLANSTAConnect_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SSID_EncodedSize(ThisPtr->currentSSID);
    length += Icb_WLANConnectStatus_EncodedSize(ThisPtr->wLANConnectStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANSTAConnect_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANSTAConnect_Response_t);
    length += Icb_SSID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANSTAConnect_Response_Print(Icb_OpWLANSTAConnect_Response ThisPtr) {
    ASN_PrintIndented("currentSSID" EOL);
    ASN_PrintSetIndent(1);
    Icb_SSID_Print(ThisPtr->currentSSID);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("wLANConnectStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANConnectStatus_Print(ThisPtr->wLANConnectStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANSTAConnect_Response_Decode(Icb_OpWLANSTAConnect_Response ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->currentSSID, session, stream));
    ASN_DECODE_CHECK(Icb_WLANConnectStatus_Decode(&ThisPtr->wLANConnectStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANSTAConnect_Response_Encode(Icb_OpWLANSTAConnect_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->currentSSID, stream));
    ASN_ENCODE_CHECK(Icb_WLANConnectStatus_Encode(ThisPtr->wLANConnectStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANSTAConnect_Response of type ASNSequence
 */

/*
 * Start of Icb_OpWLANAPStatusSettings_Response of type ASNSequence
 */

Icb_OpWLANAPStatusSettings_Response Icb_OpWLANAPStatusSettings_Response_Create(ASN_Session session) {
    Icb_OpWLANAPStatusSettings_Response value = (Icb_OpWLANAPStatusSettings_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpWLANAPStatusSettings_Response_t));
    if (value != (Icb_OpWLANAPStatusSettings_Response)NULL) {
        value->wLANAPCurrentStatus = 0;
        value->currentSSID = Icb_SSID_Create(session);
        value->currentPassword = Icb_WLAN_Password_Create(session);
        value->numberOfConnectedDevices = 0;
        value->currentUsedFrequencyBand = 0;
    }
    return value;
}

U32 Icb_OpWLANAPStatusSettings_Response_EncodedSize(Icb_OpWLANAPStatusSettings_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANAPCurrentStatus_EncodedSize(ThisPtr->wLANAPCurrentStatus);
    length += Icb_SSID_EncodedSize(ThisPtr->currentSSID);
    length += Icb_WLAN_Password_EncodedSize(ThisPtr->currentPassword);
    length += U32_EncodedSize(ThisPtr->numberOfConnectedDevices, 0, 8);
    length += Icb_WLANFrequencyBand_EncodedSize(ThisPtr->currentUsedFrequencyBand);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANAPStatusSettings_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANAPStatusSettings_Response_t);
    length += Icb_SSID_SessionSize();
    length += Icb_WLAN_Password_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANAPStatusSettings_Response_Print(Icb_OpWLANAPStatusSettings_Response ThisPtr) {
    ASN_PrintIndented("wLANAPCurrentStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANAPCurrentStatus_Print(ThisPtr->wLANAPCurrentStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("currentSSID" EOL);
    ASN_PrintSetIndent(1);
    Icb_SSID_Print(ThisPtr->currentSSID);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("currentPassword" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLAN_Password_Print(ThisPtr->currentPassword);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("numberOfConnectedDevices" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->numberOfConnectedDevices);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("currentUsedFrequencyBand" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANFrequencyBand_Print(ThisPtr->currentUsedFrequencyBand);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANAPStatusSettings_Response_Decode(Icb_OpWLANAPStatusSettings_Response ThisPtr, ASN_Session session,
                                                      ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANAPCurrentStatus_Decode(&ThisPtr->wLANAPCurrentStatus, session, stream));
    ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->currentSSID, session, stream));
    ASN_DECODE_CHECK(Icb_WLAN_Password_Decode(ThisPtr->currentPassword, session, stream));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->numberOfConnectedDevices, session, stream, 0, 8));
    ASN_DECODE_CHECK(Icb_WLANFrequencyBand_Decode(&ThisPtr->currentUsedFrequencyBand, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANAPStatusSettings_Response_Encode(Icb_OpWLANAPStatusSettings_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANAPCurrentStatus_Encode(ThisPtr->wLANAPCurrentStatus, stream));
    ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->currentSSID, stream));
    ASN_ENCODE_CHECK(Icb_WLAN_Password_Encode(ThisPtr->currentPassword, stream));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->numberOfConnectedDevices, stream, 0, 8));
    ASN_ENCODE_CHECK(Icb_WLANFrequencyBand_Encode(ThisPtr->currentUsedFrequencyBand, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANAPStatusSettings_Response of type ASNSequence
 */

/*
 * Start of Icb_OpWLANSTAStatus_Response of type ASNSequence
 */

Icb_OpWLANSTAStatus_Response Icb_OpWLANSTAStatus_Response_Create(ASN_Session session) {
    Icb_OpWLANSTAStatus_Response value =
            (Icb_OpWLANSTAStatus_Response)ASN_Malloc(session, sizeof(struct Icb_OpWLANSTAStatus_Response_t));
    if (value != (Icb_OpWLANSTAStatus_Response)NULL) {
        value->exists__optional__currentUsedSSID = 0;
        value->currentWLANSTAMode = 0;
        value->currentConnectionStatus = 0;
        value->currentUsedSSID = ASN_OctetString_Create(session);
        value->availableNetworkInfoList = Icb_ArrayOf_AvailableNetworkInformation_Create(session);
    }
    return value;
}

U32 Icb_OpWLANSTAStatus_Response_EncodedSize(Icb_OpWLANSTAStatus_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__currentUsedSSID);
    length += Icb_WLANMode_EncodedSize(ThisPtr->currentWLANSTAMode);
    length += Icb_WLANConnectionStatus_EncodedSize(ThisPtr->currentConnectionStatus);
    if (ThisPtr->exists__optional__currentUsedSSID == TRUE) {
        length += ASN_OctetString_EncodedSize(ThisPtr->currentUsedSSID, 0, 32);
    }
    length += Icb_ArrayOf_AvailableNetworkInformation_EncodedSize(ThisPtr->availableNetworkInfoList, 0, 100);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANSTAStatus_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANSTAStatus_Response_t);
    length += ASN_OctetString_SessionSize(0, 32);
    length += Icb_ArrayOf_AvailableNetworkInformation_SessionSize(0, 100);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANSTAStatus_Response_Print(Icb_OpWLANSTAStatus_Response ThisPtr) {
    ASN_PrintIndented("exists__optional__currentUsedSSID" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__currentUsedSSID);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("currentWLANSTAMode" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANMode_Print(ThisPtr->currentWLANSTAMode);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("currentConnectionStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANConnectionStatus_Print(ThisPtr->currentConnectionStatus);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__currentUsedSSID == TRUE) {
        ASN_PrintIndented("currentUsedSSID" EOL);
        ASN_PrintSetIndent(1);
        ASN_OctetString_Print(ThisPtr->currentUsedSSID);
        ASN_PrintSetIndent(-1);
    }
    ASN_PrintIndented("availableNetworkInfoList" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_AvailableNetworkInformation_Print(ThisPtr->availableNetworkInfoList);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANSTAStatus_Response_Decode(Icb_OpWLANSTAStatus_Response ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__currentUsedSSID, session, stream));
    ASN_DECODE_CHECK(Icb_WLANMode_Decode(&ThisPtr->currentWLANSTAMode, session, stream));
    ASN_DECODE_CHECK(Icb_WLANConnectionStatus_Decode(&ThisPtr->currentConnectionStatus, session, stream));
    if (ThisPtr->exists__optional__currentUsedSSID == TRUE) {
        ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->currentUsedSSID, session, stream, 0, 32));
    }
    ASN_DECODE_CHECK(
            Icb_ArrayOf_AvailableNetworkInformation_Decode(ThisPtr->availableNetworkInfoList, session, stream, 0, 100));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANSTAStatus_Response_Encode(Icb_OpWLANSTAStatus_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__currentUsedSSID, stream));
    ASN_ENCODE_CHECK(Icb_WLANMode_Encode(ThisPtr->currentWLANSTAMode, stream));
    ASN_ENCODE_CHECK(Icb_WLANConnectionStatus_Encode(ThisPtr->currentConnectionStatus, stream));
    if (ThisPtr->exists__optional__currentUsedSSID == TRUE) {
        ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->currentUsedSSID, stream, 0, 32));
    }
    ASN_ENCODE_CHECK(Icb_ArrayOf_AvailableNetworkInformation_Encode(ThisPtr->availableNetworkInfoList, stream, 0, 100));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANSTAStatus_Response of type ASNSequence
 */

/*
 * Start of Icb_OpWLANSTAStatus_Notification of type ASNSequence
 */

Icb_OpWLANSTAStatus_Notification Icb_OpWLANSTAStatus_Notification_Create(ASN_Session session) {
    Icb_OpWLANSTAStatus_Notification value =
            (Icb_OpWLANSTAStatus_Notification)ASN_Malloc(session, sizeof(struct Icb_OpWLANSTAStatus_Notification_t));
    if (value != (Icb_OpWLANSTAStatus_Notification)NULL) {
        value->notifyConnectionStatus = 0;
        value->availableNetworkInfoList = Icb_ArrayOf_AvailableNetworkInformation_Create(session);
    }
    return value;
}

U32 Icb_OpWLANSTAStatus_Notification_EncodedSize(Icb_OpWLANSTAStatus_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANConnectionStatus_EncodedSize(ThisPtr->notifyConnectionStatus);
    length += Icb_ArrayOf_AvailableNetworkInformation_EncodedSize(ThisPtr->availableNetworkInfoList, 0, 100);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANSTAStatus_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANSTAStatus_Notification_t);
    length += Icb_ArrayOf_AvailableNetworkInformation_SessionSize(0, 100);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANSTAStatus_Notification_Print(Icb_OpWLANSTAStatus_Notification ThisPtr) {
    ASN_PrintIndented("notifyConnectionStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANConnectionStatus_Print(ThisPtr->notifyConnectionStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("availableNetworkInfoList" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_AvailableNetworkInformation_Print(ThisPtr->availableNetworkInfoList);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANSTAStatus_Notification_Decode(Icb_OpWLANSTAStatus_Notification ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANConnectionStatus_Decode(&ThisPtr->notifyConnectionStatus, session, stream));
    ASN_DECODE_CHECK(
            Icb_ArrayOf_AvailableNetworkInformation_Decode(ThisPtr->availableNetworkInfoList, session, stream, 0, 100));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANSTAStatus_Notification_Encode(Icb_OpWLANSTAStatus_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANConnectionStatus_Encode(ThisPtr->notifyConnectionStatus, stream));
    ASN_ENCODE_CHECK(Icb_ArrayOf_AvailableNetworkInformation_Encode(ThisPtr->availableNetworkInfoList, stream, 0, 100));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANSTAStatus_Notification of type ASNSequence
 */

/*
 * Start of Icb_AvailableNetworkInformation of type ASNSequence
 */

Icb_AvailableNetworkInformation Icb_AvailableNetworkInformation_Create(ASN_Session session) {
    Icb_AvailableNetworkInformation value =
            (Icb_AvailableNetworkInformation)ASN_Malloc(session, sizeof(struct Icb_AvailableNetworkInformation_t));
    if (value != (Icb_AvailableNetworkInformation)NULL) {
        value->exists__default__rememberedSSID = 0;
        value->sSID = Icb_SSID_Create(session);
        value->signalStrength = 0;
        value->securityType = 0;
        value->rememberedSSID = false;
    }
    return value;
}

U32 Icb_AvailableNetworkInformation_EncodedSize(Icb_AvailableNetworkInformation ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__default__rememberedSSID);
    length += Icb_SSID_EncodedSize(ThisPtr->sSID);
    length += S32_EncodedSize(ThisPtr->signalStrength, -100, 0);
    length += Icb_WLANSecurityType_EncodedSize(ThisPtr->securityType);
    if (ThisPtr->exists__default__rememberedSSID == TRUE) {
        length += BOOL_EncodedSize(ThisPtr->rememberedSSID);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_AvailableNetworkInformation_SessionSize() {
    U32 length = sizeof(struct Icb_AvailableNetworkInformation_t);
    length += Icb_SSID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_AvailableNetworkInformation_Print(Icb_AvailableNetworkInformation ThisPtr) {
    ASN_PrintIndented("exists__default__rememberedSSID" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__default__rememberedSSID);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("sSID" EOL);
    ASN_PrintSetIndent(1);
    Icb_SSID_Print(ThisPtr->sSID);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("signalStrength" EOL);
    ASN_PrintSetIndent(1);
    S32_Print(ThisPtr->signalStrength);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("securityType" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANSecurityType_Print(ThisPtr->securityType);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__default__rememberedSSID == TRUE) {
        ASN_PrintIndented("rememberedSSID" EOL);
        ASN_PrintSetIndent(1);
        BOOL_Print(ThisPtr->rememberedSSID);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_AvailableNetworkInformation_Decode(Icb_AvailableNetworkInformation ThisPtr, ASN_Session session,
                                                  ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__default__rememberedSSID, session, stream));
    ASN_DECODE_CHECK(Icb_SSID_Decode(ThisPtr->sSID, session, stream));
    ASN_DECODE_CHECK(S32_Decode(&ThisPtr->signalStrength, session, stream, -100, 0));
    ASN_DECODE_CHECK(Icb_WLANSecurityType_Decode(&ThisPtr->securityType, session, stream));
    if (ThisPtr->exists__default__rememberedSSID == TRUE) {
        ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->rememberedSSID, session, stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_AvailableNetworkInformation_Encode(Icb_AvailableNetworkInformation ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__default__rememberedSSID, stream));
    ASN_ENCODE_CHECK(Icb_SSID_Encode(ThisPtr->sSID, stream));
    ASN_ENCODE_CHECK(S32_Encode(ThisPtr->signalStrength, stream, -100, 0));
    ASN_ENCODE_CHECK(Icb_WLANSecurityType_Encode(ThisPtr->securityType, stream));
    if (ThisPtr->exists__default__rememberedSSID == TRUE) {
        ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->rememberedSSID, stream));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_AvailableNetworkInformation of type ASNSequence
 */

/*
 * Start of Icb_OpWLANSTARememberedNetwks_Response of type ASNSequence
 */

Icb_OpWLANSTARememberedNetwks_Response Icb_OpWLANSTARememberedNetwks_Response_Create(ASN_Session session) {
    Icb_OpWLANSTARememberedNetwks_Response value = (Icb_OpWLANSTARememberedNetwks_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpWLANSTARememberedNetwks_Response_t));
    if (value != (Icb_OpWLANSTARememberedNetwks_Response)NULL) {
        value->wLANRememberedNetworksSSIDList = Icb_ArrayOf_SSID_Create(session);
    }
    return value;
}

U32 Icb_OpWLANSTARememberedNetwks_Response_EncodedSize(Icb_OpWLANSTARememberedNetwks_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_SSID_EncodedSize(ThisPtr->wLANRememberedNetworksSSIDList, 0, 50);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANSTARememberedNetwks_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANSTARememberedNetwks_Response_t);
    length += Icb_ArrayOf_SSID_SessionSize(0, 50);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANSTARememberedNetwks_Response_Print(Icb_OpWLANSTARememberedNetwks_Response ThisPtr) {
    ASN_PrintIndented("wLANRememberedNetworksSSIDList" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_SSID_Print(ThisPtr->wLANRememberedNetworksSSIDList);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANSTARememberedNetwks_Response_Decode(Icb_OpWLANSTARememberedNetwks_Response ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_SSID_Decode(ThisPtr->wLANRememberedNetworksSSIDList, session, stream, 0, 50));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANSTARememberedNetwks_Response_Encode(Icb_OpWLANSTARememberedNetwks_Response ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_SSID_Encode(ThisPtr->wLANRememberedNetworksSSIDList, stream, 0, 50));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANSTARememberedNetwks_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMSecurity_SetRequest of type ASNSequence
 */

Icb_OpPSIMSecurity_SetRequest Icb_OpPSIMSecurity_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMSecurity_SetRequest value =
            (Icb_OpPSIMSecurity_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpPSIMSecurity_SetRequest_t));
    if (value != (Icb_OpPSIMSecurity_SetRequest)NULL) {
        value->setting = 0;
        value->pin = Icb_PinCode_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMSecurity_SetRequest_EncodedSize(Icb_OpPSIMSecurity_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_SimSecuritySetting_EncodedSize(ThisPtr->setting);
    length += Icb_PinCode_EncodedSize(ThisPtr->pin);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMSecurity_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMSecurity_SetRequest_t);
    length += Icb_PinCode_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMSecurity_SetRequest_Print(Icb_OpPSIMSecurity_SetRequest ThisPtr) {
    ASN_PrintIndented("setting" EOL);
    ASN_PrintSetIndent(1);
    Icb_SimSecuritySetting_Print(ThisPtr->setting);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("pin" EOL);
    ASN_PrintSetIndent(1);
    Icb_PinCode_Print(ThisPtr->pin);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMSecurity_SetRequest_Decode(Icb_OpPSIMSecurity_SetRequest ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_SimSecuritySetting_Decode(&ThisPtr->setting, session, stream));
    ASN_DECODE_CHECK(Icb_PinCode_Decode(ThisPtr->pin, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMSecurity_SetRequest_Encode(Icb_OpPSIMSecurity_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_SimSecuritySetting_Encode(ThisPtr->setting, stream));
    ASN_ENCODE_CHECK(Icb_PinCode_Encode(ThisPtr->pin, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMSecurity_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMEnterCode_SetRequest of type ASNSequence
 */

Icb_OpPSIMEnterCode_SetRequest Icb_OpPSIMEnterCode_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMEnterCode_SetRequest value =
            (Icb_OpPSIMEnterCode_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpPSIMEnterCode_SetRequest_t));
    if (value != (Icb_OpPSIMEnterCode_SetRequest)NULL) {
        value->command = Icb_PinPukCommand_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMEnterCode_SetRequest_EncodedSize(Icb_OpPSIMEnterCode_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_PinPukCommand_EncodedSize(ThisPtr->command);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMEnterCode_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMEnterCode_SetRequest_t);
    length += Icb_PinPukCommand_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMEnterCode_SetRequest_Print(Icb_OpPSIMEnterCode_SetRequest ThisPtr) {
    ASN_PrintIndented("command" EOL);
    ASN_PrintSetIndent(1);
    Icb_PinPukCommand_Print(ThisPtr->command);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMEnterCode_SetRequest_Decode(Icb_OpPSIMEnterCode_SetRequest ThisPtr, ASN_Session session,
                                                 ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_PinPukCommand_Decode(ThisPtr->command, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMEnterCode_SetRequest_Encode(Icb_OpPSIMEnterCode_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_PinPukCommand_Encode(ThisPtr->command, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMEnterCode_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMRegisterState_Response of type ASNSequence
 */

Icb_OpPSIMRegisterState_Response Icb_OpPSIMRegisterState_Response_Create(ASN_Session session) {
    Icb_OpPSIMRegisterState_Response value =
            (Icb_OpPSIMRegisterState_Response)ASN_Malloc(session, sizeof(struct Icb_OpPSIMRegisterState_Response_t));
    if (value != (Icb_OpPSIMRegisterState_Response)NULL) {
        value->registerState = Icb_RegisterState_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMRegisterState_Response_EncodedSize(Icb_OpPSIMRegisterState_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_RegisterState_EncodedSize(ThisPtr->registerState);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMRegisterState_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMRegisterState_Response_t);
    length += Icb_RegisterState_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMRegisterState_Response_Print(Icb_OpPSIMRegisterState_Response ThisPtr) {
    ASN_PrintIndented("registerState" EOL);
    ASN_PrintSetIndent(1);
    Icb_RegisterState_Print(ThisPtr->registerState);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMRegisterState_Response_Decode(Icb_OpPSIMRegisterState_Response ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_RegisterState_Decode(ThisPtr->registerState, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMRegisterState_Response_Encode(Icb_OpPSIMRegisterState_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_RegisterState_Encode(ThisPtr->registerState, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMRegisterState_Response of type ASNSequence
 */

/*
 * Start of Icb_NetworkOperator of type ASNSequence
 */

Icb_NetworkOperator Icb_NetworkOperator_Create(ASN_Session session) {
    Icb_NetworkOperator value = (Icb_NetworkOperator)ASN_Malloc(session, sizeof(struct Icb_NetworkOperator_t));
    if (value != (Icb_NetworkOperator)NULL) {
        value->id = Icb_NwOperatorId_Create(session);
        value->name = ASN_OctetString_Create(session);
        value->type = 0;
        value->ciphering = 0;
    }
    return value;
}

U32 Icb_NetworkOperator_EncodedSize(Icb_NetworkOperator ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_NwOperatorId_EncodedSize(ThisPtr->id);
    length += ASN_OctetString_EncodedSize(ThisPtr->name, 0, 30);
    length += Icb_NetworkType_EncodedSize(ThisPtr->type);
    length += Icb_OnOffStatus_EncodedSize(ThisPtr->ciphering);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_NetworkOperator_SessionSize() {
    U32 length = sizeof(struct Icb_NetworkOperator_t);
    length += Icb_NwOperatorId_SessionSize();
    length += ASN_OctetString_SessionSize(0, 30);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_NetworkOperator_Print(Icb_NetworkOperator ThisPtr) {
    ASN_PrintIndented("id" EOL);
    ASN_PrintSetIndent(1);
    Icb_NwOperatorId_Print(ThisPtr->id);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("name" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->name);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("type" EOL);
    ASN_PrintSetIndent(1);
    Icb_NetworkType_Print(ThisPtr->type);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("ciphering" EOL);
    ASN_PrintSetIndent(1);
    Icb_OnOffStatus_Print(ThisPtr->ciphering);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_NetworkOperator_Decode(Icb_NetworkOperator ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_NwOperatorId_Decode(ThisPtr->id, session, stream));
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->name, session, stream, 0, 30));
    ASN_DECODE_CHECK(Icb_NetworkType_Decode(&ThisPtr->type, session, stream));
    ASN_DECODE_CHECK(Icb_OnOffStatus_Decode(&ThisPtr->ciphering, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_NetworkOperator_Encode(Icb_NetworkOperator ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_NwOperatorId_Encode(ThisPtr->id, stream));
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->name, stream, 0, 30));
    ASN_ENCODE_CHECK(Icb_NetworkType_Encode(ThisPtr->type, stream));
    ASN_ENCODE_CHECK(Icb_OnOffStatus_Encode(ThisPtr->ciphering, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_NetworkOperator of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMNetworkOperators_Response of type ASNSequence
 */

Icb_OpPSIMNetworkOperators_Response Icb_OpPSIMNetworkOperators_Response_Create(ASN_Session session) {
    Icb_OpPSIMNetworkOperators_Response value = (Icb_OpPSIMNetworkOperators_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMNetworkOperators_Response_t));
    if (value != (Icb_OpPSIMNetworkOperators_Response)NULL) {
        value->operators = Icb_ArrayOf_NetworkOperator_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMNetworkOperators_Response_EncodedSize(Icb_OpPSIMNetworkOperators_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_NetworkOperator_EncodedSize(ThisPtr->operators, 0, 20);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMNetworkOperators_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMNetworkOperators_Response_t);
    length += Icb_ArrayOf_NetworkOperator_SessionSize(0, 20);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMNetworkOperators_Response_Print(Icb_OpPSIMNetworkOperators_Response ThisPtr) {
    ASN_PrintIndented("operators" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_NetworkOperator_Print(ThisPtr->operators);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMNetworkOperators_Response_Decode(Icb_OpPSIMNetworkOperators_Response ThisPtr, ASN_Session session,
                                                      ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_NetworkOperator_Decode(ThisPtr->operators, session, stream, 0, 20));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMNetworkOperators_Response_Encode(Icb_OpPSIMNetworkOperators_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_NetworkOperator_Encode(ThisPtr->operators, stream, 0, 20));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMNetworkOperators_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMNetworkOperatorCommand_SetRequest of type ASNSequence
 */

Icb_OpPSIMNetworkOperatorCommand_SetRequest Icb_OpPSIMNetworkOperatorCommand_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMNetworkOperatorCommand_SetRequest value = (Icb_OpPSIMNetworkOperatorCommand_SetRequest)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMNetworkOperatorCommand_SetRequest_t));
    if (value != (Icb_OpPSIMNetworkOperatorCommand_SetRequest)NULL) {
        value->cmd = Icb_OperatorSelection_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMNetworkOperatorCommand_SetRequest_EncodedSize(Icb_OpPSIMNetworkOperatorCommand_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_OperatorSelection_EncodedSize(ThisPtr->cmd);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMNetworkOperatorCommand_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMNetworkOperatorCommand_SetRequest_t);
    length += Icb_OperatorSelection_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMNetworkOperatorCommand_SetRequest_Print(Icb_OpPSIMNetworkOperatorCommand_SetRequest ThisPtr) {
    ASN_PrintIndented("cmd" EOL);
    ASN_PrintSetIndent(1);
    Icb_OperatorSelection_Print(ThisPtr->cmd);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMNetworkOperatorCommand_SetRequest_Decode(Icb_OpPSIMNetworkOperatorCommand_SetRequest ThisPtr,
                                                              ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_OperatorSelection_Decode(ThisPtr->cmd, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMNetworkOperatorCommand_SetRequest_Encode(Icb_OpPSIMNetworkOperatorCommand_SetRequest ThisPtr,
                                                              ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_OperatorSelection_Encode(ThisPtr->cmd, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMNetworkOperatorCommand_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMNetworkOperatorCommand_Response of type ASNSequence
 */

Icb_OpPSIMNetworkOperatorCommand_Response Icb_OpPSIMNetworkOperatorCommand_Response_Create(ASN_Session session) {
    Icb_OpPSIMNetworkOperatorCommand_Response value = (Icb_OpPSIMNetworkOperatorCommand_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMNetworkOperatorCommand_Response_t));
    if (value != (Icb_OpPSIMNetworkOperatorCommand_Response)NULL) {
        value->status = Icb_OperatorSelection_Create(session);
        value->operatorSelectionResult = 0;
    }
    return value;
}

U32 Icb_OpPSIMNetworkOperatorCommand_Response_EncodedSize(Icb_OpPSIMNetworkOperatorCommand_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_OperatorSelection_EncodedSize(ThisPtr->status);
    length += Icb_GenericOkStatus_EncodedSize(ThisPtr->operatorSelectionResult);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMNetworkOperatorCommand_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMNetworkOperatorCommand_Response_t);
    length += Icb_OperatorSelection_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMNetworkOperatorCommand_Response_Print(Icb_OpPSIMNetworkOperatorCommand_Response ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_OperatorSelection_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("operatorSelectionResult" EOL);
    ASN_PrintSetIndent(1);
    Icb_GenericOkStatus_Print(ThisPtr->operatorSelectionResult);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMNetworkOperatorCommand_Response_Decode(Icb_OpPSIMNetworkOperatorCommand_Response ThisPtr,
                                                            ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_OperatorSelection_Decode(ThisPtr->status, session, stream));
    ASN_DECODE_CHECK(Icb_GenericOkStatus_Decode(&ThisPtr->operatorSelectionResult, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMNetworkOperatorCommand_Response_Encode(Icb_OpPSIMNetworkOperatorCommand_Response ThisPtr,
                                                            ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_OperatorSelection_Encode(ThisPtr->status, stream));
    ASN_ENCODE_CHECK(Icb_GenericOkStatus_Encode(ThisPtr->operatorSelectionResult, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMNetworkOperatorCommand_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMNetworkOperatorCommand_Notification of type ASNSequence
 */

Icb_OpPSIMNetworkOperatorCommand_Notification Icb_OpPSIMNetworkOperatorCommand_Notification_Create(
        ASN_Session session) {
    Icb_OpPSIMNetworkOperatorCommand_Notification value = (Icb_OpPSIMNetworkOperatorCommand_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMNetworkOperatorCommand_Notification_t));
    if (value != (Icb_OpPSIMNetworkOperatorCommand_Notification)NULL) {
        value->status = Icb_OperatorSelection_Create(session);
        value->operatorSelectionResult = 0;
    }
    return value;
}

U32 Icb_OpPSIMNetworkOperatorCommand_Notification_EncodedSize(Icb_OpPSIMNetworkOperatorCommand_Notification ThisPtr) {
    U32 length = 0;
    length += Icb_OperatorSelection_EncodedSize(ThisPtr->status);
    length += Icb_GenericOkStatus_EncodedSize(ThisPtr->operatorSelectionResult);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMNetworkOperatorCommand_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMNetworkOperatorCommand_Notification_t);
    length += Icb_OperatorSelection_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMNetworkOperatorCommand_Notification_Print(Icb_OpPSIMNetworkOperatorCommand_Notification ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_OperatorSelection_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("operatorSelectionResult" EOL);
    ASN_PrintSetIndent(1);
    Icb_GenericOkStatus_Print(ThisPtr->operatorSelectionResult);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMNetworkOperatorCommand_Notification_Decode(Icb_OpPSIMNetworkOperatorCommand_Notification ThisPtr,
                                                                ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(Icb_OperatorSelection_Decode(ThisPtr->status, session, stream));
    ASN_DECODE_CHECK(Icb_GenericOkStatus_Decode(&ThisPtr->operatorSelectionResult, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMNetworkOperatorCommand_Notification_Encode(Icb_OpPSIMNetworkOperatorCommand_Notification ThisPtr,
                                                                ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(Icb_OperatorSelection_Encode(ThisPtr->status, stream));
    ASN_ENCODE_CHECK(Icb_GenericOkStatus_Encode(ThisPtr->operatorSelectionResult, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMNetworkOperatorCommand_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMState_Response of type ASNSequence
 */

Icb_OpPSIMState_Response Icb_OpPSIMState_Response_Create(ASN_Session session) {
    Icb_OpPSIMState_Response value =
            (Icb_OpPSIMState_Response)ASN_Malloc(session, sizeof(struct Icb_OpPSIMState_Response_t));
    if (value != (Icb_OpPSIMState_Response)NULL) {
        value->exists__optional__simID = 0;
        value->status = Icb_SimStatus_Create(session);
        value->simID = Icb_IMSINumber_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMState_Response_EncodedSize(Icb_OpPSIMState_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__simID);
    length += Icb_SimStatus_EncodedSize(ThisPtr->status);
    if (ThisPtr->exists__optional__simID == TRUE) {
        length += Icb_IMSINumber_EncodedSize(ThisPtr->simID);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMState_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMState_Response_t);
    length += Icb_SimStatus_SessionSize();
    length += Icb_IMSINumber_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMState_Response_Print(Icb_OpPSIMState_Response ThisPtr) {
    ASN_PrintIndented("exists__optional__simID" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__simID);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_SimStatus_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__simID == TRUE) {
        ASN_PrintIndented("simID" EOL);
        ASN_PrintSetIndent(1);
        Icb_IMSINumber_Print(ThisPtr->simID);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMState_Response_Decode(Icb_OpPSIMState_Response ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__simID, session, stream));
    ASN_DECODE_CHECK(Icb_SimStatus_Decode(ThisPtr->status, session, stream));
    if (ThisPtr->exists__optional__simID == TRUE) {
        ASN_DECODE_CHECK(Icb_IMSINumber_Decode(ThisPtr->simID, session, stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMState_Response_Encode(Icb_OpPSIMState_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__simID, stream));
    ASN_ENCODE_CHECK(Icb_SimStatus_Encode(ThisPtr->status, stream));
    if (ThisPtr->exists__optional__simID == TRUE) {
        ASN_ENCODE_CHECK(Icb_IMSINumber_Encode(ThisPtr->simID, stream));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMState_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMPhoneOperationMode_Response of type ASNSequence
 */

Icb_OpPSIMPhoneOperationMode_Response Icb_OpPSIMPhoneOperationMode_Response_Create(ASN_Session session) {
    Icb_OpPSIMPhoneOperationMode_Response value = (Icb_OpPSIMPhoneOperationMode_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpPSIMPhoneOperationMode_Response_t));
    if (value != (Icb_OpPSIMPhoneOperationMode_Response)NULL) {
        value->mode = 0;
    }
    return value;
}

U32 Icb_OpPSIMPhoneOperationMode_Response_EncodedSize(Icb_OpPSIMPhoneOperationMode_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_PhoneOperationMode_EncodedSize(ThisPtr->mode);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMPhoneOperationMode_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMPhoneOperationMode_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMPhoneOperationMode_Response_Print(Icb_OpPSIMPhoneOperationMode_Response ThisPtr) {
    ASN_PrintIndented("mode" EOL);
    ASN_PrintSetIndent(1);
    Icb_PhoneOperationMode_Print(ThisPtr->mode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMPhoneOperationMode_Response_Decode(Icb_OpPSIMPhoneOperationMode_Response ThisPtr,
                                                        ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_PhoneOperationMode_Decode(&ThisPtr->mode, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMPhoneOperationMode_Response_Encode(Icb_OpPSIMPhoneOperationMode_Response ThisPtr,
                                                        ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_PhoneOperationMode_Encode(ThisPtr->mode, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMPhoneOperationMode_Response of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMUssd_SetRequest of type ASNSequence
 */

Icb_OpPSIMUssd_SetRequest Icb_OpPSIMUssd_SetRequest_Create(ASN_Session session) {
    Icb_OpPSIMUssd_SetRequest value =
            (Icb_OpPSIMUssd_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpPSIMUssd_SetRequest_t));
    if (value != (Icb_OpPSIMUssd_SetRequest)NULL) {
        value->ussd = Icb_UssdCode_Create(session);
        value->language = ASN_OctetString_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMUssd_SetRequest_EncodedSize(Icb_OpPSIMUssd_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_UssdCode_EncodedSize(ThisPtr->ussd);
    length += ASN_OctetString_EncodedSize(ThisPtr->language, 3, 3);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMUssd_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMUssd_SetRequest_t);
    length += Icb_UssdCode_SessionSize();
    length += ASN_OctetString_SessionSize(3, 3);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMUssd_SetRequest_Print(Icb_OpPSIMUssd_SetRequest ThisPtr) {
    ASN_PrintIndented("ussd" EOL);
    ASN_PrintSetIndent(1);
    Icb_UssdCode_Print(ThisPtr->ussd);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("language" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->language);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMUssd_SetRequest_Decode(Icb_OpPSIMUssd_SetRequest ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_UssdCode_Decode(ThisPtr->ussd, session, stream));
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->language, session, stream, 3, 3));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMUssd_SetRequest_Encode(Icb_OpPSIMUssd_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_UssdCode_Encode(ThisPtr->ussd, stream));
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->language, stream, 3, 3));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMUssd_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpPSIMUssd_Response of type ASNSequence
 */

Icb_OpPSIMUssd_Response Icb_OpPSIMUssd_Response_Create(ASN_Session session) {
    Icb_OpPSIMUssd_Response value =
            (Icb_OpPSIMUssd_Response)ASN_Malloc(session, sizeof(struct Icb_OpPSIMUssd_Response_t));
    if (value != (Icb_OpPSIMUssd_Response)NULL) {
        value->ussdStatus = 0;
        value->ussd = Icb_UssdReturnCode_Create(session);
    }
    return value;
}

U32 Icb_OpPSIMUssd_Response_EncodedSize(Icb_OpPSIMUssd_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_UssdStatus_EncodedSize(ThisPtr->ussdStatus);
    length += Icb_UssdReturnCode_EncodedSize(ThisPtr->ussd);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpPSIMUssd_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpPSIMUssd_Response_t);
    length += Icb_UssdReturnCode_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpPSIMUssd_Response_Print(Icb_OpPSIMUssd_Response ThisPtr) {
    ASN_PrintIndented("ussdStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_UssdStatus_Print(ThisPtr->ussdStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("ussd" EOL);
    ASN_PrintSetIndent(1);
    Icb_UssdReturnCode_Print(ThisPtr->ussd);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpPSIMUssd_Response_Decode(Icb_OpPSIMUssd_Response ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_UssdStatus_Decode(&ThisPtr->ussdStatus, session, stream));
    ASN_DECODE_CHECK(Icb_UssdReturnCode_Decode(ThisPtr->ussd, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpPSIMUssd_Response_Encode(Icb_OpPSIMUssd_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_UssdStatus_Encode(ThisPtr->ussdStatus, stream));
    ASN_ENCODE_CHECK(Icb_UssdReturnCode_Encode(ThisPtr->ussd, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpPSIMUssd_Response of type ASNSequence
 */

/*
 * Start of Icb_OpCallHandling_SetRequest of type ASNSequence
 */

Icb_OpCallHandling_SetRequest Icb_OpCallHandling_SetRequest_Create(ASN_Session session) {
    Icb_OpCallHandling_SetRequest value =
            (Icb_OpCallHandling_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpCallHandling_SetRequest_t));
    if (value != (Icb_OpCallHandling_SetRequest)NULL) {
        value->exists__optional__callId = 0;
        value->action = 0;
        value->callId = 0;
    }
    return value;
}

U32 Icb_OpCallHandling_SetRequest_EncodedSize(Icb_OpCallHandling_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__callId);
    length += Icb_AssistCallAction_EncodedSize(ThisPtr->action);
    if (ThisPtr->exists__optional__callId == TRUE) {
        length += U32_EncodedSize(ThisPtr->callId, 0, 255);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCallHandling_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpCallHandling_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCallHandling_SetRequest_Print(Icb_OpCallHandling_SetRequest ThisPtr) {
    ASN_PrintIndented("exists__optional__callId" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__callId);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("action" EOL);
    ASN_PrintSetIndent(1);
    Icb_AssistCallAction_Print(ThisPtr->action);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__callId == TRUE) {
        ASN_PrintIndented("callId" EOL);
        ASN_PrintSetIndent(1);
        U32_Print(ThisPtr->callId);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCallHandling_SetRequest_Decode(Icb_OpCallHandling_SetRequest ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__callId, session, stream));
    ASN_DECODE_CHECK(Icb_AssistCallAction_Decode(&ThisPtr->action, session, stream));
    if (ThisPtr->exists__optional__callId == TRUE) {
        ASN_DECODE_CHECK(U32_Decode(&ThisPtr->callId, session, stream, 0, 255));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCallHandling_SetRequest_Encode(Icb_OpCallHandling_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__callId, stream));
    ASN_ENCODE_CHECK(Icb_AssistCallAction_Encode(ThisPtr->action, stream));
    if (ThisPtr->exists__optional__callId == TRUE) {
        ASN_ENCODE_CHECK(U32_Encode(ThisPtr->callId, stream, 0, 255));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCallHandling_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpTEMIdentification_Response of type ASNSequence
 */

Icb_OpTEMIdentification_Response Icb_OpTEMIdentification_Response_Create(ASN_Session session) {
    Icb_OpTEMIdentification_Response value =
            (Icb_OpTEMIdentification_Response)ASN_Malloc(session, sizeof(struct Icb_OpTEMIdentification_Response_t));
    if (value != (Icb_OpTEMIdentification_Response)NULL) {
        value->exists__optional__wifiMac = 0;
        value->imei = ASN_OctetString_Create(session);
        value->wifiMac = Icb_MacAddress_Create(session);
        value->serialNr = ASN_OctetString_Create(session);
    }
    return value;
}

U32 Icb_OpTEMIdentification_Response_EncodedSize(Icb_OpTEMIdentification_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__wifiMac);
    length += ASN_OctetString_EncodedSize(ThisPtr->imei, 15, 15);
    if (ThisPtr->exists__optional__wifiMac == TRUE) {
        length += Icb_MacAddress_EncodedSize(ThisPtr->wifiMac);
    }
    length += ASN_OctetString_EncodedSize(ThisPtr->serialNr, 15, 15);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTEMIdentification_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpTEMIdentification_Response_t);
    length += ASN_OctetString_SessionSize(15, 15);
    length += Icb_MacAddress_SessionSize();
    length += ASN_OctetString_SessionSize(15, 15);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTEMIdentification_Response_Print(Icb_OpTEMIdentification_Response ThisPtr) {
    ASN_PrintIndented("exists__optional__wifiMac" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__wifiMac);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("imei" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->imei);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__wifiMac == TRUE) {
        ASN_PrintIndented("wifiMac" EOL);
        ASN_PrintSetIndent(1);
        Icb_MacAddress_Print(ThisPtr->wifiMac);
        ASN_PrintSetIndent(-1);
    }
    ASN_PrintIndented("serialNr" EOL);
    ASN_PrintSetIndent(1);
    ASN_OctetString_Print(ThisPtr->serialNr);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTEMIdentification_Response_Decode(Icb_OpTEMIdentification_Response ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__wifiMac, session, stream));
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->imei, session, stream, 15, 15));
    if (ThisPtr->exists__optional__wifiMac == TRUE) {
        ASN_DECODE_CHECK(Icb_MacAddress_Decode(ThisPtr->wifiMac, session, stream));
    }
    ASN_DECODE_CHECK(ASN_OctetString_Decode(ThisPtr->serialNr, session, stream, 15, 15));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTEMIdentification_Response_Encode(Icb_OpTEMIdentification_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__wifiMac, stream));
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->imei, stream, 15, 15));
    if (ThisPtr->exists__optional__wifiMac == TRUE) {
        ASN_ENCODE_CHECK(Icb_MacAddress_Encode(ThisPtr->wifiMac, stream));
    }
    ASN_ENCODE_CHECK(ASN_OctetString_Encode(ThisPtr->serialNr, stream, 15, 15));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTEMIdentification_Response of type ASNSequence
 */

/*
 * Start of Icb_OpTEMRadioMode_SetRequest of type ASNSequence
 */

Icb_OpTEMRadioMode_SetRequest Icb_OpTEMRadioMode_SetRequest_Create(ASN_Session session) {
    Icb_OpTEMRadioMode_SetRequest value =
            (Icb_OpTEMRadioMode_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpTEMRadioMode_SetRequest_t));
    if (value != (Icb_OpTEMRadioMode_SetRequest)NULL) {
        value->requestedMode = 0;
    }
    return value;
}

U32 Icb_OpTEMRadioMode_SetRequest_EncodedSize(Icb_OpTEMRadioMode_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_RadioMode_EncodedSize(ThisPtr->requestedMode);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTEMRadioMode_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpTEMRadioMode_SetRequest_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTEMRadioMode_SetRequest_Print(Icb_OpTEMRadioMode_SetRequest ThisPtr) {
    ASN_PrintIndented("requestedMode" EOL);
    ASN_PrintSetIndent(1);
    Icb_RadioMode_Print(ThisPtr->requestedMode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTEMRadioMode_SetRequest_Decode(Icb_OpTEMRadioMode_SetRequest ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_RadioMode_Decode(&ThisPtr->requestedMode, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTEMRadioMode_SetRequest_Encode(Icb_OpTEMRadioMode_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_RadioMode_Encode(ThisPtr->requestedMode, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTEMRadioMode_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpTEMRadioMode_Response of type ASNSequence
 */

Icb_OpTEMRadioMode_Response Icb_OpTEMRadioMode_Response_Create(ASN_Session session) {
    Icb_OpTEMRadioMode_Response value =
            (Icb_OpTEMRadioMode_Response)ASN_Malloc(session, sizeof(struct Icb_OpTEMRadioMode_Response_t));
    if (value != (Icb_OpTEMRadioMode_Response)NULL) {
        value->currentMode = 0;
    }
    return value;
}

U32 Icb_OpTEMRadioMode_Response_EncodedSize(Icb_OpTEMRadioMode_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_RadioMode_EncodedSize(ThisPtr->currentMode);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTEMRadioMode_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpTEMRadioMode_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTEMRadioMode_Response_Print(Icb_OpTEMRadioMode_Response ThisPtr) {
    ASN_PrintIndented("currentMode" EOL);
    ASN_PrintSetIndent(1);
    Icb_RadioMode_Print(ThisPtr->currentMode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTEMRadioMode_Response_Decode(Icb_OpTEMRadioMode_Response ThisPtr, ASN_Session session,
                                              ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_RadioMode_Decode(&ThisPtr->currentMode, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTEMRadioMode_Response_Encode(Icb_OpTEMRadioMode_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_RadioMode_Encode(ThisPtr->currentMode, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTEMRadioMode_Response of type ASNSequence
 */

/*
 * Start of Icb_OpTunerFrequencies_Response of type ASNSequence
 */

Icb_OpTunerFrequencies_Response Icb_OpTunerFrequencies_Response_Create(ASN_Session session) {
    Icb_OpTunerFrequencies_Response value =
            (Icb_OpTunerFrequencies_Response)ASN_Malloc(session, sizeof(struct Icb_OpTunerFrequencies_Response_t));
    if (value != (Icb_OpTunerFrequencies_Response)NULL) {
        value->frequencies = Icb_ArrayOf_RadioFrequencyHz_Create(session);
    }
    return value;
}

U32 Icb_OpTunerFrequencies_Response_EncodedSize(Icb_OpTunerFrequencies_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_RadioFrequencyHz_EncodedSize(ThisPtr->frequencies, 0, 10);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpTunerFrequencies_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpTunerFrequencies_Response_t);
    length += Icb_ArrayOf_RadioFrequencyHz_SessionSize(0, 10);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpTunerFrequencies_Response_Print(Icb_OpTunerFrequencies_Response ThisPtr) {
    ASN_PrintIndented("frequencies" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_RadioFrequencyHz_Print(ThisPtr->frequencies);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpTunerFrequencies_Response_Decode(Icb_OpTunerFrequencies_Response ThisPtr, ASN_Session session,
                                                  ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_RadioFrequencyHz_Decode(ThisPtr->frequencies, session, stream, 0, 10));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpTunerFrequencies_Response_Encode(Icb_OpTunerFrequencies_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_RadioFrequencyHz_Encode(ThisPtr->frequencies, stream, 0, 10));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpTunerFrequencies_Response of type ASNSequence
 */

/*
 * Start of Icb_OpDeadReckonedPosition_Response of type ASNSequence
 */

Icb_OpDeadReckonedPosition_Response Icb_OpDeadReckonedPosition_Response_Create(ASN_Session session) {
    Icb_OpDeadReckonedPosition_Response value = (Icb_OpDeadReckonedPosition_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpDeadReckonedPosition_Response_t));
    if (value != (Icb_OpDeadReckonedPosition_Response)NULL) {
        value->position = Icb_DRVehiclePosition_Create(session);
    }
    return value;
}

U32 Icb_OpDeadReckonedPosition_Response_EncodedSize(Icb_OpDeadReckonedPosition_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_DRVehiclePosition_EncodedSize(ThisPtr->position);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpDeadReckonedPosition_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpDeadReckonedPosition_Response_t);
    length += Icb_DRVehiclePosition_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpDeadReckonedPosition_Response_Print(Icb_OpDeadReckonedPosition_Response ThisPtr) {
    ASN_PrintIndented("position" EOL);
    ASN_PrintSetIndent(1);
    Icb_DRVehiclePosition_Print(ThisPtr->position);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpDeadReckonedPosition_Response_Decode(Icb_OpDeadReckonedPosition_Response ThisPtr, ASN_Session session,
                                                      ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_DRVehiclePosition_Decode(ThisPtr->position, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpDeadReckonedPosition_Response_Encode(Icb_OpDeadReckonedPosition_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_DRVehiclePosition_Encode(ThisPtr->position, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpDeadReckonedPosition_Response of type ASNSequence
 */

/*
 * Start of Icb_DRPositionData of type ASNSequence
 */

Icb_DRPositionData Icb_DRPositionData_Create(ASN_Session session) {
    Icb_DRPositionData value = (Icb_DRPositionData)ASN_Malloc(session, sizeof(struct Icb_DRPositionData_t));
    if (value != (Icb_DRPositionData)NULL) {
        value->longLat = Icb_CoordinatesLongLat_Create(session);
        value->heading = 0;
        value->speedKmph = 0;
        value->hdopX10 = 0;
        value->numSat = 0;
        value->fixTime = Icb_DateTime_Create(session);
        value->fixType = 0;
        value->drType = 0;
        value->drDistance = 0;
    }
    return value;
}

U32 Icb_DRPositionData_EncodedSize(Icb_DRPositionData ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_CoordinatesLongLat_EncodedSize(ThisPtr->longLat);
    length += U32_EncodedSize(ThisPtr->heading, 0, 360);
    length += U32_EncodedSize(ThisPtr->speedKmph, 0, 255);
    length += U32_EncodedSize(ThisPtr->hdopX10, 0, 255);
    length += U32_EncodedSize(ThisPtr->numSat, 0, 127);
    length += Icb_DateTime_EncodedSize(ThisPtr->fixTime);
    length += Icb_GnssFixType_EncodedSize(ThisPtr->fixType);
    length += Icb_DeadReckoningType_EncodedSize(ThisPtr->drType);
    length += U32_EncodedSize(ThisPtr->drDistance, 0, 65535);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_DRPositionData_SessionSize() {
    U32 length = sizeof(struct Icb_DRPositionData_t);
    length += Icb_CoordinatesLongLat_SessionSize();
    length += Icb_DateTime_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_DRPositionData_Print(Icb_DRPositionData ThisPtr) {
    ASN_PrintIndented("longLat" EOL);
    ASN_PrintSetIndent(1);
    Icb_CoordinatesLongLat_Print(ThisPtr->longLat);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("heading" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->heading);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("speedKmph" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->speedKmph);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("hdopX10" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->hdopX10);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("numSat" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->numSat);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("fixTime" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->fixTime);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("fixType" EOL);
    ASN_PrintSetIndent(1);
    Icb_GnssFixType_Print(ThisPtr->fixType);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("drType" EOL);
    ASN_PrintSetIndent(1);
    Icb_DeadReckoningType_Print(ThisPtr->drType);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("drDistance" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->drDistance);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_DRPositionData_Decode(Icb_DRPositionData ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_CoordinatesLongLat_Decode(ThisPtr->longLat, session, stream));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->heading, session, stream, 0, 360));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->speedKmph, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->hdopX10, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->numSat, session, stream, 0, 127));
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->fixTime, session, stream));
    ASN_DECODE_CHECK(Icb_GnssFixType_Decode(&ThisPtr->fixType, session, stream));
    ASN_DECODE_CHECK(Icb_DeadReckoningType_Decode(&ThisPtr->drType, session, stream));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->drDistance, session, stream, 0, 65535));
    return ASN_RESULT_OK;
}

ASN_Result Icb_DRPositionData_Encode(Icb_DRPositionData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_CoordinatesLongLat_Encode(ThisPtr->longLat, stream));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->heading, stream, 0, 360));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->speedKmph, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->hdopX10, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->numSat, stream, 0, 127));
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->fixTime, stream));
    ASN_ENCODE_CHECK(Icb_GnssFixType_Encode(ThisPtr->fixType, stream));
    ASN_ENCODE_CHECK(Icb_DeadReckoningType_Encode(ThisPtr->drType, stream));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->drDistance, stream, 0, 65535));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_DRPositionData of type ASNSequence
 */

/*
 * Start of Icb_GeographicalPosition of type ASNSequence
 */

Icb_GeographicalPosition Icb_GeographicalPosition_Create(ASN_Session session) {
    Icb_GeographicalPosition value =
            (Icb_GeographicalPosition)ASN_Malloc(session, sizeof(struct Icb_GeographicalPosition_t));
    if (value != (Icb_GeographicalPosition)NULL) {
        value->longLat = Icb_CoordinatesLongLat_Create(session);
        value->altitude = 0;
    }
    return value;
}

U32 Icb_GeographicalPosition_EncodedSize(Icb_GeographicalPosition ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_CoordinatesLongLat_EncodedSize(ThisPtr->longLat);
    length += S32_EncodedSize(ThisPtr->altitude, -1000, 60000);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_GeographicalPosition_SessionSize() {
    U32 length = sizeof(struct Icb_GeographicalPosition_t);
    length += Icb_CoordinatesLongLat_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_GeographicalPosition_Print(Icb_GeographicalPosition ThisPtr) {
    ASN_PrintIndented("longLat" EOL);
    ASN_PrintSetIndent(1);
    Icb_CoordinatesLongLat_Print(ThisPtr->longLat);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("altitude" EOL);
    ASN_PrintSetIndent(1);
    S32_Print(ThisPtr->altitude);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_GeographicalPosition_Decode(Icb_GeographicalPosition ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_CoordinatesLongLat_Decode(ThisPtr->longLat, session, stream));
    ASN_DECODE_CHECK(S32_Decode(&ThisPtr->altitude, session, stream, -1000, 60000));
    return ASN_RESULT_OK;
}

ASN_Result Icb_GeographicalPosition_Encode(Icb_GeographicalPosition ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_CoordinatesLongLat_Encode(ThisPtr->longLat, stream));
    ASN_ENCODE_CHECK(S32_Encode(ThisPtr->altitude, stream, -1000, 60000));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_GeographicalPosition of type ASNSequence
 */

/*
 * Start of Icb_SatelliteUsage of type ASNSequence
 */

Icb_SatelliteUsage Icb_SatelliteUsage_Create(ASN_Session session) {
    Icb_SatelliteUsage value = (Icb_SatelliteUsage)ASN_Malloc(session, sizeof(struct Icb_SatelliteUsage_t));
    if (value != (Icb_SatelliteUsage)NULL) {
        value->nrOfSatellitesVisible = Icb_NrOfSatellitesPerSystem_Create(session);
        value->nrOfSatellitesUsed = Icb_NrOfSatellitesPerSystem_Create(session);
    }
    return value;
}

U32 Icb_SatelliteUsage_EncodedSize(Icb_SatelliteUsage ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_NrOfSatellitesPerSystem_EncodedSize(ThisPtr->nrOfSatellitesVisible);
    length += Icb_NrOfSatellitesPerSystem_EncodedSize(ThisPtr->nrOfSatellitesUsed);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_SatelliteUsage_SessionSize() {
    U32 length = sizeof(struct Icb_SatelliteUsage_t);
    length += Icb_NrOfSatellitesPerSystem_SessionSize();
    length += Icb_NrOfSatellitesPerSystem_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_SatelliteUsage_Print(Icb_SatelliteUsage ThisPtr) {
    ASN_PrintIndented("nrOfSatellitesVisible" EOL);
    ASN_PrintSetIndent(1);
    Icb_NrOfSatellitesPerSystem_Print(ThisPtr->nrOfSatellitesVisible);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("nrOfSatellitesUsed" EOL);
    ASN_PrintSetIndent(1);
    Icb_NrOfSatellitesPerSystem_Print(ThisPtr->nrOfSatellitesUsed);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_SatelliteUsage_Decode(Icb_SatelliteUsage ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_NrOfSatellitesPerSystem_Decode(ThisPtr->nrOfSatellitesVisible, session, stream));
    ASN_DECODE_CHECK(Icb_NrOfSatellitesPerSystem_Decode(ThisPtr->nrOfSatellitesUsed, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_SatelliteUsage_Encode(Icb_SatelliteUsage ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_NrOfSatellitesPerSystem_Encode(ThisPtr->nrOfSatellitesVisible, stream));
    ASN_ENCODE_CHECK(Icb_NrOfSatellitesPerSystem_Encode(ThisPtr->nrOfSatellitesUsed, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_SatelliteUsage of type ASNSequence
 */

/*
 * Start of Icb_ChannelData of type ASNSequence
 */

Icb_ChannelData Icb_ChannelData_Create(ASN_Session session) {
    Icb_ChannelData value = (Icb_ChannelData)ASN_Malloc(session, sizeof(struct Icb_ChannelData_t));
    if (value != (Icb_ChannelData)NULL) {
        value->prn = 0;
        value->trackingStatus = 0;
        value->svacc = 0;
        value->snr = 0;
        value->azimuthAngle = 0;
        value->elevationAngle = 0;
        value->extendedData = Icb_ExtendedChannelData_Create(session);
    }
    return value;
}

U32 Icb_ChannelData_EncodedSize(Icb_ChannelData ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += U32_EncodedSize(ThisPtr->prn, 1, 255);
    length += Icb_SatelliteTrackingStatusType_EncodedSize(ThisPtr->trackingStatus);
    length += U32_EncodedSize(ThisPtr->svacc, 0, 15);
    length += U32_EncodedSize(ThisPtr->snr, 0, 255);
    length += U32_EncodedSize(ThisPtr->azimuthAngle, 0, 255);
    length += U32_EncodedSize(ThisPtr->elevationAngle, 0, 255);
    length += Icb_ExtendedChannelData_EncodedSize(ThisPtr->extendedData);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ChannelData_SessionSize() {
    U32 length = sizeof(struct Icb_ChannelData_t);
    length += Icb_ExtendedChannelData_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_ChannelData_Print(Icb_ChannelData ThisPtr) {
    ASN_PrintIndented("prn" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->prn);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("trackingStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_SatelliteTrackingStatusType_Print(ThisPtr->trackingStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("svacc" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->svacc);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("snr" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->snr);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("azimuthAngle" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->azimuthAngle);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("elevationAngle" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->elevationAngle);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("extendedData" EOL);
    ASN_PrintSetIndent(1);
    Icb_ExtendedChannelData_Print(ThisPtr->extendedData);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_ChannelData_Decode(Icb_ChannelData ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->prn, session, stream, 1, 255));
    ASN_DECODE_CHECK(Icb_SatelliteTrackingStatusType_Decode(&ThisPtr->trackingStatus, session, stream));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->svacc, session, stream, 0, 15));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->snr, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->azimuthAngle, session, stream, 0, 255));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->elevationAngle, session, stream, 0, 255));
    ASN_DECODE_CHECK(Icb_ExtendedChannelData_Decode(ThisPtr->extendedData, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_ChannelData_Encode(Icb_ChannelData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->prn, stream, 1, 255));
    ASN_ENCODE_CHECK(Icb_SatelliteTrackingStatusType_Encode(ThisPtr->trackingStatus, stream));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->svacc, stream, 0, 15));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->snr, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->azimuthAngle, stream, 0, 255));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->elevationAngle, stream, 0, 255));
    ASN_ENCODE_CHECK(Icb_ExtendedChannelData_Encode(ThisPtr->extendedData, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_ChannelData of type ASNSequence
 */

/*
 * Start of Icb_GNSSDataAccuracy of type ASNSequence
 */

Icb_GNSSDataAccuracy Icb_GNSSDataAccuracy_Create(ASN_Session session) {
    Icb_GNSSDataAccuracy value = (Icb_GNSSDataAccuracy)ASN_Malloc(session, sizeof(struct Icb_GNSSDataAccuracy_t));
    if (value != (Icb_GNSSDataAccuracy)NULL) {
        value->utcTime = Icb_DateTime_Create(session);
        value->accuracy = Icb_AccuracyValues_Create(session);
    }
    return value;
}

U32 Icb_GNSSDataAccuracy_EncodedSize(Icb_GNSSDataAccuracy ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_DateTime_EncodedSize(ThisPtr->utcTime);
    length += Icb_AccuracyValues_EncodedSize(ThisPtr->accuracy);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_GNSSDataAccuracy_SessionSize() {
    U32 length = sizeof(struct Icb_GNSSDataAccuracy_t);
    length += Icb_DateTime_SessionSize();
    length += Icb_AccuracyValues_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_GNSSDataAccuracy_Print(Icb_GNSSDataAccuracy ThisPtr) {
    ASN_PrintIndented("utcTime" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->utcTime);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("accuracy" EOL);
    ASN_PrintSetIndent(1);
    Icb_AccuracyValues_Print(ThisPtr->accuracy);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_GNSSDataAccuracy_Decode(Icb_GNSSDataAccuracy ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->utcTime, session, stream));
    ASN_DECODE_CHECK(Icb_AccuracyValues_Decode(ThisPtr->accuracy, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_GNSSDataAccuracy_Encode(Icb_GNSSDataAccuracy ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->utcTime, stream));
    ASN_ENCODE_CHECK(Icb_AccuracyValues_Encode(ThisPtr->accuracy, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_GNSSDataAccuracy of type ASNSequence
 */

/*
 * Start of Icb_OpRemoteDiagnosticInfo_Notification of type ASNSequence
 */

Icb_OpRemoteDiagnosticInfo_Notification Icb_OpRemoteDiagnosticInfo_Notification_Create(ASN_Session session) {
    Icb_OpRemoteDiagnosticInfo_Notification value = (Icb_OpRemoteDiagnosticInfo_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpRemoteDiagnosticInfo_Notification_t));
    if (value != (Icb_OpRemoteDiagnosticInfo_Notification)NULL) {
        value->remoteDiagInfo = 0;
    }
    return value;
}

U32 Icb_OpRemoteDiagnosticInfo_Notification_EncodedSize(Icb_OpRemoteDiagnosticInfo_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_RemoteDiagInfo_EncodedSize(ThisPtr->remoteDiagInfo);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpRemoteDiagnosticInfo_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpRemoteDiagnosticInfo_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpRemoteDiagnosticInfo_Notification_Print(Icb_OpRemoteDiagnosticInfo_Notification ThisPtr) {
    ASN_PrintIndented("remoteDiagInfo" EOL);
    ASN_PrintSetIndent(1);
    Icb_RemoteDiagInfo_Print(ThisPtr->remoteDiagInfo);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpRemoteDiagnosticInfo_Notification_Decode(Icb_OpRemoteDiagnosticInfo_Notification ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_RemoteDiagInfo_Decode(&ThisPtr->remoteDiagInfo, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpRemoteDiagnosticInfo_Notification_Encode(Icb_OpRemoteDiagnosticInfo_Notification ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_RemoteDiagInfo_Encode(ThisPtr->remoteDiagInfo, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpRemoteDiagnosticInfo_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpCurrentDoIPState_Notification of type ASNSequence
 */

Icb_OpCurrentDoIPState_Notification Icb_OpCurrentDoIPState_Notification_Create(ASN_Session session) {
    Icb_OpCurrentDoIPState_Notification value = (Icb_OpCurrentDoIPState_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpCurrentDoIPState_Notification_t));
    if (value != (Icb_OpCurrentDoIPState_Notification)NULL) {
        value->doIPState = 0;
        value->doIPMode = 0;
        value->doIPPhase = 0;
    }
    return value;
}

U32 Icb_OpCurrentDoIPState_Notification_EncodedSize(Icb_OpCurrentDoIPState_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->doIPState);
    length += Icb_DoIPMode_EncodedSize(ThisPtr->doIPMode);
    length += Icb_DoIPPhase_EncodedSize(ThisPtr->doIPPhase);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCurrentDoIPState_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpCurrentDoIPState_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCurrentDoIPState_Notification_Print(Icb_OpCurrentDoIPState_Notification ThisPtr) {
    ASN_PrintIndented("doIPState" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->doIPState);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("doIPMode" EOL);
    ASN_PrintSetIndent(1);
    Icb_DoIPMode_Print(ThisPtr->doIPMode);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("doIPPhase" EOL);
    ASN_PrintSetIndent(1);
    Icb_DoIPPhase_Print(ThisPtr->doIPPhase);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCurrentDoIPState_Notification_Decode(Icb_OpCurrentDoIPState_Notification ThisPtr, ASN_Session session,
                                                      ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->doIPState, session, stream));
    ASN_DECODE_CHECK(Icb_DoIPMode_Decode(&ThisPtr->doIPMode, session, stream));
    ASN_DECODE_CHECK(Icb_DoIPPhase_Decode(&ThisPtr->doIPPhase, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCurrentDoIPState_Notification_Encode(Icb_OpCurrentDoIPState_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->doIPState, stream));
    ASN_ENCODE_CHECK(Icb_DoIPMode_Encode(ThisPtr->doIPMode, stream));
    ASN_ENCODE_CHECK(Icb_DoIPPhase_Encode(ThisPtr->doIPPhase, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCurrentDoIPState_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpCurrentDoIPConnection_Notification of type ASNSequence
 */

Icb_OpCurrentDoIPConnection_Notification Icb_OpCurrentDoIPConnection_Notification_Create(ASN_Session session) {
    Icb_OpCurrentDoIPConnection_Notification value = (Icb_OpCurrentDoIPConnection_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpCurrentDoIPConnection_Notification_t));
    if (value != (Icb_OpCurrentDoIPConnection_Notification)NULL) {
        value->currentDoIPConn = 0;
    }
    return value;
}

U32 Icb_OpCurrentDoIPConnection_Notification_EncodedSize(Icb_OpCurrentDoIPConnection_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_CurrentDoIPConn_EncodedSize(ThisPtr->currentDoIPConn);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpCurrentDoIPConnection_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpCurrentDoIPConnection_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpCurrentDoIPConnection_Notification_Print(Icb_OpCurrentDoIPConnection_Notification ThisPtr) {
    ASN_PrintIndented("currentDoIPConn" EOL);
    ASN_PrintSetIndent(1);
    Icb_CurrentDoIPConn_Print(ThisPtr->currentDoIPConn);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpCurrentDoIPConnection_Notification_Decode(Icb_OpCurrentDoIPConnection_Notification ThisPtr,
                                                           ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_CurrentDoIPConn_Decode(&ThisPtr->currentDoIPConn, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpCurrentDoIPConnection_Notification_Encode(Icb_OpCurrentDoIPConnection_Notification ThisPtr,
                                                           ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_CurrentDoIPConn_Encode(ThisPtr->currentDoIPConn, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpCurrentDoIPConnection_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpRequestUserAuthentication_Response of type ASNSequence
 */

Icb_OpRequestUserAuthentication_Response Icb_OpRequestUserAuthentication_Response_Create(ASN_Session session) {
    Icb_OpRequestUserAuthentication_Response value = (Icb_OpRequestUserAuthentication_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpRequestUserAuthentication_Response_t));
    if (value != (Icb_OpRequestUserAuthentication_Response)NULL) {
        value->userAuthCredentials = 0;
    }
    return value;
}

U32 Icb_OpRequestUserAuthentication_Response_EncodedSize(Icb_OpRequestUserAuthentication_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_UserAuthCredentials_EncodedSize(ThisPtr->userAuthCredentials);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpRequestUserAuthentication_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpRequestUserAuthentication_Response_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpRequestUserAuthentication_Response_Print(Icb_OpRequestUserAuthentication_Response ThisPtr) {
    ASN_PrintIndented("userAuthCredentials" EOL);
    ASN_PrintSetIndent(1);
    Icb_UserAuthCredentials_Print(ThisPtr->userAuthCredentials);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpRequestUserAuthentication_Response_Decode(Icb_OpRequestUserAuthentication_Response ThisPtr,
                                                           ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_UserAuthCredentials_Decode(&ThisPtr->userAuthCredentials, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpRequestUserAuthentication_Response_Encode(Icb_OpRequestUserAuthentication_Response ThisPtr,
                                                           ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_UserAuthCredentials_Encode(ThisPtr->userAuthCredentials, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpRequestUserAuthentication_Response of type ASNSequence
 */

/*
 * Start of Icb_OpUpdateDaCMode_Notification of type ASNSequence
 */

Icb_OpUpdateDaCMode_Notification Icb_OpUpdateDaCMode_Notification_Create(ASN_Session session) {
    Icb_OpUpdateDaCMode_Notification value =
            (Icb_OpUpdateDaCMode_Notification)ASN_Malloc(session, sizeof(struct Icb_OpUpdateDaCMode_Notification_t));
    if (value != (Icb_OpUpdateDaCMode_Notification)NULL) {
        value->updateDaCMode = 0;
    }
    return value;
}

U32 Icb_OpUpdateDaCMode_Notification_EncodedSize(Icb_OpUpdateDaCMode_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_UpdateDacMode_EncodedSize(ThisPtr->updateDaCMode);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpUpdateDaCMode_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpUpdateDaCMode_Notification_t);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpUpdateDaCMode_Notification_Print(Icb_OpUpdateDaCMode_Notification ThisPtr) {
    ASN_PrintIndented("updateDaCMode" EOL);
    ASN_PrintSetIndent(1);
    Icb_UpdateDacMode_Print(ThisPtr->updateDaCMode);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpUpdateDaCMode_Notification_Decode(Icb_OpUpdateDaCMode_Notification ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_UpdateDacMode_Decode(&ThisPtr->updateDaCMode, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpUpdateDaCMode_Notification_Encode(Icb_OpUpdateDaCMode_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_UpdateDacMode_Encode(ThisPtr->updateDaCMode, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpUpdateDaCMode_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpApprovalStatus_Response of type ASNSequence
 */

Icb_OpApprovalStatus_Response Icb_OpApprovalStatus_Response_Create(ASN_Session session) {
    Icb_OpApprovalStatus_Response value =
            (Icb_OpApprovalStatus_Response)ASN_Malloc(session, sizeof(struct Icb_OpApprovalStatus_Response_t));
    if (value != (Icb_OpApprovalStatus_Response)NULL) {
        value->status = Icb_ArrayOf_ApprovalStatusType_Create(session);
    }
    return value;
}

U32 Icb_OpApprovalStatus_Response_EncodedSize(Icb_OpApprovalStatus_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_ApprovalStatusType_EncodedSize(ThisPtr->status, 0, 60);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpApprovalStatus_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpApprovalStatus_Response_t);
    length += Icb_ArrayOf_ApprovalStatusType_SessionSize(0, 60);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpApprovalStatus_Response_Print(Icb_OpApprovalStatus_Response ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_ApprovalStatusType_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpApprovalStatus_Response_Decode(Icb_OpApprovalStatus_Response ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_ApprovalStatusType_Decode(ThisPtr->status, session, stream, 0, 60));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpApprovalStatus_Response_Encode(Icb_OpApprovalStatus_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_ApprovalStatusType_Encode(ThisPtr->status, stream, 0, 60));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpApprovalStatus_Response of type ASNSequence
 */

/*
 * Start of Icb_OpApprovalStatus_Notification of type ASNSequence
 */

Icb_OpApprovalStatus_Notification Icb_OpApprovalStatus_Notification_Create(ASN_Session session) {
    Icb_OpApprovalStatus_Notification value =
            (Icb_OpApprovalStatus_Notification)ASN_Malloc(session, sizeof(struct Icb_OpApprovalStatus_Notification_t));
    if (value != (Icb_OpApprovalStatus_Notification)NULL) {
        value->status = Icb_ArrayOf_ApprovalStatusType_Create(session);
    }
    return value;
}

U32 Icb_OpApprovalStatus_Notification_EncodedSize(Icb_OpApprovalStatus_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_ApprovalStatusType_EncodedSize(ThisPtr->status, 0, 60);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpApprovalStatus_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpApprovalStatus_Notification_t);
    length += Icb_ArrayOf_ApprovalStatusType_SessionSize(0, 60);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpApprovalStatus_Notification_Print(Icb_OpApprovalStatus_Notification ThisPtr) {
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_ApprovalStatusType_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpApprovalStatus_Notification_Decode(Icb_OpApprovalStatus_Notification ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_ApprovalStatusType_Decode(ThisPtr->status, session, stream, 0, 60));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpApprovalStatus_Notification_Encode(Icb_OpApprovalStatus_Notification ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_ApprovalStatusType_Encode(ThisPtr->status, stream, 0, 60));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpApprovalStatus_Notification of type ASNSequence
 */

/*
 * Start of Icb_OpDownloadStatus_Response of type ASNSequence
 */

Icb_OpDownloadStatus_Response Icb_OpDownloadStatus_Response_Create(ASN_Session session) {
    Icb_OpDownloadStatus_Response value =
            (Icb_OpDownloadStatus_Response)ASN_Malloc(session, sizeof(struct Icb_OpDownloadStatus_Response_t));
    if (value != (Icb_OpDownloadStatus_Response)NULL) {
        value->exists__optional__downloadList = 0;
        value->downloadStatus = 0;
        value->downloadList = Icb_ArrayOf_SoftwareProduct_Create(session);
    }
    return value;
}

U32 Icb_OpDownloadStatus_Response_EncodedSize(Icb_OpDownloadStatus_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__downloadList);
    length += Icb_DownloadStatus_EncodedSize(ThisPtr->downloadStatus);
    if (ThisPtr->exists__optional__downloadList == TRUE) {
        length += Icb_ArrayOf_SoftwareProduct_EncodedSize(ThisPtr->downloadList, 1, 100);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpDownloadStatus_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpDownloadStatus_Response_t);
    length += Icb_ArrayOf_SoftwareProduct_SessionSize(1, 100);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpDownloadStatus_Response_Print(Icb_OpDownloadStatus_Response ThisPtr) {
    ASN_PrintIndented("exists__optional__downloadList" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__downloadList);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("downloadStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_DownloadStatus_Print(ThisPtr->downloadStatus);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__downloadList == TRUE) {
        ASN_PrintIndented("downloadList" EOL);
        ASN_PrintSetIndent(1);
        Icb_ArrayOf_SoftwareProduct_Print(ThisPtr->downloadList);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpDownloadStatus_Response_Decode(Icb_OpDownloadStatus_Response ThisPtr, ASN_Session session,
                                                ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__downloadList, session, stream));
    ASN_DECODE_CHECK(Icb_DownloadStatus_Decode(&ThisPtr->downloadStatus, session, stream));
    if (ThisPtr->exists__optional__downloadList == TRUE) {
        ASN_DECODE_CHECK(Icb_ArrayOf_SoftwareProduct_Decode(ThisPtr->downloadList, session, stream, 1, 100));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpDownloadStatus_Response_Encode(Icb_OpDownloadStatus_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__downloadList, stream));
    ASN_ENCODE_CHECK(Icb_DownloadStatus_Encode(ThisPtr->downloadStatus, stream));
    if (ThisPtr->exists__optional__downloadList == TRUE) {
        ASN_ENCODE_CHECK(Icb_ArrayOf_SoftwareProduct_Encode(ThisPtr->downloadList, stream, 1, 100));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpDownloadStatus_Response of type ASNSequence
 */

/*
 * Start of Icb_SoftwareProduct of type ASNSequence
 */

Icb_SoftwareProduct Icb_SoftwareProduct_Create(ASN_Session session) {
    Icb_SoftwareProduct value = (Icb_SoftwareProduct)ASN_Malloc(session, sizeof(struct Icb_SoftwareProduct_t));
    if (value != (Icb_SoftwareProduct)NULL) {
        value->exists__optional__progress = 0;
        value->id = Icb_UUID_Create(session);
        value->downloadState = 0;
        value->progress = 0;
    }
    return value;
}

U32 Icb_SoftwareProduct_EncodedSize(Icb_SoftwareProduct ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__progress);
    length += Icb_UUID_EncodedSize(ThisPtr->id);
    length += Icb_DownloadState_EncodedSize(ThisPtr->downloadState);
    if (ThisPtr->exists__optional__progress == TRUE) {
        length += Icb_DownloadProgress_EncodedSize(ThisPtr->progress);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_SoftwareProduct_SessionSize() {
    U32 length = sizeof(struct Icb_SoftwareProduct_t);
    length += Icb_UUID_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_SoftwareProduct_Print(Icb_SoftwareProduct ThisPtr) {
    ASN_PrintIndented("exists__optional__progress" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__progress);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("id" EOL);
    ASN_PrintSetIndent(1);
    Icb_UUID_Print(ThisPtr->id);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("downloadState" EOL);
    ASN_PrintSetIndent(1);
    Icb_DownloadState_Print(ThisPtr->downloadState);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__progress == TRUE) {
        ASN_PrintIndented("progress" EOL);
        ASN_PrintSetIndent(1);
        Icb_DownloadProgress_Print(ThisPtr->progress);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_SoftwareProduct_Decode(Icb_SoftwareProduct ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__progress, session, stream));
    ASN_DECODE_CHECK(Icb_UUID_Decode(ThisPtr->id, session, stream));
    ASN_DECODE_CHECK(Icb_DownloadState_Decode(&ThisPtr->downloadState, session, stream));
    if (ThisPtr->exists__optional__progress == TRUE) {
        ASN_DECODE_CHECK(Icb_DownloadProgress_Decode(&ThisPtr->progress, session, stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_SoftwareProduct_Encode(Icb_SoftwareProduct ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__progress, stream));
    ASN_ENCODE_CHECK(Icb_UUID_Encode(ThisPtr->id, stream));
    ASN_ENCODE_CHECK(Icb_DownloadState_Encode(ThisPtr->downloadState, stream));
    if (ThisPtr->exists__optional__progress == TRUE) {
        ASN_ENCODE_CHECK(Icb_DownloadProgress_Encode(ThisPtr->progress, stream));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_SoftwareProduct of type ASNSequence
 */

/*
 * Start of Icb_OpDownloadSoftware_SetRequest of type ASNSequence
 */

Icb_OpDownloadSoftware_SetRequest Icb_OpDownloadSoftware_SetRequest_Create(ASN_Session session) {
    Icb_OpDownloadSoftware_SetRequest value =
            (Icb_OpDownloadSoftware_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpDownloadSoftware_SetRequest_t));
    if (value != (Icb_OpDownloadSoftware_SetRequest)NULL) {
        value->downloadList = Icb_ArrayOf_UUID_Create(session);
    }
    return value;
}

U32 Icb_OpDownloadSoftware_SetRequest_EncodedSize(Icb_OpDownloadSoftware_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_UUID_EncodedSize(ThisPtr->downloadList, 0, 100);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpDownloadSoftware_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpDownloadSoftware_SetRequest_t);
    length += Icb_ArrayOf_UUID_SessionSize(0, 100);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpDownloadSoftware_SetRequest_Print(Icb_OpDownloadSoftware_SetRequest ThisPtr) {
    ASN_PrintIndented("downloadList" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_UUID_Print(ThisPtr->downloadList);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpDownloadSoftware_SetRequest_Decode(Icb_OpDownloadSoftware_SetRequest ThisPtr, ASN_Session session,
                                                    ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_UUID_Decode(ThisPtr->downloadList, session, stream, 0, 100));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpDownloadSoftware_SetRequest_Encode(Icb_OpDownloadSoftware_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_UUID_Encode(ThisPtr->downloadList, stream, 0, 100));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpDownloadSoftware_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpDeletedSoftware_SetRequest of type ASNSequence
 */

Icb_OpDeletedSoftware_SetRequest Icb_OpDeletedSoftware_SetRequest_Create(ASN_Session session) {
    Icb_OpDeletedSoftware_SetRequest value =
            (Icb_OpDeletedSoftware_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpDeletedSoftware_SetRequest_t));
    if (value != (Icb_OpDeletedSoftware_SetRequest)NULL) {
        value->deletedSoftware = Icb_ArrayOf_PartIdentifier_Create(session);
    }
    return value;
}

U32 Icb_OpDeletedSoftware_SetRequest_EncodedSize(Icb_OpDeletedSoftware_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_ArrayOf_PartIdentifier_EncodedSize(ThisPtr->deletedSoftware, 0, 100);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpDeletedSoftware_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpDeletedSoftware_SetRequest_t);
    length += Icb_ArrayOf_PartIdentifier_SessionSize(0, 100);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpDeletedSoftware_SetRequest_Print(Icb_OpDeletedSoftware_SetRequest ThisPtr) {
    ASN_PrintIndented("deletedSoftware" EOL);
    ASN_PrintSetIndent(1);
    Icb_ArrayOf_PartIdentifier_Print(ThisPtr->deletedSoftware);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpDeletedSoftware_SetRequest_Decode(Icb_OpDeletedSoftware_SetRequest ThisPtr, ASN_Session session,
                                                   ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_ArrayOf_PartIdentifier_Decode(ThisPtr->deletedSoftware, session, stream, 0, 100));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpDeletedSoftware_SetRequest_Encode(Icb_OpDeletedSoftware_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_ArrayOf_PartIdentifier_Encode(ThisPtr->deletedSoftware, stream, 0, 100));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpDeletedSoftware_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpDeviceInstall_SetRequest of type ASNSequence
 */

Icb_OpDeviceInstall_SetRequest Icb_OpDeviceInstall_SetRequest_Create(ASN_Session session) {
    Icb_OpDeviceInstall_SetRequest value =
            (Icb_OpDeviceInstall_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpDeviceInstall_SetRequest_t));
    if (value != (Icb_OpDeviceInstall_SetRequest)NULL) {
        value->exists__optional__installList = 0;
        value->installCommand = 0;
        value->installList = Icb_ArrayOf_InstallationData_Create(session);
    }
    return value;
}

U32 Icb_OpDeviceInstall_SetRequest_EncodedSize(Icb_OpDeviceInstall_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__installList);
    length += Icb_InstallCommand_EncodedSize(ThisPtr->installCommand);
    if (ThisPtr->exists__optional__installList == TRUE) {
        length += Icb_ArrayOf_InstallationData_EncodedSize(ThisPtr->installList, 0, 100);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpDeviceInstall_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpDeviceInstall_SetRequest_t);
    length += Icb_ArrayOf_InstallationData_SessionSize(0, 100);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpDeviceInstall_SetRequest_Print(Icb_OpDeviceInstall_SetRequest ThisPtr) {
    ASN_PrintIndented("exists__optional__installList" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__installList);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("installCommand" EOL);
    ASN_PrintSetIndent(1);
    Icb_InstallCommand_Print(ThisPtr->installCommand);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__installList == TRUE) {
        ASN_PrintIndented("installList" EOL);
        ASN_PrintSetIndent(1);
        Icb_ArrayOf_InstallationData_Print(ThisPtr->installList);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpDeviceInstall_SetRequest_Decode(Icb_OpDeviceInstall_SetRequest ThisPtr, ASN_Session session,
                                                 ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__installList, session, stream));
    ASN_DECODE_CHECK(Icb_InstallCommand_Decode(&ThisPtr->installCommand, session, stream));
    if (ThisPtr->exists__optional__installList == TRUE) {
        ASN_DECODE_CHECK(Icb_ArrayOf_InstallationData_Decode(ThisPtr->installList, session, stream, 0, 100));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpDeviceInstall_SetRequest_Encode(Icb_OpDeviceInstall_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__installList, stream));
    ASN_ENCODE_CHECK(Icb_InstallCommand_Encode(ThisPtr->installCommand, stream));
    if (ThisPtr->exists__optional__installList == TRUE) {
        ASN_ENCODE_CHECK(Icb_ArrayOf_InstallationData_Encode(ThisPtr->installList, stream, 0, 100));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpDeviceInstall_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpDeviceInstall_Response of type ASNSequence
 */

Icb_OpDeviceInstall_Response Icb_OpDeviceInstall_Response_Create(ASN_Session session) {
    Icb_OpDeviceInstall_Response value =
            (Icb_OpDeviceInstall_Response)ASN_Malloc(session, sizeof(struct Icb_OpDeviceInstall_Response_t));
    if (value != (Icb_OpDeviceInstall_Response)NULL) {
        value->exists__optional__installProgress = 0;
        value->exists__optional__installedList = 0;
        value->status = 0;
        value->installProgress = 0;
        value->installedList = Icb_ArrayOf_InstalledData_Create(session);
    }
    return value;
}

U32 Icb_OpDeviceInstall_Response_EncodedSize(Icb_OpDeviceInstall_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__installProgress);
    length += BOOL_EncodedSize(ThisPtr->exists__optional__installedList);
    length += Icb_InstallStatus_EncodedSize(ThisPtr->status);
    if (ThisPtr->exists__optional__installProgress == TRUE) {
        length += Icb_InstallProgress_EncodedSize(ThisPtr->installProgress);
    }
    if (ThisPtr->exists__optional__installedList == TRUE) {
        length += Icb_ArrayOf_InstalledData_EncodedSize(ThisPtr->installedList, 0, 100);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpDeviceInstall_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpDeviceInstall_Response_t);
    length += Icb_ArrayOf_InstalledData_SessionSize(0, 100);
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpDeviceInstall_Response_Print(Icb_OpDeviceInstall_Response ThisPtr) {
    ASN_PrintIndented("exists__optional__installProgress" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__installProgress);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("exists__optional__installedList" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__installedList);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("status" EOL);
    ASN_PrintSetIndent(1);
    Icb_InstallStatus_Print(ThisPtr->status);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__installProgress == TRUE) {
        ASN_PrintIndented("installProgress" EOL);
        ASN_PrintSetIndent(1);
        Icb_InstallProgress_Print(ThisPtr->installProgress);
        ASN_PrintSetIndent(-1);
    }
    if (ThisPtr->exists__optional__installedList == TRUE) {
        ASN_PrintIndented("installedList" EOL);
        ASN_PrintSetIndent(1);
        Icb_ArrayOf_InstalledData_Print(ThisPtr->installedList);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpDeviceInstall_Response_Decode(Icb_OpDeviceInstall_Response ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__installProgress, session, stream));
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__installedList, session, stream));
    ASN_DECODE_CHECK(Icb_InstallStatus_Decode(&ThisPtr->status, session, stream));
    if (ThisPtr->exists__optional__installProgress == TRUE) {
        ASN_DECODE_CHECK(Icb_InstallProgress_Decode(&ThisPtr->installProgress, session, stream));
    }
    if (ThisPtr->exists__optional__installedList == TRUE) {
        ASN_DECODE_CHECK(Icb_ArrayOf_InstalledData_Decode(ThisPtr->installedList, session, stream, 0, 100));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpDeviceInstall_Response_Encode(Icb_OpDeviceInstall_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__installProgress, stream));
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__installedList, stream));
    ASN_ENCODE_CHECK(Icb_InstallStatus_Encode(ThisPtr->status, stream));
    if (ThisPtr->exists__optional__installProgress == TRUE) {
        ASN_ENCODE_CHECK(Icb_InstallProgress_Encode(ThisPtr->installProgress, stream));
    }
    if (ThisPtr->exists__optional__installedList == TRUE) {
        ASN_ENCODE_CHECK(Icb_ArrayOf_InstalledData_Encode(ThisPtr->installedList, stream, 0, 100));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpDeviceInstall_Response of type ASNSequence
 */

/*
 * Start of Icb_InstalledData of type ASNSequence
 */

Icb_InstalledData Icb_InstalledData_Create(ASN_Session session) {
    Icb_InstalledData value = (Icb_InstalledData)ASN_Malloc(session, sizeof(struct Icb_InstalledData_t));
    if (value != (Icb_InstalledData)NULL) {
        value->identifier = Icb_PartIdentifier_Create(session);
        value->fileStatus = 0;
    }
    return value;
}

U32 Icb_InstalledData_EncodedSize(Icb_InstalledData ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_PartIdentifier_EncodedSize(ThisPtr->identifier);
    length += Icb_FileInstallationStatus_EncodedSize(ThisPtr->fileStatus);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_InstalledData_SessionSize() {
    U32 length = sizeof(struct Icb_InstalledData_t);
    length += Icb_PartIdentifier_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_InstalledData_Print(Icb_InstalledData ThisPtr) {
    ASN_PrintIndented("identifier" EOL);
    ASN_PrintSetIndent(1);
    Icb_PartIdentifier_Print(ThisPtr->identifier);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("fileStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_FileInstallationStatus_Print(ThisPtr->fileStatus);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_InstalledData_Decode(Icb_InstalledData ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_PartIdentifier_Decode(ThisPtr->identifier, session, stream));
    ASN_DECODE_CHECK(Icb_FileInstallationStatus_Decode(&ThisPtr->fileStatus, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_InstalledData_Encode(Icb_InstalledData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_PartIdentifier_Encode(ThisPtr->identifier, stream));
    ASN_ENCODE_CHECK(Icb_FileInstallationStatus_Encode(ThisPtr->fileStatus, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_InstalledData of type ASNSequence
 */

/*
 * Start of Icb_OpEcallSettings_SetRequest of type ASNSequence
 */

Icb_OpEcallSettings_SetRequest Icb_OpEcallSettings_SetRequest_Create(ASN_Session session) {
    Icb_OpEcallSettings_SetRequest value =
            (Icb_OpEcallSettings_SetRequest)ASN_Malloc(session, sizeof(struct Icb_OpEcallSettings_SetRequest_t));
    if (value != (Icb_OpEcallSettings_SetRequest)NULL) {
        value->exists__optional__ecallSetting = 0;
        value->ecallSetting = Icb_EcalSettings_Create(session);
    }
    return value;
}

U32 Icb_OpEcallSettings_SetRequest_EncodedSize(Icb_OpEcallSettings_SetRequest ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += BOOL_EncodedSize(ThisPtr->exists__optional__ecallSetting);
    if (ThisPtr->exists__optional__ecallSetting == TRUE) {
        length += Icb_EcalSettings_EncodedSize(ThisPtr->ecallSetting);
    }
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpEcallSettings_SetRequest_SessionSize() {
    U32 length = sizeof(struct Icb_OpEcallSettings_SetRequest_t);
    length += Icb_EcalSettings_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpEcallSettings_SetRequest_Print(Icb_OpEcallSettings_SetRequest ThisPtr) {
    ASN_PrintIndented("exists__optional__ecallSetting" EOL);
    ASN_PrintSetIndent(1);
    BOOL_Print(ThisPtr->exists__optional__ecallSetting);
    ASN_PrintSetIndent(-1);
    if (ThisPtr->exists__optional__ecallSetting == TRUE) {
        ASN_PrintIndented("ecallSetting" EOL);
        ASN_PrintSetIndent(1);
        Icb_EcalSettings_Print(ThisPtr->ecallSetting);
        ASN_PrintSetIndent(-1);
    }
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpEcallSettings_SetRequest_Decode(Icb_OpEcallSettings_SetRequest ThisPtr, ASN_Session session,
                                                 ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(BOOL_Decode(&ThisPtr->exists__optional__ecallSetting, session, stream));
    if (ThisPtr->exists__optional__ecallSetting == TRUE) {
        ASN_DECODE_CHECK(Icb_EcalSettings_Decode(ThisPtr->ecallSetting, session, stream));
    }
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpEcallSettings_SetRequest_Encode(Icb_OpEcallSettings_SetRequest ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(BOOL_Encode(ThisPtr->exists__optional__ecallSetting, stream));
    if (ThisPtr->exists__optional__ecallSetting == TRUE) {
        ASN_ENCODE_CHECK(Icb_EcalSettings_Encode(ThisPtr->ecallSetting, stream));
    }
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpEcallSettings_SetRequest of type ASNSequence
 */

/*
 * Start of Icb_OpEcallSettings_Response of type ASNSequence
 */

Icb_OpEcallSettings_Response Icb_OpEcallSettings_Response_Create(ASN_Session session) {
    Icb_OpEcallSettings_Response value =
            (Icb_OpEcallSettings_Response)ASN_Malloc(session, sizeof(struct Icb_OpEcallSettings_Response_t));
    if (value != (Icb_OpEcallSettings_Response)NULL) {
        value->ecallSetting = Icb_EcalSettings_Create(session);
    }
    return value;
}

U32 Icb_OpEcallSettings_Response_EncodedSize(Icb_OpEcallSettings_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_EcalSettings_EncodedSize(ThisPtr->ecallSetting);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpEcallSettings_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpEcallSettings_Response_t);
    length += Icb_EcalSettings_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpEcallSettings_Response_Print(Icb_OpEcallSettings_Response ThisPtr) {
    ASN_PrintIndented("ecallSetting" EOL);
    ASN_PrintSetIndent(1);
    Icb_EcalSettings_Print(ThisPtr->ecallSetting);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpEcallSettings_Response_Decode(Icb_OpEcallSettings_Response ThisPtr, ASN_Session session,
                                               ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_EcalSettings_Decode(ThisPtr->ecallSetting, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpEcallSettings_Response_Encode(Icb_OpEcallSettings_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_EcalSettings_Encode(ThisPtr->ecallSetting, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpEcallSettings_Response of type ASNSequence
 */

/*
 * Start of Icb_ClimateTimer of type ASNSequence
 */

Icb_ClimateTimer Icb_ClimateTimer_Create(ASN_Session session) {
    Icb_ClimateTimer value = (Icb_ClimateTimer)ASN_Malloc(session, sizeof(struct Icb_ClimateTimer_t));
    if (value != (Icb_ClimateTimer)NULL) {
        value->id = 0;
        value->timerStatus = 0;
        value->timerType = 0;
        value->days = Icb_TimerDays_Create(session);
        value->time = Icb_DateTime_Create(session);
    }
    return value;
}

U32 Icb_ClimateTimer_EncodedSize(Icb_ClimateTimer ThisPtr) {
    U32 length = 0;
    length += U32_EncodedSize(ThisPtr->id, 1, 32);
    length += Icb_TimerStatus_EncodedSize(ThisPtr->timerStatus);
    length += Icb_TimerType_EncodedSize(ThisPtr->timerType);
    length += Icb_TimerDays_EncodedSize(ThisPtr->days);
    length += Icb_DateTime_EncodedSize(ThisPtr->time);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_ClimateTimer_SessionSize() {
    U32 length = sizeof(struct Icb_ClimateTimer_t);
    length += Icb_TimerDays_SessionSize();
    length += Icb_DateTime_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_ClimateTimer_Print(Icb_ClimateTimer ThisPtr) {
    ASN_PrintIndented("id" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->id);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("timerStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_TimerStatus_Print(ThisPtr->timerStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("timerType" EOL);
    ASN_PrintSetIndent(1);
    Icb_TimerType_Print(ThisPtr->timerType);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("days" EOL);
    ASN_PrintSetIndent(1);
    Icb_TimerDays_Print(ThisPtr->days);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("time" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->time);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_ClimateTimer_Decode(Icb_ClimateTimer ThisPtr, ASN_Session session, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->id, session, stream, 1, 32));
    ASN_DECODE_CHECK(Icb_TimerStatus_Decode(&ThisPtr->timerStatus, session, stream));
    ASN_DECODE_CHECK(Icb_TimerType_Decode(&ThisPtr->timerType, session, stream));
    ASN_DECODE_CHECK(Icb_TimerDays_Decode(ThisPtr->days, session, stream));
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->time, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_ClimateTimer_Encode(Icb_ClimateTimer ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->id, stream, 1, 32));
    ASN_ENCODE_CHECK(Icb_TimerStatus_Encode(ThisPtr->timerStatus, stream));
    ASN_ENCODE_CHECK(Icb_TimerType_Encode(ThisPtr->timerType, stream));
    ASN_ENCODE_CHECK(Icb_TimerDays_Encode(ThisPtr->days, stream));
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->time, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_ClimateTimer of type ASNSequence
 */

/*
 * Start of Icb_OpWLANChannelFreqInfo_Notification of type ASNSequence
 */

Icb_OpWLANChannelFreqInfo_Notification Icb_OpWLANChannelFreqInfo_Notification_Create(ASN_Session session) {
    Icb_OpWLANChannelFreqInfo_Notification value = (Icb_OpWLANChannelFreqInfo_Notification)ASN_Malloc(
            session, sizeof(struct Icb_OpWLANChannelFreqInfo_Notification_t));
    if (value != (Icb_OpWLANChannelFreqInfo_Notification)NULL) {
        value->wLANChannelInfo = Icb_WLANChannelInfo_Create(session);
    }
    return value;
}

U32 Icb_OpWLANChannelFreqInfo_Notification_EncodedSize(Icb_OpWLANChannelFreqInfo_Notification ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_WLANChannelInfo_EncodedSize(ThisPtr->wLANChannelInfo);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpWLANChannelFreqInfo_Notification_SessionSize() {
    U32 length = sizeof(struct Icb_OpWLANChannelFreqInfo_Notification_t);
    length += Icb_WLANChannelInfo_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpWLANChannelFreqInfo_Notification_Print(Icb_OpWLANChannelFreqInfo_Notification ThisPtr) {
    ASN_PrintIndented("wLANChannelInfo" EOL);
    ASN_PrintSetIndent(1);
    Icb_WLANChannelInfo_Print(ThisPtr->wLANChannelInfo);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpWLANChannelFreqInfo_Notification_Decode(Icb_OpWLANChannelFreqInfo_Notification ThisPtr,
                                                         ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_WLANChannelInfo_Decode(ThisPtr->wLANChannelInfo, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpWLANChannelFreqInfo_Notification_Encode(Icb_OpWLANChannelFreqInfo_Notification ThisPtr,
                                                         ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_WLANChannelInfo_Encode(ThisPtr->wLANChannelInfo, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpWLANChannelFreqInfo_Notification of type ASNSequence
 */

/*
 * Start of Icb_GNSSData of type ASNSequence
 */

Icb_GNSSData Icb_GNSSData_Create(ASN_Session session) {
    Icb_GNSSData value = (Icb_GNSSData)ASN_Malloc(session, sizeof(struct Icb_GNSSData_t));
    if (value != (Icb_GNSSData)NULL) {
        value->utcTime = Icb_DateTime_Create(session);
        value->gpsTime = Icb_GPSSystemTime_Create(session);
        value->position = Icb_GeographicalPosition_Create(session);
        value->movement = Icb_Velocity_Create(session);
        value->heading = 0;
        value->gnssStatus = Icb_GNSSUsage_Create(session);
        value->positioningStatus = Icb_GNSSStatus_Create(session);
        value->satelliteInfo = Icb_SatelliteUsage_Create(session);
        value->precision = Icb_DOPValues_Create(session);
        value->receiverChannels = Icb_ReceiverChannelData_Create(session);
    }
    return value;
}

U32 Icb_GNSSData_EncodedSize(Icb_GNSSData ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_DateTime_EncodedSize(ThisPtr->utcTime);
    length += Icb_GPSSystemTime_EncodedSize(ThisPtr->gpsTime);
    length += Icb_GeographicalPosition_EncodedSize(ThisPtr->position);
    length += Icb_Velocity_EncodedSize(ThisPtr->movement);
    length += U32_EncodedSize(ThisPtr->heading, 0, 35999);
    length += Icb_GNSSUsage_EncodedSize(ThisPtr->gnssStatus);
    length += Icb_GNSSStatus_EncodedSize(ThisPtr->positioningStatus);
    length += Icb_SatelliteUsage_EncodedSize(ThisPtr->satelliteInfo);
    length += Icb_DOPValues_EncodedSize(ThisPtr->precision);
    length += Icb_ReceiverChannelData_EncodedSize(ThisPtr->receiverChannels);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_GNSSData_SessionSize() {
    U32 length = sizeof(struct Icb_GNSSData_t);
    length += Icb_DateTime_SessionSize();
    length += Icb_GPSSystemTime_SessionSize();
    length += Icb_GeographicalPosition_SessionSize();
    length += Icb_Velocity_SessionSize();
    length += Icb_GNSSUsage_SessionSize();
    length += Icb_GNSSStatus_SessionSize();
    length += Icb_SatelliteUsage_SessionSize();
    length += Icb_DOPValues_SessionSize();
    length += Icb_ReceiverChannelData_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_GNSSData_Print(Icb_GNSSData ThisPtr) {
    ASN_PrintIndented("utcTime" EOL);
    ASN_PrintSetIndent(1);
    Icb_DateTime_Print(ThisPtr->utcTime);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("gpsTime" EOL);
    ASN_PrintSetIndent(1);
    Icb_GPSSystemTime_Print(ThisPtr->gpsTime);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("position" EOL);
    ASN_PrintSetIndent(1);
    Icb_GeographicalPosition_Print(ThisPtr->position);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("movement" EOL);
    ASN_PrintSetIndent(1);
    Icb_Velocity_Print(ThisPtr->movement);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("heading" EOL);
    ASN_PrintSetIndent(1);
    U32_Print(ThisPtr->heading);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("gnssStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_GNSSUsage_Print(ThisPtr->gnssStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("positioningStatus" EOL);
    ASN_PrintSetIndent(1);
    Icb_GNSSStatus_Print(ThisPtr->positioningStatus);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("satelliteInfo" EOL);
    ASN_PrintSetIndent(1);
    Icb_SatelliteUsage_Print(ThisPtr->satelliteInfo);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("precision" EOL);
    ASN_PrintSetIndent(1);
    Icb_DOPValues_Print(ThisPtr->precision);
    ASN_PrintSetIndent(-1);
    ASN_PrintIndented("receiverChannels" EOL);
    ASN_PrintSetIndent(1);
    Icb_ReceiverChannelData_Print(ThisPtr->receiverChannels);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_GNSSData_Decode(Icb_GNSSData ThisPtr, ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_DateTime_Decode(ThisPtr->utcTime, session, stream));
    ASN_DECODE_CHECK(Icb_GPSSystemTime_Decode(ThisPtr->gpsTime, session, stream));
    ASN_DECODE_CHECK(Icb_GeographicalPosition_Decode(ThisPtr->position, session, stream));
    ASN_DECODE_CHECK(Icb_Velocity_Decode(ThisPtr->movement, session, stream));
    ASN_DECODE_CHECK(U32_Decode(&ThisPtr->heading, session, stream, 0, 35999));
    ASN_DECODE_CHECK(Icb_GNSSUsage_Decode(ThisPtr->gnssStatus, session, stream));
    ASN_DECODE_CHECK(Icb_GNSSStatus_Decode(ThisPtr->positioningStatus, session, stream));
    ASN_DECODE_CHECK(Icb_SatelliteUsage_Decode(ThisPtr->satelliteInfo, session, stream));
    ASN_DECODE_CHECK(Icb_DOPValues_Decode(ThisPtr->precision, session, stream));
    ASN_DECODE_CHECK(Icb_ReceiverChannelData_Decode(ThisPtr->receiverChannels, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_GNSSData_Encode(Icb_GNSSData ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_DateTime_Encode(ThisPtr->utcTime, stream));
    ASN_ENCODE_CHECK(Icb_GPSSystemTime_Encode(ThisPtr->gpsTime, stream));
    ASN_ENCODE_CHECK(Icb_GeographicalPosition_Encode(ThisPtr->position, stream));
    ASN_ENCODE_CHECK(Icb_Velocity_Encode(ThisPtr->movement, stream));
    ASN_ENCODE_CHECK(U32_Encode(ThisPtr->heading, stream, 0, 35999));
    ASN_ENCODE_CHECK(Icb_GNSSUsage_Encode(ThisPtr->gnssStatus, stream));
    ASN_ENCODE_CHECK(Icb_GNSSStatus_Encode(ThisPtr->positioningStatus, stream));
    ASN_ENCODE_CHECK(Icb_SatelliteUsage_Encode(ThisPtr->satelliteInfo, stream));
    ASN_ENCODE_CHECK(Icb_DOPValues_Encode(ThisPtr->precision, stream));
    ASN_ENCODE_CHECK(Icb_ReceiverChannelData_Encode(ThisPtr->receiverChannels, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_GNSSData of type ASNSequence
 */

/*
 * Start of Icb_OpGNSSPositionDataAccuracy_Response of type ASNSequence
 */

Icb_OpGNSSPositionDataAccuracy_Response Icb_OpGNSSPositionDataAccuracy_Response_Create(ASN_Session session) {
    Icb_OpGNSSPositionDataAccuracy_Response value = (Icb_OpGNSSPositionDataAccuracy_Response)ASN_Malloc(
            session, sizeof(struct Icb_OpGNSSPositionDataAccuracy_Response_t));
    if (value != (Icb_OpGNSSPositionDataAccuracy_Response)NULL) {
        value->gnssPositionDataAccuracy = Icb_GNSSDataAccuracy_Create(session);
    }
    return value;
}

U32 Icb_OpGNSSPositionDataAccuracy_Response_EncodedSize(Icb_OpGNSSPositionDataAccuracy_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_GNSSDataAccuracy_EncodedSize(ThisPtr->gnssPositionDataAccuracy);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpGNSSPositionDataAccuracy_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpGNSSPositionDataAccuracy_Response_t);
    length += Icb_GNSSDataAccuracy_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpGNSSPositionDataAccuracy_Response_Print(Icb_OpGNSSPositionDataAccuracy_Response ThisPtr) {
    ASN_PrintIndented("gnssPositionDataAccuracy" EOL);
    ASN_PrintSetIndent(1);
    Icb_GNSSDataAccuracy_Print(ThisPtr->gnssPositionDataAccuracy);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpGNSSPositionDataAccuracy_Response_Decode(Icb_OpGNSSPositionDataAccuracy_Response ThisPtr,
                                                          ASN_Session session, ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_GNSSDataAccuracy_Decode(ThisPtr->gnssPositionDataAccuracy, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGNSSPositionDataAccuracy_Response_Encode(Icb_OpGNSSPositionDataAccuracy_Response ThisPtr,
                                                          ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_GNSSDataAccuracy_Encode(ThisPtr->gnssPositionDataAccuracy, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpGNSSPositionDataAccuracy_Response of type ASNSequence
 */

/*
 * Start of Icb_OpGNSSPositionData_Response of type ASNSequence
 */

Icb_OpGNSSPositionData_Response Icb_OpGNSSPositionData_Response_Create(ASN_Session session) {
    Icb_OpGNSSPositionData_Response value =
            (Icb_OpGNSSPositionData_Response)ASN_Malloc(session, sizeof(struct Icb_OpGNSSPositionData_Response_t));
    if (value != (Icb_OpGNSSPositionData_Response)NULL) {
        value->gnssPositionData = Icb_GNSSData_Create(session);
    }
    return value;
}

U32 Icb_OpGNSSPositionData_Response_EncodedSize(Icb_OpGNSSPositionData_Response ThisPtr) {
    U32 length = 0;
    length += 1;  // This type is extendable
    length += Icb_GNSSData_EncodedSize(ThisPtr->gnssPositionData);
    return length;
}

#ifdef ENABLE_ASN_SESSION_SIZE
U32 Icb_OpGNSSPositionData_Response_SessionSize() {
    U32 length = sizeof(struct Icb_OpGNSSPositionData_Response_t);
    length += Icb_GNSSData_SessionSize();
    return length;
}
#endif /* #ifdef ENABLE_ASN_SESSION_SIZE */

#ifdef ASN_PRINT
void Icb_OpGNSSPositionData_Response_Print(Icb_OpGNSSPositionData_Response ThisPtr) {
    ASN_PrintIndented("gnssPositionData" EOL);
    ASN_PrintSetIndent(1);
    Icb_GNSSData_Print(ThisPtr->gnssPositionData);
    ASN_PrintSetIndent(-1);
}
#endif /* #ifdef ASN_PRINT */

ASN_Result Icb_OpGNSSPositionData_Response_Decode(Icb_OpGNSSPositionData_Response ThisPtr, ASN_Session session,
                                                  ASN_Stream stream) {
    BOOL hasExtensions;
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_DECODE_CHECK(BOOL_Decode(&hasExtensions, session, stream));

    // 18.2
    ASN_DECODE_CHECK(Icb_GNSSData_Decode(ThisPtr->gnssPositionData, session, stream));
    return ASN_RESULT_OK;
}

ASN_Result Icb_OpGNSSPositionData_Response_Encode(Icb_OpGNSSPositionData_Response ThisPtr, ASN_Stream stream) {
    ASN_Result result = ASN_RESULT_OK;

    // X.691 Section 18

    // 18.1
    ASN_ENCODE_CHECK(BOOL_Encode(FALSE, stream));

    // 18.2
    ASN_ENCODE_CHECK(Icb_GNSSData_Encode(ThisPtr->gnssPositionData, stream));
    return ASN_RESULT_OK;
}

/*
 * End of Icb_OpGNSSPositionData_Response of type ASNSequence
 */

// End of infotainmentIpBus.c
