/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201601121427.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#pragma once

#include <vector>
#include "CommonApiEnum.hpp"
#include "CommonTypes.hpp"

namespace v0 {
namespace org {
namespace volvocars {
namespace climate {

class ParkingClimate {
  public:
    virtual ~ParkingClimate() {}

    struct ParkingClimateRequest : CommonApiEnumeration<int32_t> {
        enum Literal : int32_t { OFF = 2, ON = 3 };

        ParkingClimateRequest() : CommonApiEnumeration<int32_t>(static_cast<int32_t>(Literal::OFF)) {}
        ParkingClimateRequest(Literal _literal) : CommonApiEnumeration<int32_t>(static_cast<int32_t>(_literal)) {}

        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OFF):
                case static_cast<int32_t>(Literal::ON):
                    return true;
                default:
                    return false;
            }
        }

        inline bool operator==(const ParkingClimateRequest& _other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ParkingClimateRequest& _other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ParkingClimateRequest& _other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ParkingClimateRequest& _other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ParkingClimateRequest& _other) const { return (value_ < _other.value_); }
        inline bool operator>(const ParkingClimateRequest& _other) const { return (value_ > _other.value_); }

        inline bool operator==(const Literal& _value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal& _value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal& _value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal& _value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal& _value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal& _value) const { return (value_ > static_cast<int32_t>(_value)); }
    };

    struct ParkingClimateState : CommonApiEnumeration<int32_t> {
        enum Literal : int32_t { OFF = 2, ON = 3, NOT_PRESENT = 0, DISABLED = 1 };

        ParkingClimateState() : CommonApiEnumeration<int32_t>(static_cast<int32_t>(Literal::OFF)) {}
        ParkingClimateState(Literal _literal) : CommonApiEnumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        ParkingClimateState& operator=(const ParkingClimateRequest::Literal& _value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }

        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OFF):
                case static_cast<int32_t>(Literal::ON):
                case static_cast<int32_t>(Literal::NOT_PRESENT):
                case static_cast<int32_t>(Literal::DISABLED):
                    return true;
                default:
                    return false;
            }
        }

        inline bool operator==(const ParkingClimateState& _other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ParkingClimateState& _other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ParkingClimateState& _other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ParkingClimateState& _other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ParkingClimateState& _other) const { return (value_ < _other.value_); }
        inline bool operator>(const ParkingClimateState& _other) const { return (value_ > _other.value_); }

        inline bool operator==(const Literal& _value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal& _value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal& _value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal& _value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal& _value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal& _value) const { return (value_ > static_cast<int32_t>(_value)); }
    };

    struct PreConditioningSettingRequest : CommonApiEnumeration<int32_t> {
        enum Literal : int32_t { OFF = 1, ON = 2 };

        PreConditioningSettingRequest() : CommonApiEnumeration<int32_t>(static_cast<int32_t>(Literal::OFF)) {}
        PreConditioningSettingRequest(Literal _literal)
            : CommonApiEnumeration<int32_t>(static_cast<int32_t>(_literal)) {}

        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OFF):
                case static_cast<int32_t>(Literal::ON):
                    return true;
                default:
                    return false;
            }
        }

        inline bool operator==(const PreConditioningSettingRequest& _other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PreConditioningSettingRequest& _other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PreConditioningSettingRequest& _other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PreConditioningSettingRequest& _other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PreConditioningSettingRequest& _other) const { return (value_ < _other.value_); }
        inline bool operator>(const PreConditioningSettingRequest& _other) const { return (value_ > _other.value_); }

        inline bool operator==(const Literal& _value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal& _value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal& _value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal& _value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal& _value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal& _value) const { return (value_ > static_cast<int32_t>(_value)); }
    };

    struct PreConditioningSettingState : CommonApiEnumeration<int32_t> {
        enum Literal : int32_t { OFF = 1, ON = 2, NOT_PRESENT = 0 };

        PreConditioningSettingState() : CommonApiEnumeration<int32_t>(static_cast<int32_t>(Literal::OFF)) {}
        PreConditioningSettingState(Literal _literal) : CommonApiEnumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        PreConditioningSettingState& operator=(const PreConditioningSettingRequest::Literal& _value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }

        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OFF):
                case static_cast<int32_t>(Literal::ON):
                case static_cast<int32_t>(Literal::NOT_PRESENT):
                    return true;
                default:
                    return false;
            }
        }

        inline bool operator==(const PreConditioningSettingState& _other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PreConditioningSettingState& _other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PreConditioningSettingState& _other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PreConditioningSettingState& _other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PreConditioningSettingState& _other) const { return (value_ < _other.value_); }
        inline bool operator>(const PreConditioningSettingState& _other) const { return (value_ > _other.value_); }

        inline bool operator==(const Literal& _value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal& _value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal& _value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal& _value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal& _value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal& _value) const { return (value_ > static_cast<int32_t>(_value)); }
    };

    struct PreCleaningNotificationState : CommonApiEnumeration<int32_t> {
        enum Literal : int32_t { NOT_VISIBLE = 0, COMPLETED = 1, LOW_BATTERY_ERROR = 2, INTERRUPTED = 3 };

        PreCleaningNotificationState() : CommonApiEnumeration<int32_t>(static_cast<int32_t>(Literal::NOT_VISIBLE)) {}
        PreCleaningNotificationState(Literal _literal)
            : CommonApiEnumeration<int32_t>(static_cast<int32_t>(_literal)) {}

        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NOT_VISIBLE):
                case static_cast<int32_t>(Literal::COMPLETED):
                case static_cast<int32_t>(Literal::LOW_BATTERY_ERROR):
                case static_cast<int32_t>(Literal::INTERRUPTED):
                    return true;
                default:
                    return false;
            }
        }

        inline bool operator==(const PreCleaningNotificationState& _other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PreCleaningNotificationState& _other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PreCleaningNotificationState& _other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PreCleaningNotificationState& _other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PreCleaningNotificationState& _other) const { return (value_ < _other.value_); }
        inline bool operator>(const PreCleaningNotificationState& _other) const { return (value_ > _other.value_); }

        inline bool operator==(const Literal& _value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal& _value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal& _value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal& _value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal& _value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal& _value) const { return (value_ > static_cast<int32_t>(_value)); }
    };

    struct TimerTypeEnum : CommonApiEnumeration<int32_t> {
        enum Literal : int32_t { SINGLE = 0, DAY = 1, REPEATED = 2 };

        TimerTypeEnum() : CommonApiEnumeration<int32_t>(static_cast<int32_t>(Literal::SINGLE)) {}
        TimerTypeEnum(Literal _literal) : CommonApiEnumeration<int32_t>(static_cast<int32_t>(_literal)) {}

        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SINGLE):
                case static_cast<int32_t>(Literal::DAY):
                case static_cast<int32_t>(Literal::REPEATED):
                    return true;
                default:
                    return false;
            }
        }

        inline bool operator==(const TimerTypeEnum& _other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TimerTypeEnum& _other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TimerTypeEnum& _other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TimerTypeEnum& _other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TimerTypeEnum& _other) const { return (value_ < _other.value_); }
        inline bool operator>(const TimerTypeEnum& _other) const { return (value_ > _other.value_); }

        inline bool operator==(const Literal& _value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal& _value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal& _value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal& _value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal& _value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal& _value) const { return (value_ > static_cast<int32_t>(_value)); }
    };

    struct WeekdayEnum : CommonApiEnumeration<int32_t> {
        enum Literal : int32_t {
            MONDAY = 0,
            TUESDAY = 1,
            WEDNESDAY = 2,
            THURSDAY = 3,
            FRIDAY = 4,
            SATURDAY = 5,
            SUNDAY = 6
        };

        WeekdayEnum() : CommonApiEnumeration<int32_t>(static_cast<int32_t>(Literal::MONDAY)) {}
        WeekdayEnum(Literal _literal) : CommonApiEnumeration<int32_t>(static_cast<int32_t>(_literal)) {}

        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MONDAY):
                case static_cast<int32_t>(Literal::TUESDAY):
                case static_cast<int32_t>(Literal::WEDNESDAY):
                case static_cast<int32_t>(Literal::THURSDAY):
                case static_cast<int32_t>(Literal::FRIDAY):
                case static_cast<int32_t>(Literal::SATURDAY):
                case static_cast<int32_t>(Literal::SUNDAY):
                    return true;
                default:
                    return false;
            }
        }

        inline bool operator==(const WeekdayEnum& _other) const { return (value_ == _other.value_); }
        inline bool operator!=(const WeekdayEnum& _other) const { return (value_ != _other.value_); }
        inline bool operator<=(const WeekdayEnum& _other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const WeekdayEnum& _other) const { return (value_ >= _other.value_); }
        inline bool operator<(const WeekdayEnum& _other) const { return (value_ < _other.value_); }
        inline bool operator>(const WeekdayEnum& _other) const { return (value_ > _other.value_); }

        inline bool operator==(const Literal& _value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal& _value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal& _value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal& _value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal& _value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal& _value) const { return (value_ > static_cast<int32_t>(_value)); }
    };

    struct TimerStateEnum : CommonApiEnumeration<int32_t> {
        enum Literal : int32_t { OFF = 0, ON = 1 };

        TimerStateEnum() : CommonApiEnumeration<int32_t>(static_cast<int32_t>(Literal::OFF)) {}
        TimerStateEnum(Literal _literal) : CommonApiEnumeration<int32_t>(static_cast<int32_t>(_literal)) {}

        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OFF):
                case static_cast<int32_t>(Literal::ON):
                    return true;
                default:
                    return false;
            }
        }

        inline bool operator==(const TimerStateEnum& _other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TimerStateEnum& _other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TimerStateEnum& _other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TimerStateEnum& _other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TimerStateEnum& _other) const { return (value_ < _other.value_); }
        inline bool operator>(const TimerStateEnum& _other) const { return (value_ > _other.value_); }

        inline bool operator==(const Literal& _value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal& _value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal& _value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal& _value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal& _value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal& _value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct DateTimeStruct : CommonAPI::Struct<uint16_t, uint16_t, uint16_t, uint16_t, uint16_t, uint16_t> {
        DateTimeStruct() {}
        DateTimeStruct(const uint16_t& _year,
                       const uint16_t& _month,
                       const uint16_t& _day,
                       const uint16_t& _hour,
                       const uint16_t& _minute,
                       const uint16_t& _second) {
            std::get<0>(values_) = _year;
            std::get<1>(values_) = _month;
            std::get<2>(values_) = _day;
            std::get<3>(values_) = _hour;
            std::get<4>(values_) = _minute;
            std::get<5>(values_) = _second;
        }
        inline const uint16_t& getYear() const { return std::get<0>(values_); }
        inline void setYear(const uint16_t& _value) { std::get<0>(values_) = _value; }
        inline const uint16_t& getMonth() const { return std::get<1>(values_); }
        inline void setMonth(const uint16_t& _value) { std::get<1>(values_) = _value; }
        inline const uint16_t& getDay() const { return std::get<2>(values_); }
        inline void setDay(const uint16_t& _value) { std::get<2>(values_) = _value; }
        inline const uint16_t& getHour() const { return std::get<3>(values_); }
        inline void setHour(const uint16_t& _value) { std::get<3>(values_) = _value; }
        inline const uint16_t& getMinute() const { return std::get<4>(values_); }
        inline void setMinute(const uint16_t& _value) { std::get<4>(values_) = _value; }
        inline const uint16_t& getSecond() const { return std::get<5>(values_); }
        inline void setSecond(const uint16_t& _value) { std::get<5>(values_) = _value; }
        inline bool operator==(const DateTimeStruct& _other) const {
            return (getYear() == _other.getYear() && getMonth() == _other.getMonth() && getDay() == _other.getDay() &&
                    getHour() == _other.getHour() && getMinute() == _other.getMinute() &&
                    getSecond() == _other.getSecond());
        }
        inline bool operator!=(const DateTimeStruct& _other) const { return !((*this) == _other); }
    };
    typedef std::vector<ParkingClimate::WeekdayEnum> WeekdaysVec;
    struct ParkingTimerStruct
            : CommonAPI::Struct<uint32_t, TimerTypeEnum, TimerStateEnum, DateTimeStruct, WeekdaysVec> {
        ParkingTimerStruct() {}
        ParkingTimerStruct(const uint32_t& _timerId,
                           const TimerTypeEnum& _timerType,
                           const TimerStateEnum& _active,
                           const DateTimeStruct& _dateTime,
                           const WeekdaysVec& _weekdays) {
            std::get<0>(values_) = _timerId;
            std::get<1>(values_) = _timerType;
            std::get<2>(values_) = _active;
            std::get<3>(values_) = _dateTime;
            std::get<4>(values_) = _weekdays;
        }
        inline const uint32_t& getTimerId() const { return std::get<0>(values_); }
        inline void setTimerId(const uint32_t& _value) { std::get<0>(values_) = _value; }
        inline const TimerTypeEnum& getTimerType() const { return std::get<1>(values_); }
        inline void setTimerType(const TimerTypeEnum& _value) { std::get<1>(values_) = _value; }
        inline const TimerStateEnum& getActive() const { return std::get<2>(values_); }
        inline void setActive(const TimerStateEnum& _value) { std::get<2>(values_) = _value; }
        inline const DateTimeStruct& getDateTime() const { return std::get<3>(values_); }
        inline void setDateTime(const DateTimeStruct& _value) { std::get<3>(values_) = _value; }
        inline const WeekdaysVec& getWeekdays() const { return std::get<4>(values_); }
        inline void setWeekdays(const WeekdaysVec& _value) { std::get<4>(values_) = _value; }
        inline bool operator==(const ParkingTimerStruct& _other) const {
            return (getTimerId() == _other.getTimerId() && getTimerType() == _other.getTimerType() &&
                    getActive() == _other.getActive() && getDateTime() == _other.getDateTime() &&
                    getWeekdays() == _other.getWeekdays());
        }
        inline bool operator!=(const ParkingTimerStruct& _other) const { return !((*this) == _other); }
    };
    typedef std::vector<ParkingClimate::ParkingTimerStruct> ParkingTimers;
};

}  // namespace climate
}  // namespace volvocars
}  // namespace org
}  // namespace v0

namespace CommonAPI {}

// Compatibility
namespace v0_1 = v0;
