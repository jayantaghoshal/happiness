/*===========================================================================*\
* Copyright 2017 Delphi Technologies, Inc., All Rights Reserved.
* Delphi Confidential
\*===========================================================================*/

#ifndef ECDDATAELEMENT_H
#define ECDDATAELEMENT_H

/*!
 * \file
 *
 * \brief This file is used if you want to listen on out signals or inject in signals into the IHU/MP.
 *
 * It provides access to DESink (used to listen on out signals) and
 * DEInjector (used to inject in signals into the system).
 *
 * !!! DEInjector shall most likely NEVER be used unless you know exactly what you are doing !!!
 */

#include "dataelementframework.h"
#include "jsonserializers.h"
#include "callbackwrapper.h"

namespace ECDDataElement {

/*!
 * \brief DEInjector, template class used to inject signals into the MP.
 *
 * The class is template instantiated with the classes declared in gen_dataelements.h
 * that inherits from InTag.
 *
 * Example:
 * \code
 * DEInjector<autosar::ADataRawSafe_info> mySignal;
 * mySignal.inject(...);
 * mySignal.error(0);
 * \endcode
 */
template<typename S>
class DEInjector {
static_assert(std::is_base_of<autosar::InTag, S>::value, "Only for IN Data Elements");
public:
    /*!
     * \brief Inject a value for the signal represented by the DEInjector instance.
     *
     * \param deValue The value to inject. Its type is given from the DEInjector template class S::data_elem_type
     * Most of these types are declared in gen_datatypes.h but for simple types like bool, int etc the type is shown directly
     * in gen_dataelements.h
     * \param timestamp The timestamp in milliseconds since Jan 1, 1970 UTC (https://en.wikipedia.org/wiki/Unix_time).
     * A timestamp will automatically be generated by the framework if not provided by the caller.
     */
    void inject( const typename S::data_elem_type& deValue, long long timestamp=-1 ) {
        DataElementFramework::instance().inject<S>(deValue, timestamp);
    }

    /*!
     * \brief Inject a signal error for the signal.
     * \param errorCode The errorCode. See dataelemvalue.h, type SignalErrorCode, for details.
     * \param timestamp The timestamp in milliseconds since Jan 1, 1970 UTC (https://en.wikipedia.org/wiki/Unix_time).
     * A timestamp will automatically be generated by the framework if not provided by the caller.
     */
    void error( int errorCode, long long timestamp=-1 ) {
        DataElementFramework::instance().injectError<S>(errorCode, timestamp);
    }
};

/*!
 * \brief DESink, template class used to listen on (get + subscribe) signals that are sent out from the MP.
 *
 * The class is template instantiated with the classes declared in gen_dataelements.h
 * that inherits from the OutTag.
 */
template<typename S>
class DESink : public INewDataElement {
static_assert(std::is_base_of<autosar::OutTag, S>::value, "Only for OUT Data Elements");
public:
    DESink() : _value(DataElementFramework::instance().subscribe<S>(this)) {}

    virtual ~DESink() {
        DataElementFramework::instance().unsubscribe(S::Name(), this);
    }

    virtual void newDataElementValue(const DataElemValueBase& newvalue) {
        _value = dynamic_cast<const DataElemValue<S>&>(newvalue);
    }

    virtual void performCallback() {
        std::unique_lock<std::mutex> protectCallback(setCallbackMutex);
        _callback(_value);
    }

    /*!
     * \brief Subscribe to changes in the signal state and/or value.
     * \param callback A callback that will be called once the state and/or value
     * of the signal has changed. Example:
     * \code
     * DESink<autosar::AccAdprSpdLimActv_info> outSignal;
     * autosar::OnOffPen myValue = outSignal.get().value();
     * outSignal.subscribe([&]() {
     *    // do something with the out-signal
     *    auto v = outSignal.get().value();
     *    :
     * });
     * \endcode
     */
    void subscribe( const std::function<void()>& callback ) {
        const bool hasValidValue = (_value.isOk() || (_value.isError() && _value.errorCode()!=-1));

        {
            std::unique_lock<std::mutex> protectCallback(setCallbackMutex);
            _callback.set(callback);
        }

        if ( callback != nullptr && hasValidValue) {
            // performing direct callback since we have a valid value
            callback();
        }
    }

    /*!
     * \brief Subscribe to changes in the signal state and/or value.
     * \param callback A callback that will be called once the state and/or value
     * of the signal has changed. The callback contains the signalvalue.
     * If you use C++14 then use it like this:
     * \code
     * DESink<autosar::AccAdprSpdLimActv_info> myOutSignal;
     * myOutSignal.subscribeVal([](auto signalValue) {
     *    // do something with the out-signal
     *    if ( signalValue.isOk() ) {
     *       :
     *    }
     *    :
     * });
     * \endcode
     *
     * If you use ancient C++11 use it like this:
     * \code
     * DESink<autosar::AccAdprSpdLimActv_info> myOutSignal;
     * myOutSignal.subscribeVal([](DataElemValue<autosar::AccAdprSpdLimActv_info> signalValue) {
     *    // do something with the out-signal
     *    if ( signalValue.isOk() ) {
     *       :
     *    }
     *    :
     * });
     * \endcode
     */
    void subscribeVal( const std::function<void(const DataElemValue<S>&)>& callback ) {
        const bool hasValidValue = (_value.isOk() || (_value.isError() && _value.errorCode()!=-1));

        {
            std::unique_lock<std::mutex> protectCallback(setCallbackMutex);
            _callback.set(callback);
        }

        if ( callback != nullptr && hasValidValue) {
            // performing direct callback since we have a valid value
            callback(_value);
        }
    }

    /*!
     * \brief Get signal information from the DESink instance.
     * The value received from get() provides information about the signal state and also the real signal value.
     * An out signal received with DESink ALWAYS has the state==OK (in contrast to an in signal
     * received with DEReceiver which can have the state OK or ERROR).
     *
     * Normally it is used something like this:
     * \code
     * auto value = sinkSignal.get().value();
     * \endcode
     */
    DataElemValue<S> get() const {
        return _value;
    }

private:
    // These have no meaning really
    DESink(const DESink&)=delete;
    DESink(const DESink&&)=delete;
    DESink& operator=(const DESink&)=delete;
    DESink& operator=(const DESink&&)=delete;

    std::mutex setCallbackMutex;
    CallbackWrapper<DataElemValue<S>> _callback;
    DataElemValue<S> _value;
};

} // end of namespace
#endif // ECDDATAELEMENT_H

