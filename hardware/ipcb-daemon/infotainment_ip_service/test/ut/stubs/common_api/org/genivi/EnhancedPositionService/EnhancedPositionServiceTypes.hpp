/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef ORG_GENIVI_ENHANCEDPOSITIONSERVICE_Enhanced_Position_Service_Types_HPP_
#define ORG_GENIVI_ENHANCEDPOSITIONSERVICE_Enhanced_Position_Service_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace org {
namespace genivi {
namespace EnhancedPositionService {

struct EnhancedPositionServiceTypes {
    typedef uint64_t Timestamp;
    /**
     * description: bitmask obtained as a result of an OR operation on enum values of type
     *   PositionInfoKey
     */
    typedef uint64_t Bitmask;
    /**
     * description: version
     */
    struct Version : CommonAPI::Struct<uint16_t, uint16_t, uint16_t, std::string> {
    	
    	Version() {
    	}
    	Version(const uint16_t &_maj, const uint16_t &_min, const uint16_t &_mic, const std::string &_date)
    	{
    		std::get<0>(values_) = _maj;
    		std::get<1>(values_) = _min;
    		std::get<2>(values_) = _mic;
    		std::get<3>(values_) = _date;
    	}
    	/**
    	 * description: when the major changes, then backward compatibility with previous releases is
    	 *   not granted
    	 */
    	inline const uint16_t &getMaj() const { return std::get<0>(values_); }
    	inline void setMaj(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: when the minor changes, then backward compatibility with previous releases is
    	 *   granted, but something changed in the implementation of the API (e.g. new
    	 *   methods may have been added)
    	 */
    	inline const uint16_t &getMin() const { return std::get<1>(values_); }
    	inline void setMin(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: when the micro changes, then backward compatibility with previous releases is
    	 *   granted (bug fixes or documentation modifications)
    	 */
    	inline const uint16_t &getMic() const { return std::get<2>(values_); }
    	inline void setMic(const uint16_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: release date (e.g. 21-06-2011)
    	 */
    	inline const std::string &getDate() const { return std::get<3>(values_); }
    	inline void setDate(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const Version& _other) const {
                return (getMaj() == _other.getMaj() && getMin() == _other.getMin() && getMic() == _other.getMic() && getDate() == _other.getDate());
        }
    	inline bool operator!=(const Version &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Value = generic value (mapped to a dbus variant ('v') data type)
     */
    typedef CommonAPI::Variant<uint64_t, double, float, std::string>  Value;
    
    struct PositionInfoKey : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LATITUDE = 1,
            LONGITUDE = 2,
            ALTITUDE = 4,
            HEADING = 8,
            SPEED = 16,
            CLIMB = 32,
            ROLL_RATE = 64,
            PITCH_RATE = 128,
            YAW_RATE = 256,
            PDOP = 512,
            HDOP = 1024,
            VDOP = 2048,
            USED_SATELLITES = 4096,
            TRACKED_SATELLITES = 8192,
            VISIBLE_SATELLITES = 16384,
            SIGMA_HPOSITION = 32768,
            SIGMA_ALTITUDE = 65536,
            SIGMA_HEADING = 131072,
            SIGMA_SPEED = 262144,
            SIGMA_CLIMB = 524288,
            GNSS_FIX_STATUS = 1048576,
            DR_STATUS = 2097152,
            RELIABILTY_INDEX = 4194304,
            DR_PURE_DISTANCE = 8388608
        };
        
        PositionInfoKey() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LATITUDE)) {}
        PositionInfoKey(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LATITUDE):
                case static_cast<int32_t>(Literal::LONGITUDE):
                case static_cast<int32_t>(Literal::ALTITUDE):
                case static_cast<int32_t>(Literal::HEADING):
                case static_cast<int32_t>(Literal::SPEED):
                case static_cast<int32_t>(Literal::CLIMB):
                case static_cast<int32_t>(Literal::ROLL_RATE):
                case static_cast<int32_t>(Literal::PITCH_RATE):
                case static_cast<int32_t>(Literal::YAW_RATE):
                case static_cast<int32_t>(Literal::PDOP):
                case static_cast<int32_t>(Literal::HDOP):
                case static_cast<int32_t>(Literal::VDOP):
                case static_cast<int32_t>(Literal::USED_SATELLITES):
                case static_cast<int32_t>(Literal::TRACKED_SATELLITES):
                case static_cast<int32_t>(Literal::VISIBLE_SATELLITES):
                case static_cast<int32_t>(Literal::SIGMA_HPOSITION):
                case static_cast<int32_t>(Literal::SIGMA_ALTITUDE):
                case static_cast<int32_t>(Literal::SIGMA_HEADING):
                case static_cast<int32_t>(Literal::SIGMA_SPEED):
                case static_cast<int32_t>(Literal::SIGMA_CLIMB):
                case static_cast<int32_t>(Literal::GNSS_FIX_STATUS):
                case static_cast<int32_t>(Literal::DR_STATUS):
                case static_cast<int32_t>(Literal::RELIABILTY_INDEX):
                case static_cast<int32_t>(Literal::DR_PURE_DISTANCE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PositionInfoKey &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PositionInfoKey &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PositionInfoKey &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PositionInfoKey &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PositionInfoKey &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PositionInfoKey &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: PositionInfo = array of tuples (key,value)         key = enumeration
     *   PositionInfoKey         key = LATITUDE, value = value of type 'Double', that
     *   expresses the latitude of the current position. Range [-90:+90]. Example:
     *   48.053250         key = LONGITUDE, value = value of type 'Double', that
     *   expresses the longitude of the current position. Range [-180:+180]. Example:
     *   8.324500         key = ALTITUDE, value = value of type 'Double', that
     *   expresses the altitude above the sea level of the current position in meters  
     *         key = HEADING, value = value of type 'Double', that expresses the course
     *   angle in degree. Range [0:360]. 0 = north, 90 = east, 180 = south, 270 = west 
     *          key = SPEED, value = value of type 'Double', that expresses speed
     *   measured in m/s. A negative value indicates that the vehicle is moving
     *   backwards         key = CLIMB, value = value of type 'Double', that expresses
     *   the road gradient in degrees         key = ROLL_RATE, value = value of type
     *   'Double', rotation rate around the X-axis in degrees/s. Range [-100:+100]     
     *      key = PITCH_RATE, value = value of type 'Double', rotation rate around the
     *   Y-axis in degrees/s. Range [-100:+100]         key = YAW_RATE, value = value
     *   of type 'Double', rotation rate around the Z-axis in degrees/s. Range
     *   [-100:+100]         key = PDOP, value = value of type 'Double', that
     *   represents the positional (3D) dilution of precision         key = HDOP, value
     *   = value of type 'Double', that represents the horizontal (2D) dilution of
     *   precision         key = VDOP, value = value of type 'Double', that represents
     *   vertical (altitude) dilution of precision         key = USED_SATELLITES, value
     *   = value of type 'UInt8', that represents the number of used satellites        
     *   key = TRACKED_SATELLITES, value = value of type 'UInt8', that represents the
     *   number of tracked satellites          key = VISIBLE_SATELLITES, value = value
     *   of type 'UInt8', that represents the number of visible satellites         key
     *   = SIGMA_HPOSITION, value = value of type 'Double', that represents the
     *   standard deviation for the horizontal position in m         key =
     *   SIGMA_ALTITUDE, value = value of type 'Double', that represents the standard
     *   deviation for altitude in m         key = SIGMA_HEADING, value = value of type
     *   'Double', that represents the standard deviation for altitude in degrees      
     *     key = SIGMA_SPEED, value = value of type 'Double', that represents the
     *   standard error estimate of the speed in m/s</line>         key = SIGMA_CLIMB,
     *   value = value of type 'Double', that represents the standard error estimate of
     *   the climb in degrees</line>         key = GNSS_FIX_STATUS, value = value of
     *   type 'UInt16', that represents an
     *   enum(NO_FIX(0x01),TIME_FIX(0x01),2D_FIX(0x02),3D_FIX(0x03), ... )         key
     *   = DR_STATUS, value = value of type 'Boolean', where TRUE means that a
     *   dead-reckoning algorithm has been used to calculate the current position      
     *     key = DR_PURE_DISTANCE, value = value of type 'Double', the distance driven
     *   in pure DR is defined as a distance driven without any corrections to valid
     *   GNSS in m/s
     */
    typedef std::unordered_map<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionInfoKey, ::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::Value, CommonAPI::EnumHasher<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionInfoKey>> PositionInfo;
    
    struct SatelliteSystem : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            GPS = 1,
            GLONASS = 2,
            GALILEO = 3,
            COMPASS = 4
        };
        
        SatelliteSystem() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::GPS)) {}
        SatelliteSystem(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::GPS):
                case static_cast<int32_t>(Literal::GLONASS):
                case static_cast<int32_t>(Literal::GALILEO):
                case static_cast<int32_t>(Literal::COMPASS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SatelliteSystem &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SatelliteSystem &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SatelliteSystem &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SatelliteSystem &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SatelliteSystem &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SatelliteSystem &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: SatelliteInfo = array(struct(system,satelliteId,azimuth,elevation,snr,inUse))  
     *             system = enum(GPS, GLONASS, GALILEO, COMPASS, ... )            
     *   satelliteId = satellite ID. This ID is unique within one satellite system     
     *          azimuth = satellite azimuth in degrees. Value range 0..359            
     *   elevation = satellite elevation in degrees. Value range 0..90             snr
     *   = SNR (C/No) in dBHz. Range 0 to 99, null when not tracking             inUse
     *   = flag indicating if the satellite is used for the fix (inUse=true)
     */
    struct SatelliteInfo : CommonAPI::Struct<SatelliteSystem, uint32_t, uint32_t, uint32_t, uint32_t, bool> {
    	
    	SatelliteInfo() {
    		std::get<5>(values_) = false;
    	}
    	SatelliteInfo(const SatelliteSystem &_system, const uint32_t &_satellitId, const uint32_t &_azimuth, const uint32_t &_elevation, const uint32_t &_snr, const bool &_inUse)
    	{
    		std::get<0>(values_) = _system;
    		std::get<1>(values_) = _satellitId;
    		std::get<2>(values_) = _azimuth;
    		std::get<3>(values_) = _elevation;
    		std::get<4>(values_) = _snr;
    		std::get<5>(values_) = _inUse;
    	}
    	inline const SatelliteSystem &getSystem() const { return std::get<0>(values_); }
    	inline void setSystem(const SatelliteSystem &_value) { std::get<0>(values_) = _value; }
    	inline const uint32_t &getSatellitId() const { return std::get<1>(values_); }
    	inline void setSatellitId(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline const uint32_t &getAzimuth() const { return std::get<2>(values_); }
    	inline void setAzimuth(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	inline const uint32_t &getElevation() const { return std::get<3>(values_); }
    	inline void setElevation(const uint32_t &_value) { std::get<3>(values_) = _value; }
    	inline const uint32_t &getSnr() const { return std::get<4>(values_); }
    	inline void setSnr(const uint32_t &_value) { std::get<4>(values_) = _value; }
    	inline const bool &getInUse() const { return std::get<5>(values_); }
    	inline void setInUse(const bool _value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const SatelliteInfo& _other) const {
                return (getSystem() == _other.getSystem() && getSatellitId() == _other.getSatellitId() && getAzimuth() == _other.getAzimuth() && getElevation() == _other.getElevation() && getSnr() == _other.getSnr() && getInUse() == _other.getInUse());
        }
    	inline bool operator!=(const SatelliteInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct TimeInfoKey : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            YEAR = 16777216,
            MONTH = 33554432,
            DAY = 67108864,
            HOUR = 134217728,
            MINUTE = 268435456,
            SECOND = 536870912,
            MS = 1073741824
        };
        
        TimeInfoKey() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::YEAR)) {}
        TimeInfoKey(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::YEAR):
                case static_cast<int32_t>(Literal::MONTH):
                case static_cast<int32_t>(Literal::DAY):
                case static_cast<int32_t>(Literal::HOUR):
                case static_cast<int32_t>(Literal::MINUTE):
                case static_cast<int32_t>(Literal::SECOND):
                case static_cast<int32_t>(Literal::MS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TimeInfoKey &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TimeInfoKey &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TimeInfoKey &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TimeInfoKey &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TimeInfoKey &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TimeInfoKey &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: TimeInfo = array of tuples (key,value)         key = enumeration TimeInfoKey   
     *        key = YEAR, value = value of type 'UInt16', 4 digits number that
     *   indicates the year. Example: 2012         key = MONTH, value = value of type
     *   'UInt8', 2 digits number that indicates the month. Example: 03 means March    
     *       key = DAY, value = value of type 'UInt8', 2 digits number that indicates
     *   the day. Range [0:31]. Example: 07         key = HOUR, value = value of type
     *   'UInt8', 2 digits number that indicates the hour. Range [0:23].  Example: 01  
     *         key = MINUTE, value = value of type 'UInt8', 2 digits number that
     *   represents the minutes. Range [0:59]. Example: 01         key = SECOND, value
     *   = value of type 'UInt8', 2 digits number that represents the seconds. Range
     *   [0:59]. Example: 01         key = MS, value = value of type 'UInt16', 3 digits
     *   number that represents the milliseconds. Range [0:999]. Example: 007
     */
    typedef std::unordered_map<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::TimeInfoKey, ::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::Value, CommonAPI::EnumHasher<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::TimeInfoKey>> TimeInfo;
    
    struct PositionFeedbackKey : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LATITUDE = 1,
            LONGITUDE = 2,
            ALTITUDE = 4,
            HEADING = 8,
            SPEED = 16,
            CLIMB = 32,
            RELIABILTY_INDEX = 64
        };
        
        PositionFeedbackKey() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LATITUDE)) {}
        PositionFeedbackKey(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LATITUDE):
                case static_cast<int32_t>(Literal::LONGITUDE):
                case static_cast<int32_t>(Literal::ALTITUDE):
                case static_cast<int32_t>(Literal::HEADING):
                case static_cast<int32_t>(Literal::SPEED):
                case static_cast<int32_t>(Literal::CLIMB):
                case static_cast<int32_t>(Literal::RELIABILTY_INDEX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PositionFeedbackKey &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PositionFeedbackKey &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PositionFeedbackKey &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PositionFeedbackKey &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PositionFeedbackKey &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PositionFeedbackKey &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct PositionFeedbackType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            MAP_MATCHED_FEEDBACK = 1,
            TEST_FEEDBACK = 2
        };
        
        PositionFeedbackType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::MAP_MATCHED_FEEDBACK)) {}
        PositionFeedbackType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MAP_MATCHED_FEEDBACK):
                case static_cast<int32_t>(Literal::TEST_FEEDBACK):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PositionFeedbackType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PositionFeedbackType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PositionFeedbackType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PositionFeedbackType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PositionFeedbackType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PositionFeedbackType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: PositionFeedback = array of tuples (key,value)</line>           key =
     *   enum(LATITUDE,LONGITUDE,ALTITUDE,HEADING,SPEED,CLIMB,RELIABILTY_INDEX, ...
     *   )</line>           key = LATITUDE, value = value of type Â´dÂ´, that expresses
     *   the latitude of the current position in format %3.6f. [-90,+90]. Example:
     *   48.053250           key = LONGITUDE, value = value of type Â´dÂ´, that
     *   expresses the longitude of the current position in format %3.6f. [-180,+180].
     *   Example: 8.324500            key = ALTITUDE, value = value of type Â´iÂ´, that
     *   expresses the altitude above the sea level of the current position in meters  
     *           key = HEADING, value = value of type Â´iÂ´, that expresses the course
     *   angle in degree. [0,360]. Example: 0 => north, 90 => east, 180 => south, 270
     *   => west           key = SPEED, value = value of type Â´dÂ´, that expresses
     *   speed measured in m/s           key = CLIMB, value = value of type Â´iÂ´, that
     *   expresses the inclination measured in degrees           key =
     *   RELIABILTY_INDEX, value = value of type Â´yÂ´, that indicates the position
     *   feedabck reliabilty. It can assume values from 0 to 100
     */
    typedef std::unordered_map<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionFeedbackType, ::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::Value, CommonAPI::EnumHasher<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionFeedbackType>> PositionFeedbackInfo;



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.genivi.EnhancedPositionService.EnhancedPositionServiceTypes";
    return typeCollectionName;
}


}; // struct EnhancedPositionServiceTypes

} // namespace EnhancedPositionService
} // namespace genivi
} // namespace org

namespace CommonAPI {
}


namespace std {
    //Hash for PositionInfoKey
    template<>
    struct hash<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionInfoKey> {
        inline size_t operator()(const ::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionInfoKey& positionInfoKey) const {
            return static_cast<int32_t>(positionInfoKey);
        }
    };
    //Hash for SatelliteSystem
    template<>
    struct hash<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::SatelliteSystem> {
        inline size_t operator()(const ::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::SatelliteSystem& satelliteSystem) const {
            return static_cast<int32_t>(satelliteSystem);
        }
    };
    //Hash for TimeInfoKey
    template<>
    struct hash<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::TimeInfoKey> {
        inline size_t operator()(const ::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::TimeInfoKey& timeInfoKey) const {
            return static_cast<int32_t>(timeInfoKey);
        }
    };
    //Hash for PositionFeedbackKey
    template<>
    struct hash<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionFeedbackKey> {
        inline size_t operator()(const ::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionFeedbackKey& positionFeedbackKey) const {
            return static_cast<int32_t>(positionFeedbackKey);
        }
    };
    //Hash for PositionFeedbackType
    template<>
    struct hash<::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionFeedbackType> {
        inline size_t operator()(const ::org::genivi::EnhancedPositionService::EnhancedPositionServiceTypes::PositionFeedbackType& positionFeedbackType) const {
            return static_cast<int32_t>(positionFeedbackType);
        }
    };
}



#endif // ORG_GENIVI_ENHANCEDPOSITIONSERVICE_Enhanced_Position_Service_Types_HPP_
