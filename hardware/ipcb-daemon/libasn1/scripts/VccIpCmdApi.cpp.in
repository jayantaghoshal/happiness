
#include "ipcommandbus/VccIpCmdApi.h"

/*
 * This file is automatically generated from the template '$(TEMPLATE_FILE)'
 */

#include <cstdio>
#include <vector>

namespace Connectivity
{

namespace VccIpCmd
{

bool ServiceIdIsValid(ServiceId id)
{
    switch (id)
    {
        $(SERVICE_ID_VALID_FUNCTION)
        return true;
    case ServiceId::Undefined:
    default:
        return false;
    }
}

CombinedId::CombinedId(ServiceId _sid, OperationId _oid) : parts{_sid, _oid}
{
}

bool CombinedId::operator==(const CombinedId &id) const
{
    return (id.combined == combined);
}

std::string toString(ServiceId sid)
{
    struct ServiceIdStringMapping
    {
        ServiceId id;
        const char *serviceIdString;
    };

    static const std::vector<ServiceIdStringMapping>
        serviceIdStringMapping = {
            $(SERVICEID_STRING_MAPPING)};

    std::string idString = std::string("ServiceId=") + std::to_string(static_cast<std::uint16_t>(sid));
    for (const ServiceIdStringMapping &element : serviceIdStringMapping)
    {
        if (element.id == sid)
        {
            idString = element.serviceIdString;
            break;
        }
    }
    return idString;
}

std::string toString(ServiceId sid, OperationId oid, const char *separator)
{
    struct OperationIdStringMapping
    {
        CombinedId id;
        const char *operationIdString;
    };

    static const std::vector<OperationIdStringMapping>
        operationIdStringMapping = {
            $(COMBINEDID_STRING_MAPPING)};

    std::string idString = toString(sid);
    for (const OperationIdStringMapping &element : operationIdStringMapping)
    {
        if (element.id.parts.serviceId == sid && element.id.parts.operationId == oid)
        {
            idString += separator;
            idString += element.operationIdString;
            break;
        }
    }

    return idString;
}

std::string toString(const CombinedId &id, const char *separator)
{
    return toString(id.parts.serviceId, id.parts.operationId, separator);
}

const char *toString(OperationType ot)
{
    switch (ot)
    {
    case OperationType::REQUEST:
        return "REQUEST";
    case OperationType::SETREQUEST_NORETURN:
        return "SETREQUEST_NORETURN";
    case OperationType::SETREQUEST:
        return "SETREQUEST";
    case OperationType::NOTIFICATION_REQUEST:
        return "NOTIFICATION_REQUEST";
    case OperationType::RESPONSE:
        return "RESPONSE";
    case OperationType::NOTIFICATION:
        return "NOTIFICATION";
    case OperationType::NOTIFICATION_CYCLIC:
        return "NOTIFICATION_CYCLIC";
    case OperationType::ACK:
        return "ACK";
    case OperationType::ERROR:
        return "ERROR";
    case OperationType::UNDEFINED:
        return "UNDEFINED";
    default:
        return "<Unknown>";
    }
}

const char *toString(DataType dt)
{
    switch (dt)
    {
    case DataType::ENCODED:
        return "ENCODED";
    case DataType::NOT_ENCODED:
        return "NOT_ENCODED";
    case DataType::UNDEFINED:
        return "UNDEFINED";
    default:
        return "<Unknown>";
    }
}

} // VccIpCmd
} // Connectivity
