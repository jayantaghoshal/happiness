/*@@var:*/
variables
{
  //
  // Constants
  //

  // Ethernt Type
  const WORD kEthernetTypeIPv4  = 0x0800;
  const WORD kEthernetTypeARP   = 0x0806;

  // IPv4 protocols
  const BYTE kIPv4_Protocol_UDP = 0x11;

  //
  // Structure for MAC ID
  //
  _align(1) struct EthMacId
  {
    BYTE part[6]; // part of MAC ID
  };

  struct EthMacId kBroadcastEthernet = { part = { 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF } };

  //
  // Structure for Ethernet Header
  //
  _align(1) struct EthHeader 
  {
    struct EthMacId ethDest;   // Destination MAC ID
    struct EthMacId ethSource; // Source MAC ID
    WORD            ethType;   // Ethernet Type
  };

  //
  // Structure for IPv4 Address
  //
  _align(1) struct IPv4Address
  {
    BYTE part[4]; // part of
  };

  struct IPv4Address kBroadcastIPv4 = { part = { 0xFF,0xFF,0xFF,0xFF } };

  //
  // Structure for a IPv4 header
  //
  _align(1) struct IPv4Header
  {
    BYTE version_ihl;           // IP Version and header length in 32 bit words
    BYTE typeOfService;         // Type of service
    WORD totalLength;           // Total length of the packet in bytes
    WORD identfitication;       // Identification value for fragmentation
    WORD flags_offset;          // flags (4 bits) and fragmentation offset (12 bits)
    BYTE timeToLive;            // Time to live
    BYTE protocol;              // Protocol
    WORD headerChecksum;        // Checksum of the header
    struct IPv4Address srcAddr; // IP source address
    struct IPv4Address dstAddr; // IP destination address
  };


  //
  // Structure for a UDP header
  //
  _align(1) struct UDPHeader
  {
    WORD srcPort;     // Source UDP port
    WORD dstPort;     // Source DST port
    WORD length;      // Length of header and data
    WORD checksum;    // Check sum of pseudo header
  };


  //
  // Structure for a ARP packets (for Ethernet and IPv4)
  //
  _align(1) struct ARPPacket
  {
    struct EthHeader eth; // Ethernet header

    WORD hwType;                   // Hardware type
    WORD protAddrType;             // Protocol address type
    BYTE hwAddrSize;               // Hardware address size
    BYTE protAddrSize;             // Protocol address size
    WORD operation;                // Operation, 1=Request, 2=Response

    struct EthMacId    srcMacAddr; // Source MAC address
    struct IPv4Address srcIPAddr;  // Source IP address
    struct EthMacId    dstMacAddr; // Source MAC address
    struct IPv4Address dstIPAddr;  // Source IP address
  };
}
/*@@end*/

/*@@caplFunc:EthGetMacIdFromString(EthMacId,char[]):*///function
int EthGetMacIdFromString( struct EthMacId retMacId, char macId[] )
{
  char str[10] = "0x00";

  // part1 of MAC ID
  retMacId.part[0] = UtilGetHexNum( macId, 0 );

  // part2 of MAC ID
  retMacId.part[1] =  UtilGetHexNum( macId, 3 );

  // part3 of MAC ID
  retMacId.part[2] =  UtilGetHexNum( macId, 6 );

  // part4 of MAC ID
  retMacId.part[3] =  UtilGetHexNum( macId, 9 );

  // part5 of MAC ID
  retMacId.part[4] =  UtilGetHexNum( macId, 12 );

  // part6 of MAC ID
  retMacId.part[5] =  UtilGetHexNum( macId, 15 );

  return 0;
}
/*@@end*/

/*@@caplFunc:EthGetBroadcastMacId(EthMacId):*///function
void EthGetBroadcastMacId( struct EthMacId retMacId )
{
  retMacId.part[0] = 0xFF;
  retMacId.part[1] = 0xFF;
  retMacId.part[2] = 0xFF;
  retMacId.part[3] = 0xFF;
  retMacId.part[4] = 0xFF;
  retMacId.part[5] = 0xFF;
}
/*@@end*/

/*@@caplFunc:IPv4CalcHeaderChecksum(IPv4Header):*///function
/*
 * Calculate IPv4 header checksum
 */
WORD IPv4CalcHeaderChecksum( struct IPv4Header header )
{
  DWORD sum;
  WORD  val;
  BYTE headerData[20], swp;
  INT  i;
  
  header.headerChecksum = 0;

  memcpy( headerData, header );

  // convert little to big endian
  // total length
/*
  swp = headerData[2];
  headerData[2] = headerData[3];
  headerData[3] = swp;
  // identification
  swp = headerData[4];
  headerData[4] = headerData[5];
  headerData[5] = swp;
  // flags and offset
  swp = headerData[6];
  headerData[6] = headerData[7];
  headerData[7] = swp;
*/

  sum = 0;
  for( i = 0; i < 20; i += 2 ) {
    val  = ((((WORD)headerData[i]) << 8) & 0xFF00) | ((WORD)headerData[i+1] & 0x00FF);
    sum += val;
  }

  while(sum >> 16) {
    sum = (sum & 0xFFFF) + ((sum >> 16) & 0xFFFF);
  }

  sum                   = ~sum;
  header.headerChecksum = swapWord( sum );

  return sum; 
}
/*@@end*/

/*@@caplFunc:IPv4GetAddress(IPv4Address,char[]):*///function
int IPv4GetAddress( struct IPv4Address retAddr, char ipAddr[] )
{
  char str[5];
  int  pos;

  // part1 of MAC ID
  pos = 0;
  substr_cpy( str, ipAddr, pos, 3, 4 );
  retAddr.part[0] = atol(str );

  // part2 of MAC ID
  pos = strstr_off( ipAddr, pos+1, "." );
  substr_cpy( str, ipAddr, pos+1, 3, 4 );
  retAddr.part[1] = atol(str );

  // part3 of MAC ID
  pos = strstr_off( ipAddr, pos+1,"." );
  substr_cpy( str, ipAddr, pos+1, 3, 4 );
  retAddr.part[2] = atol(str );

  // part4 of MAC ID
  pos = strstr_off( ipAddr, pos+1, "." );
  substr_cpy( str, ipAddr, pos+1, 3, 4 );
  retAddr.part[3] = atol(str );

  return 0;
}
/*@@end*/

/*@@caplFunc:ARPInitRequest(ARPPacket,EthMacId,IPv4Address,IPv4Address):*///function
/*
 * Fill an ARP packet with data for an ARP request
 */
void ARPInitRequest( struct ARPPacket packet, struct EthMacId srcMacAddr, struct IPv4Address srcIPAddr, struct IPv4Address dstIPAddr )
{
  // set Ethernet header
  memcpy( packet.eth.ethSource, srcMacAddr );
  memcpy( packet.eth.ethDest, kBroadcastEthernet );

  packet.eth.ethType = swapWord( kEthernetTypeARP );

  // set ARP fields
  packet.hwType       = swapWord( 1 ); // Ethernet type
  packet.protAddrType = swapWord( kEthernetTypeIPv4 );
  packet.hwAddrSize   = 6;
  packet.protAddrSize = 4;
  packet.operation    = swapWord( 1 ); // ARP request

  memcpy( packet.srcMacAddr, srcMacAddr );
  memcpy( packet.srcIPAddr , srcIPAddr );
  memcpy( packet.dstMacAddr, kBroadcastEthernet );
  memcpy( packet.dstIPAddr , dstIPAddr );
}
/*@@end*/

/*@@caplFunc:ARPInitResponse(ARPPacket,EthMacId,IPv4Address,EthMacId,IPv4Address):*///function
/*
 * Fill an ARP packet with data for an ARP response
 */
void ARPInitResponse( struct ARPPacket packet, struct EthMacId srcMacAddr, struct IPv4Address srcIPAddr, struct EthMacId dstMacAddr, struct IPv4Address dstIPAddr )
{
  // set Ethernet header
  memcpy( packet.eth.ethSource, srcMacAddr );
  memcpy( packet.eth.ethDest, kBroadcastEthernet );

  packet.eth.ethType = swapWord( kEthernetTypeARP );

  // set ARP fields
  packet.hwType       = swapWord( 1 ); // Ethernet type
  packet.protAddrType = swapWord( kEthernetTypeIPv4 );
  packet.hwAddrSize   = 6;
  packet.protAddrSize = 4;
  packet.operation    = swapWord( 2 ); // ARP response

  memcpy( packet.srcMacAddr, srcMacAddr );
  memcpy( packet.srcIPAddr , srcIPAddr );
  memcpy( packet.dstMacAddr, dstMacAddr );
  memcpy( packet.dstIPAddr , dstIPAddr );
}
/*@@end*/

/*@@caplFunc:UtilGetHexNum(char[],int):*///function
LONG UtilGetHexNum( char text[], int offset )
{
  CHAR c1, c2;
  LONG digit1, digit2;

  if (offset+1 < strlen(text)) {
    c1 = text[offset];
    c2 = text[offset+1];

    // digit 1
    if ((c1 >= '0') && (c1 <= '9')) {
      digit1 = c1 - '0';
    }
    else if ((c1 >= 'A') && (c1 <= 'F')) {
      digit1 = c1 - 'A' + 10;
    }
    else if ((c1 >= 'a') && (c1 <= 'f')) {
      digit1 = c1 - 'a' + 10;
    }

    // digit 2
    if ((c2 >= '0') && (c2 <= '9')) {
      digit2 = c2 - '0';
    }
    else if ((c2 >= 'A') && (c2 <= 'F')) {
      digit2 = c2 - 'A' + 10;
    }
    else if ((c2 >= 'a') && (c2 <= 'f')) {
      digit2 = c2 - 'a' + 10;
    }

    return ((digit1 << 4) & 0xF0) | (digit2 & 0x0F);
  }
  else {
    return 0;
  }
}
/*@@end*/

/*@@caplFunc:IPv4GetAddress(byte[],dword,char[]):*///function
int IPv4GetAddress( BYTE part[], DWORD offset, char ipAddr[] )
{
  char str[5];
  int  pos;

  // part1 of MAC ID
  pos = 0;
  substr_cpy( str, ipAddr, pos, 3, 4 );
  part[offset+0] = atol(str );

  // part2 of MAC ID
  pos = strstr_off( ipAddr, pos+1, "." );
  substr_cpy( str, ipAddr, pos+1, 3, 4 );
  part[offset+1] = atol(str );

  // part3 of MAC ID
  pos = strstr_off( ipAddr, pos+1,"." );
  substr_cpy( str, ipAddr, pos+1, 3, 4 );
  part[offset+2] = atol(str );

  // part4 of MAC ID
  pos = strstr_off( ipAddr, pos+1, "." );
  substr_cpy( str, ipAddr, pos+1, 3, 4 );
  part[offset+3] = atol(str );

  return 0;
}
/*@@end*/

/*@@caplFunc:EthGetMacIdFromString(byte[],dword,char[]):*///function
int EthGetMacIdFromString( BYTE part[], DWORD offset, char macId[] )
{
  char str[10] = "0x00";

  // part1 of MAC ID
  part[offset+0] = UtilGetHexNum( macId, 0 );

  // part2 of MAC ID
  part[offset+1] =  UtilGetHexNum( macId, 3 );

  // part3 of MAC ID
  part[offset+2] =  UtilGetHexNum( macId, 6 );

  // part4 of MAC ID
  part[offset+3] =  UtilGetHexNum( macId, 9 );

  // part5 of MAC ID
  part[offset+4] =  UtilGetHexNum( macId, 12 );

  // part6 of MAC ID
  part[offset+5] =  UtilGetHexNum( macId, 15 );

  return 0;
}
/*@@end*/

/*@@caplFunc:EthMacId2Str(byte[],dword,char[]):*///function
int EthMacId2Str( BYTE part[], DWORD offset, char macId[] )
{
  snprintf( macId, elCount(macId), "%.2X:%.2X:%.2X:%.2X:%.2X:%.2X", part[offset+0], part[offset+1], part[offset+2], part[offset+3], part[offset+4], part[offset+5] );

  return 0;
}
/*@@end*/

/*@@caplFunc:IPv4Address2Str(byte[],dword,char[]):*///function
int IPv4Address2Str( BYTE part[], DWORD offset, char ipAddr[] )
{
  snprintf( ipAddr, elCount(ipAddr), "%d.%.d.%d.%d", part[offset+0], part[offset+1], part[offset+2], part[offset+3] );

  return 0;
}
/*@@end*/

/*@@caplFunc:IPv4CalcHeaderChecksum(byte[]):*///function
/*
 * Calculate IPv4 header checksum
 */
WORD IPv4CalcHeaderChecksum( BYTE packetData[] )
{
  DWORD sum;
  WORD  val;
  INT  i;

  packetData[24] = 0;  
  packetData[25] = 0;  

  sum = 0;
  for( i = 14+0; i < 14+20; i += 2 ) {
    val  = ((((WORD)packetData[i]) << 8) & 0xFF00) | ((WORD)packetData[i+1] & 0x00FF);
    sum += val;
  }

  while(sum >> 16) {
    sum = (sum & 0xFFFF) + ((sum >> 16) & 0xFFFF);
  }

  sum               = ~sum;
  packetData[24] = (sum >> 8) & 0xFF;  
  packetData[25] = sum & 0xFF;;  

  return sum; 
}
/*@@end*/

/*@@caplFunc:UDPCalcChecksum(dword,byte[]):*///function
/*
 * Calculate UDP checksum
 */
WORD UDPCalcChecksum( DWORD packetSize, BYTE packet[] )
{
  DWORD sum;
  WORD  val;
  INT  i;

  sum = 0;

  // set checksum of packet to zero
  packet[40] = 0;
  packet[41] = 0;

  // calc checkusm of pseudo header
  // IP protocol
  val  = ((((WORD)0         ) << 8) & 0xFF00) | ((WORD)packet[23] & 0x00FF);
  sum += val;
  // UDP protocol
  val  = ((((WORD)packet[38]) << 8) & 0xFF00) | ((WORD)packet[39] & 0x00FF);
  sum += val;
  // IP addresses
  for( i = 26; i < 34; i += 2 ) {
    val  = ((((WORD)packet[i]) << 8) & 0xFF00) | ((WORD)packet[i+1] & 0x00FF);
    sum += val;
  }


  // calc checksum over UDP header and payload
  for( i = 34; i < packetSize; i += 2 ) {
    if (i + 1 >= packetSize) {
      val  = ((((WORD)packet[i]) << 8) & 0xFF00);
    }
    else {
      val  = ((((WORD)packet[i]) << 8) & 0xFF00) | ((WORD)packet[i+1] & 0x00FF);
    }
    sum += val;
  }

  while(sum >> 16) {
    sum = (sum & 0xFFFF) + ((sum >> 16) & 0xFFFF);
  }

  // set checksum of packet
  sum = ~sum;
  packet[40] = (sum >> 8) & 0xFF;
  packet[41] = (sum     ) & 0xFF;

  return sum; 
}
/*@@end*/

