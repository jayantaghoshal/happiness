"""

    Generates a clang compilation database file: compile_commands.json
        See https://clang.llvm.org/docs/JSONCompilationDatabase.html

    This file can be used to provide auto completion for C and C++

    See https://c1.confluence.cm.volvocars.biz/display/IHUA/IDE for more info

"""

import sys
import os
import os.path
import re
import argparse
import json
import shlex
import subprocess


NINJA_BINARY = "prebuilts/build-tools/linux-x86/bin/ninja"

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--output", help="Where to save generated compilation database")
    parser.add_argument("-i",
                        "--ninjafile_input",
                        help="Path to ninja-file to analyze",
                        default="out/combined-ihu_vcc-vts.ninja")
    parser.add_argument("--ninjatargets_input",
                        help="Path to a file generated by ninja -t targets option, this is optional and bypasses the ninjafile_input option " +
                              "It can be useful because generate targets can be quite slow",
                        default=None)
    args = parser.parse_args()


    working_dir = os.environ["ANDROID_BUILD_TOP"]
    if args.ninjatargets_input:
        with open(args.ninjatargets_input, "r", encoding="utf-8") as f:
            ninja_commands = f.read()
    else:
        ninja_commands = create_ninja_commands(args.ninjafile_input)

    compile_db = parse_commands(ninja_commands, working_dir)
    if os.path.isdir(args.output):
        output_path = os.path.join(args.output, "compile_commands.json")
    else:
        output_path = args.output
    write_output(compile_db, output_path)

def create_ninja_commands(ninja_file):
    return subprocess.check_output([NINJA_BINARY,
                                    "-f", ninja_file,
                                    "-t" "commands"]).decode("utf-8")

def parse_commands(ninja_log: str, working_dir: str):
    cc_compile_regex = re.compile("(.*-?g?cc )|(.*-?clang )")
    cpp_compile_regex = re.compile("(.*-?[gc]\+\+ )|(.*-?clang\+\+ )")
    bash_regex = re.compile(".*bin\/(bash)")
    cpp_file_regex = re.compile("(^.+\.c$)|(^.+\.cc$)|(^.+\.cpp$)|(^.+\.cxx$)")


    filename_flags = [
        "-o",
        "-I",
        "-isystem",
        "-iquote",
        "-include",
        "-imacros",
        "-isysroot"
    ]

    for line in ninja_log.splitlines():
        if bash_regex.match(line):
            #TODO: Handle cases where there is compiler inside a bash command, these are quite frequent
            continue

        if cc_compile_regex.match(line):
            compiler = 'cc'
        elif cpp_compile_regex.match(line):
            compiler = 'c++'
        else:
            continue

        arguments = [compiler]
        words = shlex.split(line)[1:]
        filepath = None

        for (i, word) in enumerate(words):
            if (cpp_file_regex.match(word)):
                filepath = word

            # Include arguments may or may not contain a space, ie -isystem/example/path/ vs -isystem /example/path/
            if i != len(words) - 1 and word in filename_flags and words[i + 1][0] != '-':
                w = words[i + 1]
                arguments.extend([word, w])
            else:
                arguments.append(word)
        if filepath is None:
            continue

        #if not "vendor/volvocars" in filepath:
        #    continue

        yield {
            'directory': working_dir,
            'file': filepath,
            'arguments': arguments
        }


def write_output(compile_db, output_path: str):
    with output_file(output_path) as output:
        json.dump(list(compile_db), output, indent=True)
        output.write(os.linesep)


def input_file(path):
    return sys.stdin if path is None else open(path, "r", encoding="utf-8")


def output_file(path):
    return sys.stdout if path is None else open(path, "w", encoding="utf-8")

if __name__ == "__main__":
    main()