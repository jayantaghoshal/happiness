"""

    Generates a clang compilation database file: compile_commands.json
        See https://clang.llvm.org/docs/JSONCompilationDatabase.html

    This file can be used to provide auto completion for C and C++

    See https://c1.confluence.cm.volvocars.biz/display/IHUA/IDE for more info

"""

import sys
import os
import os.path
import re
import argparse
import json
import shlex
import subprocess


NINJA_BINARY = "prebuilts/build-tools/linux-x86/bin/ninja"

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--output", help="Where to save generated compilation database")
    parser.add_argument("-i",
                        "--ninjafile_input",
                        help="Path to ninja-file to analyze",
                        default="out/combined-ihu_vcc-vts.ninja")
    parser.add_argument("--ninjatargets_input",
                        help="Path to a file generated by ninja -t targets option, this is optional and bypasses the ninjafile_input option " +
                              "It can be useful because generate targets can be quite slow",
                        default=None)
    args = parser.parse_args()
    print("Please wait, this might take 1min")

    working_dir = os.environ["ANDROID_BUILD_TOP"]
    if args.ninjatargets_input:
        with open(args.ninjatargets_input, "r", encoding="utf-8") as f:
            ninja_commands = f.read()
    else:
        ninja_commands = create_ninja_commands(args.ninjafile_input)

    compile_db = parse_commands(ninja_commands, working_dir)
    if os.path.isdir(args.output):
        output_path = os.path.join(args.output, "compile_commands.json")
    else:
        output_path = args.output
    write_output(compile_db, output_path)

def create_ninja_commands(ninja_file):
    return subprocess.check_output([NINJA_BINARY,
                                    "-f", ninja_file,
                                    "-t" "commands"]).decode("utf-8")


def parse_commands(ninja_log: str, working_dir: str):
    cc_compile_regex = re.compile("(.*-?g?cc )|(.*-?clang )")
    cpp_compile_regex = re.compile("(.*-?[gc]\+\+ )|(.*-?clang\+\+ )")
    bash_regex = re.compile(".*bin\/(bash)")
    cpp_file_regex = re.compile("(^.+\.c$)|(^.+\.cc$)|(^.+\.cpp$)|(^.+\.cxx$)")


    filename_flags = [
        "-o",
        "-I",
        "-isystem",
        "-iquote",
        "-include",
        "-imacros",
        "-isysroot"
    ]
    lines = ninja_log.splitlines()
    nr_lines = len(lines)
    next_progress = 0
    for linenr, line in enumerate(lines):
        if linenr / nr_lines > next_progress:
            next_progress += 0.05
            print("%d%%" % (linenr / nr_lines * 100))

        compiler = None

        # Compiler-invocations generated with Android.mk are always wrapped inside a bash-command
        # They usually look something like: /bin/bash -c "PWD=xxxxx clangxx argsxxxx filexxxx"
        # Android.bp creates cleaner ninja targets with only the clangxx as command
        if bash_regex.match(line):
            bash_args = shlex.split(line)
            for b in bash_args:
                if cc_compile_regex.match(b):
                    compiler = 'cc'
                    line = b
                elif cpp_compile_regex.match(b):
                    compiler = 'c++'
                    line = b
            if compiler is None:
                continue
        elif cc_compile_regex.match(line):
            compiler = 'cc'
        elif cpp_compile_regex.match(line):
            compiler = 'c++'
        else:
            continue

        arguments = [compiler]
        words = shlex.split(line)[1:]
        filepath = None


        try:
            # Android.mk generates really magic ninja files that invokes bash to include an import-file using cat.
            # This included file contains include-args to all the header dependencies.
            cat_import_includes_index = words.index("$(cat")
            import_includes_path = words[cat_import_includes_index+1][0:-1] #remove trailing ) matching the $cat(
            with open(import_includes_path, "r", encoding="utf-8") as f:
                import_includes = f.read()
            more_words = shlex.split(import_includes)
            # Replace the $cat( and include_path) args with everything from the included file
            words[cat_import_includes_index:cat_import_includes_index+2] = more_words
        except ValueError:
            pass

        skipnext = False
        for (i, word) in enumerate(words):
            if skipnext:
                skipnext = False
                continue
            if (cpp_file_regex.match(word)):
                filepath = word

            # Include arguments may or may not contain a space, ie -isystem/example/path/ vs -isystem /example/path/
            if i != len(words) - 1 and word in filename_flags and words[i + 1][0] != '-':
                w = words[i + 1]
                arguments.extend([word, w])
                skipnext = True
            else:
                arguments.append(word)
        if filepath is None:
            continue


        yield {
            'directory': working_dir,
            'file': filepath,
            'arguments': arguments
        }


def write_output(compile_db, output_path: str):
    with output_file(output_path) as output:
        json.dump(list(compile_db), output, indent=True)
        output.write(os.linesep)


def input_file(path):
    return sys.stdin if path is None else open(path, "r", encoding="utf-8")


def output_file(path):
    return sys.stdout if path is None else open(path, "w", encoding="utf-8")

if __name__ == "__main__":
    main()